/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
import * as $protobuf from "protobufjs/minimal";

// Common aliases
const $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

// Exported root namespace
const $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

export const telemetry = $root.telemetry = (() => {

    /**
     * Namespace telemetry.
     * @exports telemetry
     * @namespace
     */
    const telemetry = {};

    telemetry.v1 = (function() {

        /**
         * Namespace v1.
         * @memberof telemetry
         * @namespace
         */
        const v1 = {};

        v1.NodeSnapshot = (function() {

            /**
             * Properties of a NodeSnapshot.
             * @memberof telemetry.v1
             * @interface INodeSnapshot
             * @property {string|null} [nodeId] NodeSnapshot nodeId
             * @property {boolean|null} [connected] NodeSnapshot connected
             * @property {number|Long|null} [lastSeenUnixNano] NodeSnapshot lastSeenUnixNano
             * @property {telemetry.v1.IRegistration|null} [registration] NodeSnapshot registration
             * @property {Array.<telemetry.v1.IMetricSample>|null} [latest] NodeSnapshot latest
             */

            /**
             * Constructs a new NodeSnapshot.
             * @memberof telemetry.v1
             * @classdesc Represents a NodeSnapshot.
             * @implements INodeSnapshot
             * @constructor
             * @param {telemetry.v1.INodeSnapshot=} [properties] Properties to set
             */
            function NodeSnapshot(properties) {
                this.latest = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NodeSnapshot nodeId.
             * @member {string} nodeId
             * @memberof telemetry.v1.NodeSnapshot
             * @instance
             */
            NodeSnapshot.prototype.nodeId = "";

            /**
             * NodeSnapshot connected.
             * @member {boolean} connected
             * @memberof telemetry.v1.NodeSnapshot
             * @instance
             */
            NodeSnapshot.prototype.connected = false;

            /**
             * NodeSnapshot lastSeenUnixNano.
             * @member {number|Long} lastSeenUnixNano
             * @memberof telemetry.v1.NodeSnapshot
             * @instance
             */
            NodeSnapshot.prototype.lastSeenUnixNano = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * NodeSnapshot registration.
             * @member {telemetry.v1.IRegistration|null|undefined} registration
             * @memberof telemetry.v1.NodeSnapshot
             * @instance
             */
            NodeSnapshot.prototype.registration = null;

            /**
             * NodeSnapshot latest.
             * @member {Array.<telemetry.v1.IMetricSample>} latest
             * @memberof telemetry.v1.NodeSnapshot
             * @instance
             */
            NodeSnapshot.prototype.latest = $util.emptyArray;

            /**
             * Creates a new NodeSnapshot instance using the specified properties.
             * @function create
             * @memberof telemetry.v1.NodeSnapshot
             * @static
             * @param {telemetry.v1.INodeSnapshot=} [properties] Properties to set
             * @returns {telemetry.v1.NodeSnapshot} NodeSnapshot instance
             */
            NodeSnapshot.create = function create(properties) {
                return new NodeSnapshot(properties);
            };

            /**
             * Encodes the specified NodeSnapshot message. Does not implicitly {@link telemetry.v1.NodeSnapshot.verify|verify} messages.
             * @function encode
             * @memberof telemetry.v1.NodeSnapshot
             * @static
             * @param {telemetry.v1.INodeSnapshot} message NodeSnapshot message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NodeSnapshot.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.nodeId != null && Object.hasOwnProperty.call(message, "nodeId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.nodeId);
                if (message.connected != null && Object.hasOwnProperty.call(message, "connected"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.connected);
                if (message.lastSeenUnixNano != null && Object.hasOwnProperty.call(message, "lastSeenUnixNano"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.lastSeenUnixNano);
                if (message.registration != null && Object.hasOwnProperty.call(message, "registration"))
                    $root.telemetry.v1.Registration.encode(message.registration, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.latest != null && message.latest.length)
                    for (let i = 0; i < message.latest.length; ++i)
                        $root.telemetry.v1.MetricSample.encode(message.latest[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified NodeSnapshot message, length delimited. Does not implicitly {@link telemetry.v1.NodeSnapshot.verify|verify} messages.
             * @function encodeDelimited
             * @memberof telemetry.v1.NodeSnapshot
             * @static
             * @param {telemetry.v1.INodeSnapshot} message NodeSnapshot message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NodeSnapshot.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a NodeSnapshot message from the specified reader or buffer.
             * @function decode
             * @memberof telemetry.v1.NodeSnapshot
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {telemetry.v1.NodeSnapshot} NodeSnapshot
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NodeSnapshot.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.telemetry.v1.NodeSnapshot();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.nodeId = reader.string();
                            break;
                        }
                    case 2: {
                            message.connected = reader.bool();
                            break;
                        }
                    case 3: {
                            message.lastSeenUnixNano = reader.int64();
                            break;
                        }
                    case 4: {
                            message.registration = $root.telemetry.v1.Registration.decode(reader, reader.uint32());
                            break;
                        }
                    case 5: {
                            if (!(message.latest && message.latest.length))
                                message.latest = [];
                            message.latest.push($root.telemetry.v1.MetricSample.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a NodeSnapshot message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof telemetry.v1.NodeSnapshot
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {telemetry.v1.NodeSnapshot} NodeSnapshot
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NodeSnapshot.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a NodeSnapshot message.
             * @function verify
             * @memberof telemetry.v1.NodeSnapshot
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NodeSnapshot.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.nodeId != null && message.hasOwnProperty("nodeId"))
                    if (!$util.isString(message.nodeId))
                        return "nodeId: string expected";
                if (message.connected != null && message.hasOwnProperty("connected"))
                    if (typeof message.connected !== "boolean")
                        return "connected: boolean expected";
                if (message.lastSeenUnixNano != null && message.hasOwnProperty("lastSeenUnixNano"))
                    if (!$util.isInteger(message.lastSeenUnixNano) && !(message.lastSeenUnixNano && $util.isInteger(message.lastSeenUnixNano.low) && $util.isInteger(message.lastSeenUnixNano.high)))
                        return "lastSeenUnixNano: integer|Long expected";
                if (message.registration != null && message.hasOwnProperty("registration")) {
                    let error = $root.telemetry.v1.Registration.verify(message.registration);
                    if (error)
                        return "registration." + error;
                }
                if (message.latest != null && message.hasOwnProperty("latest")) {
                    if (!Array.isArray(message.latest))
                        return "latest: array expected";
                    for (let i = 0; i < message.latest.length; ++i) {
                        let error = $root.telemetry.v1.MetricSample.verify(message.latest[i]);
                        if (error)
                            return "latest." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a NodeSnapshot message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof telemetry.v1.NodeSnapshot
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {telemetry.v1.NodeSnapshot} NodeSnapshot
             */
            NodeSnapshot.fromObject = function fromObject(object) {
                if (object instanceof $root.telemetry.v1.NodeSnapshot)
                    return object;
                let message = new $root.telemetry.v1.NodeSnapshot();
                if (object.nodeId != null)
                    message.nodeId = String(object.nodeId);
                if (object.connected != null)
                    message.connected = Boolean(object.connected);
                if (object.lastSeenUnixNano != null)
                    if ($util.Long)
                        (message.lastSeenUnixNano = $util.Long.fromValue(object.lastSeenUnixNano)).unsigned = false;
                    else if (typeof object.lastSeenUnixNano === "string")
                        message.lastSeenUnixNano = parseInt(object.lastSeenUnixNano, 10);
                    else if (typeof object.lastSeenUnixNano === "number")
                        message.lastSeenUnixNano = object.lastSeenUnixNano;
                    else if (typeof object.lastSeenUnixNano === "object")
                        message.lastSeenUnixNano = new $util.LongBits(object.lastSeenUnixNano.low >>> 0, object.lastSeenUnixNano.high >>> 0).toNumber();
                if (object.registration != null) {
                    if (typeof object.registration !== "object")
                        throw TypeError(".telemetry.v1.NodeSnapshot.registration: object expected");
                    message.registration = $root.telemetry.v1.Registration.fromObject(object.registration);
                }
                if (object.latest) {
                    if (!Array.isArray(object.latest))
                        throw TypeError(".telemetry.v1.NodeSnapshot.latest: array expected");
                    message.latest = [];
                    for (let i = 0; i < object.latest.length; ++i) {
                        if (typeof object.latest[i] !== "object")
                            throw TypeError(".telemetry.v1.NodeSnapshot.latest: object expected");
                        message.latest[i] = $root.telemetry.v1.MetricSample.fromObject(object.latest[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a NodeSnapshot message. Also converts values to other types if specified.
             * @function toObject
             * @memberof telemetry.v1.NodeSnapshot
             * @static
             * @param {telemetry.v1.NodeSnapshot} message NodeSnapshot
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NodeSnapshot.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.latest = [];
                if (options.defaults) {
                    object.nodeId = "";
                    object.connected = false;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, false);
                        object.lastSeenUnixNano = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.lastSeenUnixNano = options.longs === String ? "0" : 0;
                    object.registration = null;
                }
                if (message.nodeId != null && message.hasOwnProperty("nodeId"))
                    object.nodeId = message.nodeId;
                if (message.connected != null && message.hasOwnProperty("connected"))
                    object.connected = message.connected;
                if (message.lastSeenUnixNano != null && message.hasOwnProperty("lastSeenUnixNano"))
                    if (typeof message.lastSeenUnixNano === "number")
                        object.lastSeenUnixNano = options.longs === String ? String(message.lastSeenUnixNano) : message.lastSeenUnixNano;
                    else
                        object.lastSeenUnixNano = options.longs === String ? $util.Long.prototype.toString.call(message.lastSeenUnixNano) : options.longs === Number ? new $util.LongBits(message.lastSeenUnixNano.low >>> 0, message.lastSeenUnixNano.high >>> 0).toNumber() : message.lastSeenUnixNano;
                if (message.registration != null && message.hasOwnProperty("registration"))
                    object.registration = $root.telemetry.v1.Registration.toObject(message.registration, options);
                if (message.latest && message.latest.length) {
                    object.latest = [];
                    for (let j = 0; j < message.latest.length; ++j)
                        object.latest[j] = $root.telemetry.v1.MetricSample.toObject(message.latest[j], options);
                }
                return object;
            };

            /**
             * Converts this NodeSnapshot to JSON.
             * @function toJSON
             * @memberof telemetry.v1.NodeSnapshot
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            NodeSnapshot.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for NodeSnapshot
             * @function getTypeUrl
             * @memberof telemetry.v1.NodeSnapshot
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            NodeSnapshot.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/telemetry.v1.NodeSnapshot";
            };

            return NodeSnapshot;
        })();

        v1.ListNodesResponse = (function() {

            /**
             * Properties of a ListNodesResponse.
             * @memberof telemetry.v1
             * @interface IListNodesResponse
             * @property {Array.<telemetry.v1.INodeSnapshot>|null} [nodes] ListNodesResponse nodes
             */

            /**
             * Constructs a new ListNodesResponse.
             * @memberof telemetry.v1
             * @classdesc Represents a ListNodesResponse.
             * @implements IListNodesResponse
             * @constructor
             * @param {telemetry.v1.IListNodesResponse=} [properties] Properties to set
             */
            function ListNodesResponse(properties) {
                this.nodes = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ListNodesResponse nodes.
             * @member {Array.<telemetry.v1.INodeSnapshot>} nodes
             * @memberof telemetry.v1.ListNodesResponse
             * @instance
             */
            ListNodesResponse.prototype.nodes = $util.emptyArray;

            /**
             * Creates a new ListNodesResponse instance using the specified properties.
             * @function create
             * @memberof telemetry.v1.ListNodesResponse
             * @static
             * @param {telemetry.v1.IListNodesResponse=} [properties] Properties to set
             * @returns {telemetry.v1.ListNodesResponse} ListNodesResponse instance
             */
            ListNodesResponse.create = function create(properties) {
                return new ListNodesResponse(properties);
            };

            /**
             * Encodes the specified ListNodesResponse message. Does not implicitly {@link telemetry.v1.ListNodesResponse.verify|verify} messages.
             * @function encode
             * @memberof telemetry.v1.ListNodesResponse
             * @static
             * @param {telemetry.v1.IListNodesResponse} message ListNodesResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ListNodesResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.nodes != null && message.nodes.length)
                    for (let i = 0; i < message.nodes.length; ++i)
                        $root.telemetry.v1.NodeSnapshot.encode(message.nodes[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ListNodesResponse message, length delimited. Does not implicitly {@link telemetry.v1.ListNodesResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof telemetry.v1.ListNodesResponse
             * @static
             * @param {telemetry.v1.IListNodesResponse} message ListNodesResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ListNodesResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ListNodesResponse message from the specified reader or buffer.
             * @function decode
             * @memberof telemetry.v1.ListNodesResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {telemetry.v1.ListNodesResponse} ListNodesResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ListNodesResponse.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.telemetry.v1.ListNodesResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.nodes && message.nodes.length))
                                message.nodes = [];
                            message.nodes.push($root.telemetry.v1.NodeSnapshot.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ListNodesResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof telemetry.v1.ListNodesResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {telemetry.v1.ListNodesResponse} ListNodesResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ListNodesResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ListNodesResponse message.
             * @function verify
             * @memberof telemetry.v1.ListNodesResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ListNodesResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.nodes != null && message.hasOwnProperty("nodes")) {
                    if (!Array.isArray(message.nodes))
                        return "nodes: array expected";
                    for (let i = 0; i < message.nodes.length; ++i) {
                        let error = $root.telemetry.v1.NodeSnapshot.verify(message.nodes[i]);
                        if (error)
                            return "nodes." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a ListNodesResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof telemetry.v1.ListNodesResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {telemetry.v1.ListNodesResponse} ListNodesResponse
             */
            ListNodesResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.telemetry.v1.ListNodesResponse)
                    return object;
                let message = new $root.telemetry.v1.ListNodesResponse();
                if (object.nodes) {
                    if (!Array.isArray(object.nodes))
                        throw TypeError(".telemetry.v1.ListNodesResponse.nodes: array expected");
                    message.nodes = [];
                    for (let i = 0; i < object.nodes.length; ++i) {
                        if (typeof object.nodes[i] !== "object")
                            throw TypeError(".telemetry.v1.ListNodesResponse.nodes: object expected");
                        message.nodes[i] = $root.telemetry.v1.NodeSnapshot.fromObject(object.nodes[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a ListNodesResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof telemetry.v1.ListNodesResponse
             * @static
             * @param {telemetry.v1.ListNodesResponse} message ListNodesResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ListNodesResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.nodes = [];
                if (message.nodes && message.nodes.length) {
                    object.nodes = [];
                    for (let j = 0; j < message.nodes.length; ++j)
                        object.nodes[j] = $root.telemetry.v1.NodeSnapshot.toObject(message.nodes[j], options);
                }
                return object;
            };

            /**
             * Converts this ListNodesResponse to JSON.
             * @function toJSON
             * @memberof telemetry.v1.ListNodesResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ListNodesResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ListNodesResponse
             * @function getTypeUrl
             * @memberof telemetry.v1.ListNodesResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ListNodesResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/telemetry.v1.ListNodesResponse";
            };

            return ListNodesResponse;
        })();

        v1.NodeModulesResponse = (function() {

            /**
             * Properties of a NodeModulesResponse.
             * @memberof telemetry.v1
             * @interface INodeModulesResponse
             * @property {Array.<telemetry.v1.IModuleRegistration>|null} [modules] NodeModulesResponse modules
             */

            /**
             * Constructs a new NodeModulesResponse.
             * @memberof telemetry.v1
             * @classdesc Represents a NodeModulesResponse.
             * @implements INodeModulesResponse
             * @constructor
             * @param {telemetry.v1.INodeModulesResponse=} [properties] Properties to set
             */
            function NodeModulesResponse(properties) {
                this.modules = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NodeModulesResponse modules.
             * @member {Array.<telemetry.v1.IModuleRegistration>} modules
             * @memberof telemetry.v1.NodeModulesResponse
             * @instance
             */
            NodeModulesResponse.prototype.modules = $util.emptyArray;

            /**
             * Creates a new NodeModulesResponse instance using the specified properties.
             * @function create
             * @memberof telemetry.v1.NodeModulesResponse
             * @static
             * @param {telemetry.v1.INodeModulesResponse=} [properties] Properties to set
             * @returns {telemetry.v1.NodeModulesResponse} NodeModulesResponse instance
             */
            NodeModulesResponse.create = function create(properties) {
                return new NodeModulesResponse(properties);
            };

            /**
             * Encodes the specified NodeModulesResponse message. Does not implicitly {@link telemetry.v1.NodeModulesResponse.verify|verify} messages.
             * @function encode
             * @memberof telemetry.v1.NodeModulesResponse
             * @static
             * @param {telemetry.v1.INodeModulesResponse} message NodeModulesResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NodeModulesResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.modules != null && message.modules.length)
                    for (let i = 0; i < message.modules.length; ++i)
                        $root.telemetry.v1.ModuleRegistration.encode(message.modules[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified NodeModulesResponse message, length delimited. Does not implicitly {@link telemetry.v1.NodeModulesResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof telemetry.v1.NodeModulesResponse
             * @static
             * @param {telemetry.v1.INodeModulesResponse} message NodeModulesResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NodeModulesResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a NodeModulesResponse message from the specified reader or buffer.
             * @function decode
             * @memberof telemetry.v1.NodeModulesResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {telemetry.v1.NodeModulesResponse} NodeModulesResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NodeModulesResponse.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.telemetry.v1.NodeModulesResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.modules && message.modules.length))
                                message.modules = [];
                            message.modules.push($root.telemetry.v1.ModuleRegistration.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a NodeModulesResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof telemetry.v1.NodeModulesResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {telemetry.v1.NodeModulesResponse} NodeModulesResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NodeModulesResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a NodeModulesResponse message.
             * @function verify
             * @memberof telemetry.v1.NodeModulesResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NodeModulesResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.modules != null && message.hasOwnProperty("modules")) {
                    if (!Array.isArray(message.modules))
                        return "modules: array expected";
                    for (let i = 0; i < message.modules.length; ++i) {
                        let error = $root.telemetry.v1.ModuleRegistration.verify(message.modules[i]);
                        if (error)
                            return "modules." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a NodeModulesResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof telemetry.v1.NodeModulesResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {telemetry.v1.NodeModulesResponse} NodeModulesResponse
             */
            NodeModulesResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.telemetry.v1.NodeModulesResponse)
                    return object;
                let message = new $root.telemetry.v1.NodeModulesResponse();
                if (object.modules) {
                    if (!Array.isArray(object.modules))
                        throw TypeError(".telemetry.v1.NodeModulesResponse.modules: array expected");
                    message.modules = [];
                    for (let i = 0; i < object.modules.length; ++i) {
                        if (typeof object.modules[i] !== "object")
                            throw TypeError(".telemetry.v1.NodeModulesResponse.modules: object expected");
                        message.modules[i] = $root.telemetry.v1.ModuleRegistration.fromObject(object.modules[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a NodeModulesResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof telemetry.v1.NodeModulesResponse
             * @static
             * @param {telemetry.v1.NodeModulesResponse} message NodeModulesResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NodeModulesResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.modules = [];
                if (message.modules && message.modules.length) {
                    object.modules = [];
                    for (let j = 0; j < message.modules.length; ++j)
                        object.modules[j] = $root.telemetry.v1.ModuleRegistration.toObject(message.modules[j], options);
                }
                return object;
            };

            /**
             * Converts this NodeModulesResponse to JSON.
             * @function toJSON
             * @memberof telemetry.v1.NodeModulesResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            NodeModulesResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for NodeModulesResponse
             * @function getTypeUrl
             * @memberof telemetry.v1.NodeModulesResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            NodeModulesResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/telemetry.v1.NodeModulesResponse";
            };

            return NodeModulesResponse;
        })();

        v1.TimedSample = (function() {

            /**
             * Properties of a TimedSample.
             * @memberof telemetry.v1
             * @interface ITimedSample
             * @property {string|null} [nodeId] TimedSample nodeId
             * @property {telemetry.v1.IMetricSample|null} [sample] TimedSample sample
             */

            /**
             * Constructs a new TimedSample.
             * @memberof telemetry.v1
             * @classdesc Represents a TimedSample.
             * @implements ITimedSample
             * @constructor
             * @param {telemetry.v1.ITimedSample=} [properties] Properties to set
             */
            function TimedSample(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TimedSample nodeId.
             * @member {string} nodeId
             * @memberof telemetry.v1.TimedSample
             * @instance
             */
            TimedSample.prototype.nodeId = "";

            /**
             * TimedSample sample.
             * @member {telemetry.v1.IMetricSample|null|undefined} sample
             * @memberof telemetry.v1.TimedSample
             * @instance
             */
            TimedSample.prototype.sample = null;

            /**
             * Creates a new TimedSample instance using the specified properties.
             * @function create
             * @memberof telemetry.v1.TimedSample
             * @static
             * @param {telemetry.v1.ITimedSample=} [properties] Properties to set
             * @returns {telemetry.v1.TimedSample} TimedSample instance
             */
            TimedSample.create = function create(properties) {
                return new TimedSample(properties);
            };

            /**
             * Encodes the specified TimedSample message. Does not implicitly {@link telemetry.v1.TimedSample.verify|verify} messages.
             * @function encode
             * @memberof telemetry.v1.TimedSample
             * @static
             * @param {telemetry.v1.ITimedSample} message TimedSample message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TimedSample.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.nodeId != null && Object.hasOwnProperty.call(message, "nodeId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.nodeId);
                if (message.sample != null && Object.hasOwnProperty.call(message, "sample"))
                    $root.telemetry.v1.MetricSample.encode(message.sample, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified TimedSample message, length delimited. Does not implicitly {@link telemetry.v1.TimedSample.verify|verify} messages.
             * @function encodeDelimited
             * @memberof telemetry.v1.TimedSample
             * @static
             * @param {telemetry.v1.ITimedSample} message TimedSample message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TimedSample.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a TimedSample message from the specified reader or buffer.
             * @function decode
             * @memberof telemetry.v1.TimedSample
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {telemetry.v1.TimedSample} TimedSample
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TimedSample.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.telemetry.v1.TimedSample();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.nodeId = reader.string();
                            break;
                        }
                    case 2: {
                            message.sample = $root.telemetry.v1.MetricSample.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a TimedSample message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof telemetry.v1.TimedSample
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {telemetry.v1.TimedSample} TimedSample
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TimedSample.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a TimedSample message.
             * @function verify
             * @memberof telemetry.v1.TimedSample
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TimedSample.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.nodeId != null && message.hasOwnProperty("nodeId"))
                    if (!$util.isString(message.nodeId))
                        return "nodeId: string expected";
                if (message.sample != null && message.hasOwnProperty("sample")) {
                    let error = $root.telemetry.v1.MetricSample.verify(message.sample);
                    if (error)
                        return "sample." + error;
                }
                return null;
            };

            /**
             * Creates a TimedSample message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof telemetry.v1.TimedSample
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {telemetry.v1.TimedSample} TimedSample
             */
            TimedSample.fromObject = function fromObject(object) {
                if (object instanceof $root.telemetry.v1.TimedSample)
                    return object;
                let message = new $root.telemetry.v1.TimedSample();
                if (object.nodeId != null)
                    message.nodeId = String(object.nodeId);
                if (object.sample != null) {
                    if (typeof object.sample !== "object")
                        throw TypeError(".telemetry.v1.TimedSample.sample: object expected");
                    message.sample = $root.telemetry.v1.MetricSample.fromObject(object.sample);
                }
                return message;
            };

            /**
             * Creates a plain object from a TimedSample message. Also converts values to other types if specified.
             * @function toObject
             * @memberof telemetry.v1.TimedSample
             * @static
             * @param {telemetry.v1.TimedSample} message TimedSample
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TimedSample.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.nodeId = "";
                    object.sample = null;
                }
                if (message.nodeId != null && message.hasOwnProperty("nodeId"))
                    object.nodeId = message.nodeId;
                if (message.sample != null && message.hasOwnProperty("sample"))
                    object.sample = $root.telemetry.v1.MetricSample.toObject(message.sample, options);
                return object;
            };

            /**
             * Converts this TimedSample to JSON.
             * @function toJSON
             * @memberof telemetry.v1.TimedSample
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TimedSample.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for TimedSample
             * @function getTypeUrl
             * @memberof telemetry.v1.TimedSample
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            TimedSample.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/telemetry.v1.TimedSample";
            };

            return TimedSample;
        })();

        v1.SamplesResponse = (function() {

            /**
             * Properties of a SamplesResponse.
             * @memberof telemetry.v1
             * @interface ISamplesResponse
             * @property {Array.<telemetry.v1.ITimedSample>|null} [samples] SamplesResponse samples
             */

            /**
             * Constructs a new SamplesResponse.
             * @memberof telemetry.v1
             * @classdesc Represents a SamplesResponse.
             * @implements ISamplesResponse
             * @constructor
             * @param {telemetry.v1.ISamplesResponse=} [properties] Properties to set
             */
            function SamplesResponse(properties) {
                this.samples = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SamplesResponse samples.
             * @member {Array.<telemetry.v1.ITimedSample>} samples
             * @memberof telemetry.v1.SamplesResponse
             * @instance
             */
            SamplesResponse.prototype.samples = $util.emptyArray;

            /**
             * Creates a new SamplesResponse instance using the specified properties.
             * @function create
             * @memberof telemetry.v1.SamplesResponse
             * @static
             * @param {telemetry.v1.ISamplesResponse=} [properties] Properties to set
             * @returns {telemetry.v1.SamplesResponse} SamplesResponse instance
             */
            SamplesResponse.create = function create(properties) {
                return new SamplesResponse(properties);
            };

            /**
             * Encodes the specified SamplesResponse message. Does not implicitly {@link telemetry.v1.SamplesResponse.verify|verify} messages.
             * @function encode
             * @memberof telemetry.v1.SamplesResponse
             * @static
             * @param {telemetry.v1.ISamplesResponse} message SamplesResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SamplesResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.samples != null && message.samples.length)
                    for (let i = 0; i < message.samples.length; ++i)
                        $root.telemetry.v1.TimedSample.encode(message.samples[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified SamplesResponse message, length delimited. Does not implicitly {@link telemetry.v1.SamplesResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof telemetry.v1.SamplesResponse
             * @static
             * @param {telemetry.v1.ISamplesResponse} message SamplesResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SamplesResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SamplesResponse message from the specified reader or buffer.
             * @function decode
             * @memberof telemetry.v1.SamplesResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {telemetry.v1.SamplesResponse} SamplesResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SamplesResponse.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.telemetry.v1.SamplesResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.samples && message.samples.length))
                                message.samples = [];
                            message.samples.push($root.telemetry.v1.TimedSample.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SamplesResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof telemetry.v1.SamplesResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {telemetry.v1.SamplesResponse} SamplesResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SamplesResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SamplesResponse message.
             * @function verify
             * @memberof telemetry.v1.SamplesResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SamplesResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.samples != null && message.hasOwnProperty("samples")) {
                    if (!Array.isArray(message.samples))
                        return "samples: array expected";
                    for (let i = 0; i < message.samples.length; ++i) {
                        let error = $root.telemetry.v1.TimedSample.verify(message.samples[i]);
                        if (error)
                            return "samples." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a SamplesResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof telemetry.v1.SamplesResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {telemetry.v1.SamplesResponse} SamplesResponse
             */
            SamplesResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.telemetry.v1.SamplesResponse)
                    return object;
                let message = new $root.telemetry.v1.SamplesResponse();
                if (object.samples) {
                    if (!Array.isArray(object.samples))
                        throw TypeError(".telemetry.v1.SamplesResponse.samples: array expected");
                    message.samples = [];
                    for (let i = 0; i < object.samples.length; ++i) {
                        if (typeof object.samples[i] !== "object")
                            throw TypeError(".telemetry.v1.SamplesResponse.samples: object expected");
                        message.samples[i] = $root.telemetry.v1.TimedSample.fromObject(object.samples[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a SamplesResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof telemetry.v1.SamplesResponse
             * @static
             * @param {telemetry.v1.SamplesResponse} message SamplesResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SamplesResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.samples = [];
                if (message.samples && message.samples.length) {
                    object.samples = [];
                    for (let j = 0; j < message.samples.length; ++j)
                        object.samples[j] = $root.telemetry.v1.TimedSample.toObject(message.samples[j], options);
                }
                return object;
            };

            /**
             * Converts this SamplesResponse to JSON.
             * @function toJSON
             * @memberof telemetry.v1.SamplesResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SamplesResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SamplesResponse
             * @function getTypeUrl
             * @memberof telemetry.v1.SamplesResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SamplesResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/telemetry.v1.SamplesResponse";
            };

            return SamplesResponse;
        })();

        v1.ErrorResponse = (function() {

            /**
             * Properties of an ErrorResponse.
             * @memberof telemetry.v1
             * @interface IErrorResponse
             * @property {string|null} [error] ErrorResponse error
             * @property {number|Long|null} [timeUnixNano] ErrorResponse timeUnixNano
             */

            /**
             * Constructs a new ErrorResponse.
             * @memberof telemetry.v1
             * @classdesc Represents an ErrorResponse.
             * @implements IErrorResponse
             * @constructor
             * @param {telemetry.v1.IErrorResponse=} [properties] Properties to set
             */
            function ErrorResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ErrorResponse error.
             * @member {string} error
             * @memberof telemetry.v1.ErrorResponse
             * @instance
             */
            ErrorResponse.prototype.error = "";

            /**
             * ErrorResponse timeUnixNano.
             * @member {number|Long} timeUnixNano
             * @memberof telemetry.v1.ErrorResponse
             * @instance
             */
            ErrorResponse.prototype.timeUnixNano = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new ErrorResponse instance using the specified properties.
             * @function create
             * @memberof telemetry.v1.ErrorResponse
             * @static
             * @param {telemetry.v1.IErrorResponse=} [properties] Properties to set
             * @returns {telemetry.v1.ErrorResponse} ErrorResponse instance
             */
            ErrorResponse.create = function create(properties) {
                return new ErrorResponse(properties);
            };

            /**
             * Encodes the specified ErrorResponse message. Does not implicitly {@link telemetry.v1.ErrorResponse.verify|verify} messages.
             * @function encode
             * @memberof telemetry.v1.ErrorResponse
             * @static
             * @param {telemetry.v1.IErrorResponse} message ErrorResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ErrorResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.error != null && Object.hasOwnProperty.call(message, "error"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.error);
                if (message.timeUnixNano != null && Object.hasOwnProperty.call(message, "timeUnixNano"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.timeUnixNano);
                return writer;
            };

            /**
             * Encodes the specified ErrorResponse message, length delimited. Does not implicitly {@link telemetry.v1.ErrorResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof telemetry.v1.ErrorResponse
             * @static
             * @param {telemetry.v1.IErrorResponse} message ErrorResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ErrorResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ErrorResponse message from the specified reader or buffer.
             * @function decode
             * @memberof telemetry.v1.ErrorResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {telemetry.v1.ErrorResponse} ErrorResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ErrorResponse.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.telemetry.v1.ErrorResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.error = reader.string();
                            break;
                        }
                    case 2: {
                            message.timeUnixNano = reader.int64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ErrorResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof telemetry.v1.ErrorResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {telemetry.v1.ErrorResponse} ErrorResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ErrorResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ErrorResponse message.
             * @function verify
             * @memberof telemetry.v1.ErrorResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ErrorResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.error != null && message.hasOwnProperty("error"))
                    if (!$util.isString(message.error))
                        return "error: string expected";
                if (message.timeUnixNano != null && message.hasOwnProperty("timeUnixNano"))
                    if (!$util.isInteger(message.timeUnixNano) && !(message.timeUnixNano && $util.isInteger(message.timeUnixNano.low) && $util.isInteger(message.timeUnixNano.high)))
                        return "timeUnixNano: integer|Long expected";
                return null;
            };

            /**
             * Creates an ErrorResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof telemetry.v1.ErrorResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {telemetry.v1.ErrorResponse} ErrorResponse
             */
            ErrorResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.telemetry.v1.ErrorResponse)
                    return object;
                let message = new $root.telemetry.v1.ErrorResponse();
                if (object.error != null)
                    message.error = String(object.error);
                if (object.timeUnixNano != null)
                    if ($util.Long)
                        (message.timeUnixNano = $util.Long.fromValue(object.timeUnixNano)).unsigned = false;
                    else if (typeof object.timeUnixNano === "string")
                        message.timeUnixNano = parseInt(object.timeUnixNano, 10);
                    else if (typeof object.timeUnixNano === "number")
                        message.timeUnixNano = object.timeUnixNano;
                    else if (typeof object.timeUnixNano === "object")
                        message.timeUnixNano = new $util.LongBits(object.timeUnixNano.low >>> 0, object.timeUnixNano.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from an ErrorResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof telemetry.v1.ErrorResponse
             * @static
             * @param {telemetry.v1.ErrorResponse} message ErrorResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ErrorResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.error = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, false);
                        object.timeUnixNano = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.timeUnixNano = options.longs === String ? "0" : 0;
                }
                if (message.error != null && message.hasOwnProperty("error"))
                    object.error = message.error;
                if (message.timeUnixNano != null && message.hasOwnProperty("timeUnixNano"))
                    if (typeof message.timeUnixNano === "number")
                        object.timeUnixNano = options.longs === String ? String(message.timeUnixNano) : message.timeUnixNano;
                    else
                        object.timeUnixNano = options.longs === String ? $util.Long.prototype.toString.call(message.timeUnixNano) : options.longs === Number ? new $util.LongBits(message.timeUnixNano.low >>> 0, message.timeUnixNano.high >>> 0).toNumber() : message.timeUnixNano;
                return object;
            };

            /**
             * Converts this ErrorResponse to JSON.
             * @function toJSON
             * @memberof telemetry.v1.ErrorResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ErrorResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ErrorResponse
             * @function getTypeUrl
             * @memberof telemetry.v1.ErrorResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ErrorResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/telemetry.v1.ErrorResponse";
            };

            return ErrorResponse;
        })();

        v1.HealthzResponse = (function() {

            /**
             * Properties of a HealthzResponse.
             * @memberof telemetry.v1
             * @interface IHealthzResponse
             * @property {string|null} [status] HealthzResponse status
             * @property {number|Long|null} [timeUnixNano] HealthzResponse timeUnixNano
             */

            /**
             * Constructs a new HealthzResponse.
             * @memberof telemetry.v1
             * @classdesc Represents a HealthzResponse.
             * @implements IHealthzResponse
             * @constructor
             * @param {telemetry.v1.IHealthzResponse=} [properties] Properties to set
             */
            function HealthzResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * HealthzResponse status.
             * @member {string} status
             * @memberof telemetry.v1.HealthzResponse
             * @instance
             */
            HealthzResponse.prototype.status = "";

            /**
             * HealthzResponse timeUnixNano.
             * @member {number|Long} timeUnixNano
             * @memberof telemetry.v1.HealthzResponse
             * @instance
             */
            HealthzResponse.prototype.timeUnixNano = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new HealthzResponse instance using the specified properties.
             * @function create
             * @memberof telemetry.v1.HealthzResponse
             * @static
             * @param {telemetry.v1.IHealthzResponse=} [properties] Properties to set
             * @returns {telemetry.v1.HealthzResponse} HealthzResponse instance
             */
            HealthzResponse.create = function create(properties) {
                return new HealthzResponse(properties);
            };

            /**
             * Encodes the specified HealthzResponse message. Does not implicitly {@link telemetry.v1.HealthzResponse.verify|verify} messages.
             * @function encode
             * @memberof telemetry.v1.HealthzResponse
             * @static
             * @param {telemetry.v1.IHealthzResponse} message HealthzResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            HealthzResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.status);
                if (message.timeUnixNano != null && Object.hasOwnProperty.call(message, "timeUnixNano"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.timeUnixNano);
                return writer;
            };

            /**
             * Encodes the specified HealthzResponse message, length delimited. Does not implicitly {@link telemetry.v1.HealthzResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof telemetry.v1.HealthzResponse
             * @static
             * @param {telemetry.v1.IHealthzResponse} message HealthzResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            HealthzResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a HealthzResponse message from the specified reader or buffer.
             * @function decode
             * @memberof telemetry.v1.HealthzResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {telemetry.v1.HealthzResponse} HealthzResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            HealthzResponse.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.telemetry.v1.HealthzResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.status = reader.string();
                            break;
                        }
                    case 2: {
                            message.timeUnixNano = reader.int64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a HealthzResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof telemetry.v1.HealthzResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {telemetry.v1.HealthzResponse} HealthzResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            HealthzResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a HealthzResponse message.
             * @function verify
             * @memberof telemetry.v1.HealthzResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            HealthzResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.status != null && message.hasOwnProperty("status"))
                    if (!$util.isString(message.status))
                        return "status: string expected";
                if (message.timeUnixNano != null && message.hasOwnProperty("timeUnixNano"))
                    if (!$util.isInteger(message.timeUnixNano) && !(message.timeUnixNano && $util.isInteger(message.timeUnixNano.low) && $util.isInteger(message.timeUnixNano.high)))
                        return "timeUnixNano: integer|Long expected";
                return null;
            };

            /**
             * Creates a HealthzResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof telemetry.v1.HealthzResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {telemetry.v1.HealthzResponse} HealthzResponse
             */
            HealthzResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.telemetry.v1.HealthzResponse)
                    return object;
                let message = new $root.telemetry.v1.HealthzResponse();
                if (object.status != null)
                    message.status = String(object.status);
                if (object.timeUnixNano != null)
                    if ($util.Long)
                        (message.timeUnixNano = $util.Long.fromValue(object.timeUnixNano)).unsigned = false;
                    else if (typeof object.timeUnixNano === "string")
                        message.timeUnixNano = parseInt(object.timeUnixNano, 10);
                    else if (typeof object.timeUnixNano === "number")
                        message.timeUnixNano = object.timeUnixNano;
                    else if (typeof object.timeUnixNano === "object")
                        message.timeUnixNano = new $util.LongBits(object.timeUnixNano.low >>> 0, object.timeUnixNano.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from a HealthzResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof telemetry.v1.HealthzResponse
             * @static
             * @param {telemetry.v1.HealthzResponse} message HealthzResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            HealthzResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.status = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, false);
                        object.timeUnixNano = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.timeUnixNano = options.longs === String ? "0" : 0;
                }
                if (message.status != null && message.hasOwnProperty("status"))
                    object.status = message.status;
                if (message.timeUnixNano != null && message.hasOwnProperty("timeUnixNano"))
                    if (typeof message.timeUnixNano === "number")
                        object.timeUnixNano = options.longs === String ? String(message.timeUnixNano) : message.timeUnixNano;
                    else
                        object.timeUnixNano = options.longs === String ? $util.Long.prototype.toString.call(message.timeUnixNano) : options.longs === Number ? new $util.LongBits(message.timeUnixNano.low >>> 0, message.timeUnixNano.high >>> 0).toNumber() : message.timeUnixNano;
                return object;
            };

            /**
             * Converts this HealthzResponse to JSON.
             * @function toJSON
             * @memberof telemetry.v1.HealthzResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            HealthzResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for HealthzResponse
             * @function getTypeUrl
             * @memberof telemetry.v1.HealthzResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            HealthzResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/telemetry.v1.HealthzResponse";
            };

            return HealthzResponse;
        })();

        v1.WSWelcome = (function() {

            /**
             * Properties of a WSWelcome.
             * @memberof telemetry.v1
             * @interface IWSWelcome
             * @property {number|Long|null} [serverTimeUnixNano] WSWelcome serverTimeUnixNano
             * @property {Array.<string>|null} [nodes] WSWelcome nodes
             * @property {Array.<string>|null} [categories] WSWelcome categories
             */

            /**
             * Constructs a new WSWelcome.
             * @memberof telemetry.v1
             * @classdesc Represents a WSWelcome.
             * @implements IWSWelcome
             * @constructor
             * @param {telemetry.v1.IWSWelcome=} [properties] Properties to set
             */
            function WSWelcome(properties) {
                this.nodes = [];
                this.categories = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WSWelcome serverTimeUnixNano.
             * @member {number|Long} serverTimeUnixNano
             * @memberof telemetry.v1.WSWelcome
             * @instance
             */
            WSWelcome.prototype.serverTimeUnixNano = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * WSWelcome nodes.
             * @member {Array.<string>} nodes
             * @memberof telemetry.v1.WSWelcome
             * @instance
             */
            WSWelcome.prototype.nodes = $util.emptyArray;

            /**
             * WSWelcome categories.
             * @member {Array.<string>} categories
             * @memberof telemetry.v1.WSWelcome
             * @instance
             */
            WSWelcome.prototype.categories = $util.emptyArray;

            /**
             * Creates a new WSWelcome instance using the specified properties.
             * @function create
             * @memberof telemetry.v1.WSWelcome
             * @static
             * @param {telemetry.v1.IWSWelcome=} [properties] Properties to set
             * @returns {telemetry.v1.WSWelcome} WSWelcome instance
             */
            WSWelcome.create = function create(properties) {
                return new WSWelcome(properties);
            };

            /**
             * Encodes the specified WSWelcome message. Does not implicitly {@link telemetry.v1.WSWelcome.verify|verify} messages.
             * @function encode
             * @memberof telemetry.v1.WSWelcome
             * @static
             * @param {telemetry.v1.IWSWelcome} message WSWelcome message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WSWelcome.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.serverTimeUnixNano != null && Object.hasOwnProperty.call(message, "serverTimeUnixNano"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.serverTimeUnixNano);
                if (message.nodes != null && message.nodes.length)
                    for (let i = 0; i < message.nodes.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.nodes[i]);
                if (message.categories != null && message.categories.length)
                    for (let i = 0; i < message.categories.length; ++i)
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.categories[i]);
                return writer;
            };

            /**
             * Encodes the specified WSWelcome message, length delimited. Does not implicitly {@link telemetry.v1.WSWelcome.verify|verify} messages.
             * @function encodeDelimited
             * @memberof telemetry.v1.WSWelcome
             * @static
             * @param {telemetry.v1.IWSWelcome} message WSWelcome message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WSWelcome.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a WSWelcome message from the specified reader or buffer.
             * @function decode
             * @memberof telemetry.v1.WSWelcome
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {telemetry.v1.WSWelcome} WSWelcome
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WSWelcome.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.telemetry.v1.WSWelcome();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.serverTimeUnixNano = reader.int64();
                            break;
                        }
                    case 2: {
                            if (!(message.nodes && message.nodes.length))
                                message.nodes = [];
                            message.nodes.push(reader.string());
                            break;
                        }
                    case 3: {
                            if (!(message.categories && message.categories.length))
                                message.categories = [];
                            message.categories.push(reader.string());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a WSWelcome message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof telemetry.v1.WSWelcome
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {telemetry.v1.WSWelcome} WSWelcome
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WSWelcome.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a WSWelcome message.
             * @function verify
             * @memberof telemetry.v1.WSWelcome
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WSWelcome.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.serverTimeUnixNano != null && message.hasOwnProperty("serverTimeUnixNano"))
                    if (!$util.isInteger(message.serverTimeUnixNano) && !(message.serverTimeUnixNano && $util.isInteger(message.serverTimeUnixNano.low) && $util.isInteger(message.serverTimeUnixNano.high)))
                        return "serverTimeUnixNano: integer|Long expected";
                if (message.nodes != null && message.hasOwnProperty("nodes")) {
                    if (!Array.isArray(message.nodes))
                        return "nodes: array expected";
                    for (let i = 0; i < message.nodes.length; ++i)
                        if (!$util.isString(message.nodes[i]))
                            return "nodes: string[] expected";
                }
                if (message.categories != null && message.hasOwnProperty("categories")) {
                    if (!Array.isArray(message.categories))
                        return "categories: array expected";
                    for (let i = 0; i < message.categories.length; ++i)
                        if (!$util.isString(message.categories[i]))
                            return "categories: string[] expected";
                }
                return null;
            };

            /**
             * Creates a WSWelcome message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof telemetry.v1.WSWelcome
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {telemetry.v1.WSWelcome} WSWelcome
             */
            WSWelcome.fromObject = function fromObject(object) {
                if (object instanceof $root.telemetry.v1.WSWelcome)
                    return object;
                let message = new $root.telemetry.v1.WSWelcome();
                if (object.serverTimeUnixNano != null)
                    if ($util.Long)
                        (message.serverTimeUnixNano = $util.Long.fromValue(object.serverTimeUnixNano)).unsigned = false;
                    else if (typeof object.serverTimeUnixNano === "string")
                        message.serverTimeUnixNano = parseInt(object.serverTimeUnixNano, 10);
                    else if (typeof object.serverTimeUnixNano === "number")
                        message.serverTimeUnixNano = object.serverTimeUnixNano;
                    else if (typeof object.serverTimeUnixNano === "object")
                        message.serverTimeUnixNano = new $util.LongBits(object.serverTimeUnixNano.low >>> 0, object.serverTimeUnixNano.high >>> 0).toNumber();
                if (object.nodes) {
                    if (!Array.isArray(object.nodes))
                        throw TypeError(".telemetry.v1.WSWelcome.nodes: array expected");
                    message.nodes = [];
                    for (let i = 0; i < object.nodes.length; ++i)
                        message.nodes[i] = String(object.nodes[i]);
                }
                if (object.categories) {
                    if (!Array.isArray(object.categories))
                        throw TypeError(".telemetry.v1.WSWelcome.categories: array expected");
                    message.categories = [];
                    for (let i = 0; i < object.categories.length; ++i)
                        message.categories[i] = String(object.categories[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from a WSWelcome message. Also converts values to other types if specified.
             * @function toObject
             * @memberof telemetry.v1.WSWelcome
             * @static
             * @param {telemetry.v1.WSWelcome} message WSWelcome
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WSWelcome.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults) {
                    object.nodes = [];
                    object.categories = [];
                }
                if (options.defaults)
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, false);
                        object.serverTimeUnixNano = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.serverTimeUnixNano = options.longs === String ? "0" : 0;
                if (message.serverTimeUnixNano != null && message.hasOwnProperty("serverTimeUnixNano"))
                    if (typeof message.serverTimeUnixNano === "number")
                        object.serverTimeUnixNano = options.longs === String ? String(message.serverTimeUnixNano) : message.serverTimeUnixNano;
                    else
                        object.serverTimeUnixNano = options.longs === String ? $util.Long.prototype.toString.call(message.serverTimeUnixNano) : options.longs === Number ? new $util.LongBits(message.serverTimeUnixNano.low >>> 0, message.serverTimeUnixNano.high >>> 0).toNumber() : message.serverTimeUnixNano;
                if (message.nodes && message.nodes.length) {
                    object.nodes = [];
                    for (let j = 0; j < message.nodes.length; ++j)
                        object.nodes[j] = message.nodes[j];
                }
                if (message.categories && message.categories.length) {
                    object.categories = [];
                    for (let j = 0; j < message.categories.length; ++j)
                        object.categories[j] = message.categories[j];
                }
                return object;
            };

            /**
             * Converts this WSWelcome to JSON.
             * @function toJSON
             * @memberof telemetry.v1.WSWelcome
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            WSWelcome.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for WSWelcome
             * @function getTypeUrl
             * @memberof telemetry.v1.WSWelcome
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            WSWelcome.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/telemetry.v1.WSWelcome";
            };

            return WSWelcome;
        })();

        v1.WSClientControl = (function() {

            /**
             * Properties of a WSClientControl.
             * @memberof telemetry.v1
             * @interface IWSClientControl
             * @property {string|null} [op] WSClientControl op
             * @property {Array.<string>|null} [nodes] WSClientControl nodes
             * @property {Array.<string>|null} [categories] WSClientControl categories
             */

            /**
             * Constructs a new WSClientControl.
             * @memberof telemetry.v1
             * @classdesc Represents a WSClientControl.
             * @implements IWSClientControl
             * @constructor
             * @param {telemetry.v1.IWSClientControl=} [properties] Properties to set
             */
            function WSClientControl(properties) {
                this.nodes = [];
                this.categories = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WSClientControl op.
             * @member {string} op
             * @memberof telemetry.v1.WSClientControl
             * @instance
             */
            WSClientControl.prototype.op = "";

            /**
             * WSClientControl nodes.
             * @member {Array.<string>} nodes
             * @memberof telemetry.v1.WSClientControl
             * @instance
             */
            WSClientControl.prototype.nodes = $util.emptyArray;

            /**
             * WSClientControl categories.
             * @member {Array.<string>} categories
             * @memberof telemetry.v1.WSClientControl
             * @instance
             */
            WSClientControl.prototype.categories = $util.emptyArray;

            /**
             * Creates a new WSClientControl instance using the specified properties.
             * @function create
             * @memberof telemetry.v1.WSClientControl
             * @static
             * @param {telemetry.v1.IWSClientControl=} [properties] Properties to set
             * @returns {telemetry.v1.WSClientControl} WSClientControl instance
             */
            WSClientControl.create = function create(properties) {
                return new WSClientControl(properties);
            };

            /**
             * Encodes the specified WSClientControl message. Does not implicitly {@link telemetry.v1.WSClientControl.verify|verify} messages.
             * @function encode
             * @memberof telemetry.v1.WSClientControl
             * @static
             * @param {telemetry.v1.IWSClientControl} message WSClientControl message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WSClientControl.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.op != null && Object.hasOwnProperty.call(message, "op"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.op);
                if (message.nodes != null && message.nodes.length)
                    for (let i = 0; i < message.nodes.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.nodes[i]);
                if (message.categories != null && message.categories.length)
                    for (let i = 0; i < message.categories.length; ++i)
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.categories[i]);
                return writer;
            };

            /**
             * Encodes the specified WSClientControl message, length delimited. Does not implicitly {@link telemetry.v1.WSClientControl.verify|verify} messages.
             * @function encodeDelimited
             * @memberof telemetry.v1.WSClientControl
             * @static
             * @param {telemetry.v1.IWSClientControl} message WSClientControl message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WSClientControl.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a WSClientControl message from the specified reader or buffer.
             * @function decode
             * @memberof telemetry.v1.WSClientControl
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {telemetry.v1.WSClientControl} WSClientControl
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WSClientControl.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.telemetry.v1.WSClientControl();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.op = reader.string();
                            break;
                        }
                    case 2: {
                            if (!(message.nodes && message.nodes.length))
                                message.nodes = [];
                            message.nodes.push(reader.string());
                            break;
                        }
                    case 3: {
                            if (!(message.categories && message.categories.length))
                                message.categories = [];
                            message.categories.push(reader.string());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a WSClientControl message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof telemetry.v1.WSClientControl
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {telemetry.v1.WSClientControl} WSClientControl
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WSClientControl.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a WSClientControl message.
             * @function verify
             * @memberof telemetry.v1.WSClientControl
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WSClientControl.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.op != null && message.hasOwnProperty("op"))
                    if (!$util.isString(message.op))
                        return "op: string expected";
                if (message.nodes != null && message.hasOwnProperty("nodes")) {
                    if (!Array.isArray(message.nodes))
                        return "nodes: array expected";
                    for (let i = 0; i < message.nodes.length; ++i)
                        if (!$util.isString(message.nodes[i]))
                            return "nodes: string[] expected";
                }
                if (message.categories != null && message.hasOwnProperty("categories")) {
                    if (!Array.isArray(message.categories))
                        return "categories: array expected";
                    for (let i = 0; i < message.categories.length; ++i)
                        if (!$util.isString(message.categories[i]))
                            return "categories: string[] expected";
                }
                return null;
            };

            /**
             * Creates a WSClientControl message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof telemetry.v1.WSClientControl
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {telemetry.v1.WSClientControl} WSClientControl
             */
            WSClientControl.fromObject = function fromObject(object) {
                if (object instanceof $root.telemetry.v1.WSClientControl)
                    return object;
                let message = new $root.telemetry.v1.WSClientControl();
                if (object.op != null)
                    message.op = String(object.op);
                if (object.nodes) {
                    if (!Array.isArray(object.nodes))
                        throw TypeError(".telemetry.v1.WSClientControl.nodes: array expected");
                    message.nodes = [];
                    for (let i = 0; i < object.nodes.length; ++i)
                        message.nodes[i] = String(object.nodes[i]);
                }
                if (object.categories) {
                    if (!Array.isArray(object.categories))
                        throw TypeError(".telemetry.v1.WSClientControl.categories: array expected");
                    message.categories = [];
                    for (let i = 0; i < object.categories.length; ++i)
                        message.categories[i] = String(object.categories[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from a WSClientControl message. Also converts values to other types if specified.
             * @function toObject
             * @memberof telemetry.v1.WSClientControl
             * @static
             * @param {telemetry.v1.WSClientControl} message WSClientControl
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WSClientControl.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults) {
                    object.nodes = [];
                    object.categories = [];
                }
                if (options.defaults)
                    object.op = "";
                if (message.op != null && message.hasOwnProperty("op"))
                    object.op = message.op;
                if (message.nodes && message.nodes.length) {
                    object.nodes = [];
                    for (let j = 0; j < message.nodes.length; ++j)
                        object.nodes[j] = message.nodes[j];
                }
                if (message.categories && message.categories.length) {
                    object.categories = [];
                    for (let j = 0; j < message.categories.length; ++j)
                        object.categories[j] = message.categories[j];
                }
                return object;
            };

            /**
             * Converts this WSClientControl to JSON.
             * @function toJSON
             * @memberof telemetry.v1.WSClientControl
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            WSClientControl.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for WSClientControl
             * @function getTypeUrl
             * @memberof telemetry.v1.WSClientControl
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            WSClientControl.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/telemetry.v1.WSClientControl";
            };

            return WSClientControl;
        })();

        v1.WSOutgoingMessage = (function() {

            /**
             * Properties of a WSOutgoingMessage.
             * @memberof telemetry.v1
             * @interface IWSOutgoingMessage
             * @property {string|null} [type] WSOutgoingMessage type
             * @property {telemetry.v1.ITimedSample|null} [metric] WSOutgoingMessage metric
             * @property {telemetry.v1.IWSWelcome|null} [welcome] WSOutgoingMessage welcome
             * @property {string|null} [error] WSOutgoingMessage error
             * @property {telemetry.v1.INodeSnapshot|null} [node] WSOutgoingMessage node
             */

            /**
             * Constructs a new WSOutgoingMessage.
             * @memberof telemetry.v1
             * @classdesc Represents a WSOutgoingMessage.
             * @implements IWSOutgoingMessage
             * @constructor
             * @param {telemetry.v1.IWSOutgoingMessage=} [properties] Properties to set
             */
            function WSOutgoingMessage(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WSOutgoingMessage type.
             * @member {string} type
             * @memberof telemetry.v1.WSOutgoingMessage
             * @instance
             */
            WSOutgoingMessage.prototype.type = "";

            /**
             * WSOutgoingMessage metric.
             * @member {telemetry.v1.ITimedSample|null|undefined} metric
             * @memberof telemetry.v1.WSOutgoingMessage
             * @instance
             */
            WSOutgoingMessage.prototype.metric = null;

            /**
             * WSOutgoingMessage welcome.
             * @member {telemetry.v1.IWSWelcome|null|undefined} welcome
             * @memberof telemetry.v1.WSOutgoingMessage
             * @instance
             */
            WSOutgoingMessage.prototype.welcome = null;

            /**
             * WSOutgoingMessage error.
             * @member {string} error
             * @memberof telemetry.v1.WSOutgoingMessage
             * @instance
             */
            WSOutgoingMessage.prototype.error = "";

            /**
             * WSOutgoingMessage node.
             * @member {telemetry.v1.INodeSnapshot|null|undefined} node
             * @memberof telemetry.v1.WSOutgoingMessage
             * @instance
             */
            WSOutgoingMessage.prototype.node = null;

            /**
             * Creates a new WSOutgoingMessage instance using the specified properties.
             * @function create
             * @memberof telemetry.v1.WSOutgoingMessage
             * @static
             * @param {telemetry.v1.IWSOutgoingMessage=} [properties] Properties to set
             * @returns {telemetry.v1.WSOutgoingMessage} WSOutgoingMessage instance
             */
            WSOutgoingMessage.create = function create(properties) {
                return new WSOutgoingMessage(properties);
            };

            /**
             * Encodes the specified WSOutgoingMessage message. Does not implicitly {@link telemetry.v1.WSOutgoingMessage.verify|verify} messages.
             * @function encode
             * @memberof telemetry.v1.WSOutgoingMessage
             * @static
             * @param {telemetry.v1.IWSOutgoingMessage} message WSOutgoingMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WSOutgoingMessage.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.type);
                if (message.metric != null && Object.hasOwnProperty.call(message, "metric"))
                    $root.telemetry.v1.TimedSample.encode(message.metric, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.welcome != null && Object.hasOwnProperty.call(message, "welcome"))
                    $root.telemetry.v1.WSWelcome.encode(message.welcome, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.error != null && Object.hasOwnProperty.call(message, "error"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.error);
                if (message.node != null && Object.hasOwnProperty.call(message, "node"))
                    $root.telemetry.v1.NodeSnapshot.encode(message.node, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified WSOutgoingMessage message, length delimited. Does not implicitly {@link telemetry.v1.WSOutgoingMessage.verify|verify} messages.
             * @function encodeDelimited
             * @memberof telemetry.v1.WSOutgoingMessage
             * @static
             * @param {telemetry.v1.IWSOutgoingMessage} message WSOutgoingMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WSOutgoingMessage.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a WSOutgoingMessage message from the specified reader or buffer.
             * @function decode
             * @memberof telemetry.v1.WSOutgoingMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {telemetry.v1.WSOutgoingMessage} WSOutgoingMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WSOutgoingMessage.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.telemetry.v1.WSOutgoingMessage();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.type = reader.string();
                            break;
                        }
                    case 2: {
                            message.metric = $root.telemetry.v1.TimedSample.decode(reader, reader.uint32());
                            break;
                        }
                    case 3: {
                            message.welcome = $root.telemetry.v1.WSWelcome.decode(reader, reader.uint32());
                            break;
                        }
                    case 4: {
                            message.error = reader.string();
                            break;
                        }
                    case 5: {
                            message.node = $root.telemetry.v1.NodeSnapshot.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a WSOutgoingMessage message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof telemetry.v1.WSOutgoingMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {telemetry.v1.WSOutgoingMessage} WSOutgoingMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WSOutgoingMessage.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a WSOutgoingMessage message.
             * @function verify
             * @memberof telemetry.v1.WSOutgoingMessage
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WSOutgoingMessage.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    if (!$util.isString(message.type))
                        return "type: string expected";
                if (message.metric != null && message.hasOwnProperty("metric")) {
                    let error = $root.telemetry.v1.TimedSample.verify(message.metric);
                    if (error)
                        return "metric." + error;
                }
                if (message.welcome != null && message.hasOwnProperty("welcome")) {
                    let error = $root.telemetry.v1.WSWelcome.verify(message.welcome);
                    if (error)
                        return "welcome." + error;
                }
                if (message.error != null && message.hasOwnProperty("error"))
                    if (!$util.isString(message.error))
                        return "error: string expected";
                if (message.node != null && message.hasOwnProperty("node")) {
                    let error = $root.telemetry.v1.NodeSnapshot.verify(message.node);
                    if (error)
                        return "node." + error;
                }
                return null;
            };

            /**
             * Creates a WSOutgoingMessage message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof telemetry.v1.WSOutgoingMessage
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {telemetry.v1.WSOutgoingMessage} WSOutgoingMessage
             */
            WSOutgoingMessage.fromObject = function fromObject(object) {
                if (object instanceof $root.telemetry.v1.WSOutgoingMessage)
                    return object;
                let message = new $root.telemetry.v1.WSOutgoingMessage();
                if (object.type != null)
                    message.type = String(object.type);
                if (object.metric != null) {
                    if (typeof object.metric !== "object")
                        throw TypeError(".telemetry.v1.WSOutgoingMessage.metric: object expected");
                    message.metric = $root.telemetry.v1.TimedSample.fromObject(object.metric);
                }
                if (object.welcome != null) {
                    if (typeof object.welcome !== "object")
                        throw TypeError(".telemetry.v1.WSOutgoingMessage.welcome: object expected");
                    message.welcome = $root.telemetry.v1.WSWelcome.fromObject(object.welcome);
                }
                if (object.error != null)
                    message.error = String(object.error);
                if (object.node != null) {
                    if (typeof object.node !== "object")
                        throw TypeError(".telemetry.v1.WSOutgoingMessage.node: object expected");
                    message.node = $root.telemetry.v1.NodeSnapshot.fromObject(object.node);
                }
                return message;
            };

            /**
             * Creates a plain object from a WSOutgoingMessage message. Also converts values to other types if specified.
             * @function toObject
             * @memberof telemetry.v1.WSOutgoingMessage
             * @static
             * @param {telemetry.v1.WSOutgoingMessage} message WSOutgoingMessage
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WSOutgoingMessage.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.type = "";
                    object.metric = null;
                    object.welcome = null;
                    object.error = "";
                    object.node = null;
                }
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = message.type;
                if (message.metric != null && message.hasOwnProperty("metric"))
                    object.metric = $root.telemetry.v1.TimedSample.toObject(message.metric, options);
                if (message.welcome != null && message.hasOwnProperty("welcome"))
                    object.welcome = $root.telemetry.v1.WSWelcome.toObject(message.welcome, options);
                if (message.error != null && message.hasOwnProperty("error"))
                    object.error = message.error;
                if (message.node != null && message.hasOwnProperty("node"))
                    object.node = $root.telemetry.v1.NodeSnapshot.toObject(message.node, options);
                return object;
            };

            /**
             * Converts this WSOutgoingMessage to JSON.
             * @function toJSON
             * @memberof telemetry.v1.WSOutgoingMessage
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            WSOutgoingMessage.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for WSOutgoingMessage
             * @function getTypeUrl
             * @memberof telemetry.v1.WSOutgoingMessage
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            WSOutgoingMessage.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/telemetry.v1.WSOutgoingMessage";
            };

            return WSOutgoingMessage;
        })();

        v1.BasicInfo = (function() {

            /**
             * Properties of a BasicInfo.
             * @memberof telemetry.v1
             * @interface IBasicInfo
             * @property {string|null} [hostname] BasicInfo hostname
             * @property {Array.<string>|null} [ips] BasicInfo ips
             * @property {string|null} [os] BasicInfo os
             * @property {string|null} [kernel] BasicInfo kernel
             * @property {string|null} [arch] BasicInfo arch
             * @property {string|null} [machineId] BasicInfo machineId
             * @property {string|null} [bootId] BasicInfo bootId
             * @property {string|null} [hardwareModel] BasicInfo hardwareModel
             * @property {string|null} [hardwareVendor] BasicInfo hardwareVendor
             */

            /**
             * Constructs a new BasicInfo.
             * @memberof telemetry.v1
             * @classdesc Represents a BasicInfo.
             * @implements IBasicInfo
             * @constructor
             * @param {telemetry.v1.IBasicInfo=} [properties] Properties to set
             */
            function BasicInfo(properties) {
                this.ips = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BasicInfo hostname.
             * @member {string} hostname
             * @memberof telemetry.v1.BasicInfo
             * @instance
             */
            BasicInfo.prototype.hostname = "";

            /**
             * BasicInfo ips.
             * @member {Array.<string>} ips
             * @memberof telemetry.v1.BasicInfo
             * @instance
             */
            BasicInfo.prototype.ips = $util.emptyArray;

            /**
             * BasicInfo os.
             * @member {string} os
             * @memberof telemetry.v1.BasicInfo
             * @instance
             */
            BasicInfo.prototype.os = "";

            /**
             * BasicInfo kernel.
             * @member {string} kernel
             * @memberof telemetry.v1.BasicInfo
             * @instance
             */
            BasicInfo.prototype.kernel = "";

            /**
             * BasicInfo arch.
             * @member {string} arch
             * @memberof telemetry.v1.BasicInfo
             * @instance
             */
            BasicInfo.prototype.arch = "";

            /**
             * BasicInfo machineId.
             * @member {string} machineId
             * @memberof telemetry.v1.BasicInfo
             * @instance
             */
            BasicInfo.prototype.machineId = "";

            /**
             * BasicInfo bootId.
             * @member {string} bootId
             * @memberof telemetry.v1.BasicInfo
             * @instance
             */
            BasicInfo.prototype.bootId = "";

            /**
             * BasicInfo hardwareModel.
             * @member {string} hardwareModel
             * @memberof telemetry.v1.BasicInfo
             * @instance
             */
            BasicInfo.prototype.hardwareModel = "";

            /**
             * BasicInfo hardwareVendor.
             * @member {string} hardwareVendor
             * @memberof telemetry.v1.BasicInfo
             * @instance
             */
            BasicInfo.prototype.hardwareVendor = "";

            /**
             * Creates a new BasicInfo instance using the specified properties.
             * @function create
             * @memberof telemetry.v1.BasicInfo
             * @static
             * @param {telemetry.v1.IBasicInfo=} [properties] Properties to set
             * @returns {telemetry.v1.BasicInfo} BasicInfo instance
             */
            BasicInfo.create = function create(properties) {
                return new BasicInfo(properties);
            };

            /**
             * Encodes the specified BasicInfo message. Does not implicitly {@link telemetry.v1.BasicInfo.verify|verify} messages.
             * @function encode
             * @memberof telemetry.v1.BasicInfo
             * @static
             * @param {telemetry.v1.IBasicInfo} message BasicInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BasicInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.hostname != null && Object.hasOwnProperty.call(message, "hostname"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.hostname);
                if (message.ips != null && message.ips.length)
                    for (let i = 0; i < message.ips.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.ips[i]);
                if (message.os != null && Object.hasOwnProperty.call(message, "os"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.os);
                if (message.kernel != null && Object.hasOwnProperty.call(message, "kernel"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.kernel);
                if (message.arch != null && Object.hasOwnProperty.call(message, "arch"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.arch);
                if (message.machineId != null && Object.hasOwnProperty.call(message, "machineId"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.machineId);
                if (message.bootId != null && Object.hasOwnProperty.call(message, "bootId"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.bootId);
                if (message.hardwareModel != null && Object.hasOwnProperty.call(message, "hardwareModel"))
                    writer.uint32(/* id 8, wireType 2 =*/66).string(message.hardwareModel);
                if (message.hardwareVendor != null && Object.hasOwnProperty.call(message, "hardwareVendor"))
                    writer.uint32(/* id 9, wireType 2 =*/74).string(message.hardwareVendor);
                return writer;
            };

            /**
             * Encodes the specified BasicInfo message, length delimited. Does not implicitly {@link telemetry.v1.BasicInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof telemetry.v1.BasicInfo
             * @static
             * @param {telemetry.v1.IBasicInfo} message BasicInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BasicInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BasicInfo message from the specified reader or buffer.
             * @function decode
             * @memberof telemetry.v1.BasicInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {telemetry.v1.BasicInfo} BasicInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BasicInfo.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.telemetry.v1.BasicInfo();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.hostname = reader.string();
                            break;
                        }
                    case 2: {
                            if (!(message.ips && message.ips.length))
                                message.ips = [];
                            message.ips.push(reader.string());
                            break;
                        }
                    case 3: {
                            message.os = reader.string();
                            break;
                        }
                    case 4: {
                            message.kernel = reader.string();
                            break;
                        }
                    case 5: {
                            message.arch = reader.string();
                            break;
                        }
                    case 6: {
                            message.machineId = reader.string();
                            break;
                        }
                    case 7: {
                            message.bootId = reader.string();
                            break;
                        }
                    case 8: {
                            message.hardwareModel = reader.string();
                            break;
                        }
                    case 9: {
                            message.hardwareVendor = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a BasicInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof telemetry.v1.BasicInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {telemetry.v1.BasicInfo} BasicInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BasicInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BasicInfo message.
             * @function verify
             * @memberof telemetry.v1.BasicInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BasicInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.hostname != null && message.hasOwnProperty("hostname"))
                    if (!$util.isString(message.hostname))
                        return "hostname: string expected";
                if (message.ips != null && message.hasOwnProperty("ips")) {
                    if (!Array.isArray(message.ips))
                        return "ips: array expected";
                    for (let i = 0; i < message.ips.length; ++i)
                        if (!$util.isString(message.ips[i]))
                            return "ips: string[] expected";
                }
                if (message.os != null && message.hasOwnProperty("os"))
                    if (!$util.isString(message.os))
                        return "os: string expected";
                if (message.kernel != null && message.hasOwnProperty("kernel"))
                    if (!$util.isString(message.kernel))
                        return "kernel: string expected";
                if (message.arch != null && message.hasOwnProperty("arch"))
                    if (!$util.isString(message.arch))
                        return "arch: string expected";
                if (message.machineId != null && message.hasOwnProperty("machineId"))
                    if (!$util.isString(message.machineId))
                        return "machineId: string expected";
                if (message.bootId != null && message.hasOwnProperty("bootId"))
                    if (!$util.isString(message.bootId))
                        return "bootId: string expected";
                if (message.hardwareModel != null && message.hasOwnProperty("hardwareModel"))
                    if (!$util.isString(message.hardwareModel))
                        return "hardwareModel: string expected";
                if (message.hardwareVendor != null && message.hasOwnProperty("hardwareVendor"))
                    if (!$util.isString(message.hardwareVendor))
                        return "hardwareVendor: string expected";
                return null;
            };

            /**
             * Creates a BasicInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof telemetry.v1.BasicInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {telemetry.v1.BasicInfo} BasicInfo
             */
            BasicInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.telemetry.v1.BasicInfo)
                    return object;
                let message = new $root.telemetry.v1.BasicInfo();
                if (object.hostname != null)
                    message.hostname = String(object.hostname);
                if (object.ips) {
                    if (!Array.isArray(object.ips))
                        throw TypeError(".telemetry.v1.BasicInfo.ips: array expected");
                    message.ips = [];
                    for (let i = 0; i < object.ips.length; ++i)
                        message.ips[i] = String(object.ips[i]);
                }
                if (object.os != null)
                    message.os = String(object.os);
                if (object.kernel != null)
                    message.kernel = String(object.kernel);
                if (object.arch != null)
                    message.arch = String(object.arch);
                if (object.machineId != null)
                    message.machineId = String(object.machineId);
                if (object.bootId != null)
                    message.bootId = String(object.bootId);
                if (object.hardwareModel != null)
                    message.hardwareModel = String(object.hardwareModel);
                if (object.hardwareVendor != null)
                    message.hardwareVendor = String(object.hardwareVendor);
                return message;
            };

            /**
             * Creates a plain object from a BasicInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof telemetry.v1.BasicInfo
             * @static
             * @param {telemetry.v1.BasicInfo} message BasicInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BasicInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.ips = [];
                if (options.defaults) {
                    object.hostname = "";
                    object.os = "";
                    object.kernel = "";
                    object.arch = "";
                    object.machineId = "";
                    object.bootId = "";
                    object.hardwareModel = "";
                    object.hardwareVendor = "";
                }
                if (message.hostname != null && message.hasOwnProperty("hostname"))
                    object.hostname = message.hostname;
                if (message.ips && message.ips.length) {
                    object.ips = [];
                    for (let j = 0; j < message.ips.length; ++j)
                        object.ips[j] = message.ips[j];
                }
                if (message.os != null && message.hasOwnProperty("os"))
                    object.os = message.os;
                if (message.kernel != null && message.hasOwnProperty("kernel"))
                    object.kernel = message.kernel;
                if (message.arch != null && message.hasOwnProperty("arch"))
                    object.arch = message.arch;
                if (message.machineId != null && message.hasOwnProperty("machineId"))
                    object.machineId = message.machineId;
                if (message.bootId != null && message.hasOwnProperty("bootId"))
                    object.bootId = message.bootId;
                if (message.hardwareModel != null && message.hasOwnProperty("hardwareModel"))
                    object.hardwareModel = message.hardwareModel;
                if (message.hardwareVendor != null && message.hasOwnProperty("hardwareVendor"))
                    object.hardwareVendor = message.hardwareVendor;
                return object;
            };

            /**
             * Converts this BasicInfo to JSON.
             * @function toJSON
             * @memberof telemetry.v1.BasicInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BasicInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for BasicInfo
             * @function getTypeUrl
             * @memberof telemetry.v1.BasicInfo
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            BasicInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/telemetry.v1.BasicInfo";
            };

            return BasicInfo;
        })();

        v1.ModuleRegistration = (function() {

            /**
             * Properties of a ModuleRegistration.
             * @memberof telemetry.v1
             * @interface IModuleRegistration
             * @property {string|null} [name] ModuleRegistration name
             * @property {telemetry.module.cpu.v1.IModuleRegistration|null} [cpu] ModuleRegistration cpu
             * @property {telemetry.module.gpu.v1.IModuleRegistration|null} [gpu] ModuleRegistration gpu
             * @property {telemetry.module.memory.v1.IModuleRegistration|null} [memory] ModuleRegistration memory
             * @property {telemetry.module.storage.v1.IModuleRegistration|null} [storage] ModuleRegistration storage
             * @property {telemetry.module.network.v1.IModuleRegistration|null} [network] ModuleRegistration network
             * @property {telemetry.module.process.v1.IModuleRegistration|null} [process] ModuleRegistration process
             */

            /**
             * Constructs a new ModuleRegistration.
             * @memberof telemetry.v1
             * @classdesc Represents a ModuleRegistration.
             * @implements IModuleRegistration
             * @constructor
             * @param {telemetry.v1.IModuleRegistration=} [properties] Properties to set
             */
            function ModuleRegistration(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ModuleRegistration name.
             * @member {string} name
             * @memberof telemetry.v1.ModuleRegistration
             * @instance
             */
            ModuleRegistration.prototype.name = "";

            /**
             * ModuleRegistration cpu.
             * @member {telemetry.module.cpu.v1.IModuleRegistration|null|undefined} cpu
             * @memberof telemetry.v1.ModuleRegistration
             * @instance
             */
            ModuleRegistration.prototype.cpu = null;

            /**
             * ModuleRegistration gpu.
             * @member {telemetry.module.gpu.v1.IModuleRegistration|null|undefined} gpu
             * @memberof telemetry.v1.ModuleRegistration
             * @instance
             */
            ModuleRegistration.prototype.gpu = null;

            /**
             * ModuleRegistration memory.
             * @member {telemetry.module.memory.v1.IModuleRegistration|null|undefined} memory
             * @memberof telemetry.v1.ModuleRegistration
             * @instance
             */
            ModuleRegistration.prototype.memory = null;

            /**
             * ModuleRegistration storage.
             * @member {telemetry.module.storage.v1.IModuleRegistration|null|undefined} storage
             * @memberof telemetry.v1.ModuleRegistration
             * @instance
             */
            ModuleRegistration.prototype.storage = null;

            /**
             * ModuleRegistration network.
             * @member {telemetry.module.network.v1.IModuleRegistration|null|undefined} network
             * @memberof telemetry.v1.ModuleRegistration
             * @instance
             */
            ModuleRegistration.prototype.network = null;

            /**
             * ModuleRegistration process.
             * @member {telemetry.module.process.v1.IModuleRegistration|null|undefined} process
             * @memberof telemetry.v1.ModuleRegistration
             * @instance
             */
            ModuleRegistration.prototype.process = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * ModuleRegistration metadata.
             * @member {"cpu"|"gpu"|"memory"|"storage"|"network"|"process"|undefined} metadata
             * @memberof telemetry.v1.ModuleRegistration
             * @instance
             */
            Object.defineProperty(ModuleRegistration.prototype, "metadata", {
                get: $util.oneOfGetter($oneOfFields = ["cpu", "gpu", "memory", "storage", "network", "process"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new ModuleRegistration instance using the specified properties.
             * @function create
             * @memberof telemetry.v1.ModuleRegistration
             * @static
             * @param {telemetry.v1.IModuleRegistration=} [properties] Properties to set
             * @returns {telemetry.v1.ModuleRegistration} ModuleRegistration instance
             */
            ModuleRegistration.create = function create(properties) {
                return new ModuleRegistration(properties);
            };

            /**
             * Encodes the specified ModuleRegistration message. Does not implicitly {@link telemetry.v1.ModuleRegistration.verify|verify} messages.
             * @function encode
             * @memberof telemetry.v1.ModuleRegistration
             * @static
             * @param {telemetry.v1.IModuleRegistration} message ModuleRegistration message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ModuleRegistration.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.cpu != null && Object.hasOwnProperty.call(message, "cpu"))
                    $root.telemetry.module.cpu.v1.ModuleRegistration.encode(message.cpu, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                if (message.gpu != null && Object.hasOwnProperty.call(message, "gpu"))
                    $root.telemetry.module.gpu.v1.ModuleRegistration.encode(message.gpu, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                if (message.memory != null && Object.hasOwnProperty.call(message, "memory"))
                    $root.telemetry.module.memory.v1.ModuleRegistration.encode(message.memory, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
                if (message.storage != null && Object.hasOwnProperty.call(message, "storage"))
                    $root.telemetry.module.storage.v1.ModuleRegistration.encode(message.storage, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
                if (message.network != null && Object.hasOwnProperty.call(message, "network"))
                    $root.telemetry.module.network.v1.ModuleRegistration.encode(message.network, writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
                if (message.process != null && Object.hasOwnProperty.call(message, "process"))
                    $root.telemetry.module.process.v1.ModuleRegistration.encode(message.process, writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ModuleRegistration message, length delimited. Does not implicitly {@link telemetry.v1.ModuleRegistration.verify|verify} messages.
             * @function encodeDelimited
             * @memberof telemetry.v1.ModuleRegistration
             * @static
             * @param {telemetry.v1.IModuleRegistration} message ModuleRegistration message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ModuleRegistration.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ModuleRegistration message from the specified reader or buffer.
             * @function decode
             * @memberof telemetry.v1.ModuleRegistration
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {telemetry.v1.ModuleRegistration} ModuleRegistration
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ModuleRegistration.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.telemetry.v1.ModuleRegistration();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.name = reader.string();
                            break;
                        }
                    case 10: {
                            message.cpu = $root.telemetry.module.cpu.v1.ModuleRegistration.decode(reader, reader.uint32());
                            break;
                        }
                    case 11: {
                            message.gpu = $root.telemetry.module.gpu.v1.ModuleRegistration.decode(reader, reader.uint32());
                            break;
                        }
                    case 12: {
                            message.memory = $root.telemetry.module.memory.v1.ModuleRegistration.decode(reader, reader.uint32());
                            break;
                        }
                    case 13: {
                            message.storage = $root.telemetry.module.storage.v1.ModuleRegistration.decode(reader, reader.uint32());
                            break;
                        }
                    case 14: {
                            message.network = $root.telemetry.module.network.v1.ModuleRegistration.decode(reader, reader.uint32());
                            break;
                        }
                    case 15: {
                            message.process = $root.telemetry.module.process.v1.ModuleRegistration.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ModuleRegistration message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof telemetry.v1.ModuleRegistration
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {telemetry.v1.ModuleRegistration} ModuleRegistration
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ModuleRegistration.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ModuleRegistration message.
             * @function verify
             * @memberof telemetry.v1.ModuleRegistration
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ModuleRegistration.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.cpu != null && message.hasOwnProperty("cpu")) {
                    properties.metadata = 1;
                    {
                        let error = $root.telemetry.module.cpu.v1.ModuleRegistration.verify(message.cpu);
                        if (error)
                            return "cpu." + error;
                    }
                }
                if (message.gpu != null && message.hasOwnProperty("gpu")) {
                    if (properties.metadata === 1)
                        return "metadata: multiple values";
                    properties.metadata = 1;
                    {
                        let error = $root.telemetry.module.gpu.v1.ModuleRegistration.verify(message.gpu);
                        if (error)
                            return "gpu." + error;
                    }
                }
                if (message.memory != null && message.hasOwnProperty("memory")) {
                    if (properties.metadata === 1)
                        return "metadata: multiple values";
                    properties.metadata = 1;
                    {
                        let error = $root.telemetry.module.memory.v1.ModuleRegistration.verify(message.memory);
                        if (error)
                            return "memory." + error;
                    }
                }
                if (message.storage != null && message.hasOwnProperty("storage")) {
                    if (properties.metadata === 1)
                        return "metadata: multiple values";
                    properties.metadata = 1;
                    {
                        let error = $root.telemetry.module.storage.v1.ModuleRegistration.verify(message.storage);
                        if (error)
                            return "storage." + error;
                    }
                }
                if (message.network != null && message.hasOwnProperty("network")) {
                    if (properties.metadata === 1)
                        return "metadata: multiple values";
                    properties.metadata = 1;
                    {
                        let error = $root.telemetry.module.network.v1.ModuleRegistration.verify(message.network);
                        if (error)
                            return "network." + error;
                    }
                }
                if (message.process != null && message.hasOwnProperty("process")) {
                    if (properties.metadata === 1)
                        return "metadata: multiple values";
                    properties.metadata = 1;
                    {
                        let error = $root.telemetry.module.process.v1.ModuleRegistration.verify(message.process);
                        if (error)
                            return "process." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a ModuleRegistration message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof telemetry.v1.ModuleRegistration
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {telemetry.v1.ModuleRegistration} ModuleRegistration
             */
            ModuleRegistration.fromObject = function fromObject(object) {
                if (object instanceof $root.telemetry.v1.ModuleRegistration)
                    return object;
                let message = new $root.telemetry.v1.ModuleRegistration();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.cpu != null) {
                    if (typeof object.cpu !== "object")
                        throw TypeError(".telemetry.v1.ModuleRegistration.cpu: object expected");
                    message.cpu = $root.telemetry.module.cpu.v1.ModuleRegistration.fromObject(object.cpu);
                }
                if (object.gpu != null) {
                    if (typeof object.gpu !== "object")
                        throw TypeError(".telemetry.v1.ModuleRegistration.gpu: object expected");
                    message.gpu = $root.telemetry.module.gpu.v1.ModuleRegistration.fromObject(object.gpu);
                }
                if (object.memory != null) {
                    if (typeof object.memory !== "object")
                        throw TypeError(".telemetry.v1.ModuleRegistration.memory: object expected");
                    message.memory = $root.telemetry.module.memory.v1.ModuleRegistration.fromObject(object.memory);
                }
                if (object.storage != null) {
                    if (typeof object.storage !== "object")
                        throw TypeError(".telemetry.v1.ModuleRegistration.storage: object expected");
                    message.storage = $root.telemetry.module.storage.v1.ModuleRegistration.fromObject(object.storage);
                }
                if (object.network != null) {
                    if (typeof object.network !== "object")
                        throw TypeError(".telemetry.v1.ModuleRegistration.network: object expected");
                    message.network = $root.telemetry.module.network.v1.ModuleRegistration.fromObject(object.network);
                }
                if (object.process != null) {
                    if (typeof object.process !== "object")
                        throw TypeError(".telemetry.v1.ModuleRegistration.process: object expected");
                    message.process = $root.telemetry.module.process.v1.ModuleRegistration.fromObject(object.process);
                }
                return message;
            };

            /**
             * Creates a plain object from a ModuleRegistration message. Also converts values to other types if specified.
             * @function toObject
             * @memberof telemetry.v1.ModuleRegistration
             * @static
             * @param {telemetry.v1.ModuleRegistration} message ModuleRegistration
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ModuleRegistration.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.name = "";
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.cpu != null && message.hasOwnProperty("cpu")) {
                    object.cpu = $root.telemetry.module.cpu.v1.ModuleRegistration.toObject(message.cpu, options);
                    if (options.oneofs)
                        object.metadata = "cpu";
                }
                if (message.gpu != null && message.hasOwnProperty("gpu")) {
                    object.gpu = $root.telemetry.module.gpu.v1.ModuleRegistration.toObject(message.gpu, options);
                    if (options.oneofs)
                        object.metadata = "gpu";
                }
                if (message.memory != null && message.hasOwnProperty("memory")) {
                    object.memory = $root.telemetry.module.memory.v1.ModuleRegistration.toObject(message.memory, options);
                    if (options.oneofs)
                        object.metadata = "memory";
                }
                if (message.storage != null && message.hasOwnProperty("storage")) {
                    object.storage = $root.telemetry.module.storage.v1.ModuleRegistration.toObject(message.storage, options);
                    if (options.oneofs)
                        object.metadata = "storage";
                }
                if (message.network != null && message.hasOwnProperty("network")) {
                    object.network = $root.telemetry.module.network.v1.ModuleRegistration.toObject(message.network, options);
                    if (options.oneofs)
                        object.metadata = "network";
                }
                if (message.process != null && message.hasOwnProperty("process")) {
                    object.process = $root.telemetry.module.process.v1.ModuleRegistration.toObject(message.process, options);
                    if (options.oneofs)
                        object.metadata = "process";
                }
                return object;
            };

            /**
             * Converts this ModuleRegistration to JSON.
             * @function toJSON
             * @memberof telemetry.v1.ModuleRegistration
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ModuleRegistration.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ModuleRegistration
             * @function getTypeUrl
             * @memberof telemetry.v1.ModuleRegistration
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ModuleRegistration.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/telemetry.v1.ModuleRegistration";
            };

            return ModuleRegistration;
        })();

        v1.Registration = (function() {

            /**
             * Properties of a Registration.
             * @memberof telemetry.v1
             * @interface IRegistration
             * @property {string|null} [nodeId] Registration nodeId
             * @property {telemetry.v1.IBasicInfo|null} [basic] Registration basic
             * @property {Array.<telemetry.v1.IModuleRegistration>|null} [modules] Registration modules
             * @property {number|Long|null} [atUnixNano] Registration atUnixNano
             */

            /**
             * Constructs a new Registration.
             * @memberof telemetry.v1
             * @classdesc Represents a Registration.
             * @implements IRegistration
             * @constructor
             * @param {telemetry.v1.IRegistration=} [properties] Properties to set
             */
            function Registration(properties) {
                this.modules = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Registration nodeId.
             * @member {string} nodeId
             * @memberof telemetry.v1.Registration
             * @instance
             */
            Registration.prototype.nodeId = "";

            /**
             * Registration basic.
             * @member {telemetry.v1.IBasicInfo|null|undefined} basic
             * @memberof telemetry.v1.Registration
             * @instance
             */
            Registration.prototype.basic = null;

            /**
             * Registration modules.
             * @member {Array.<telemetry.v1.IModuleRegistration>} modules
             * @memberof telemetry.v1.Registration
             * @instance
             */
            Registration.prototype.modules = $util.emptyArray;

            /**
             * Registration atUnixNano.
             * @member {number|Long} atUnixNano
             * @memberof telemetry.v1.Registration
             * @instance
             */
            Registration.prototype.atUnixNano = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new Registration instance using the specified properties.
             * @function create
             * @memberof telemetry.v1.Registration
             * @static
             * @param {telemetry.v1.IRegistration=} [properties] Properties to set
             * @returns {telemetry.v1.Registration} Registration instance
             */
            Registration.create = function create(properties) {
                return new Registration(properties);
            };

            /**
             * Encodes the specified Registration message. Does not implicitly {@link telemetry.v1.Registration.verify|verify} messages.
             * @function encode
             * @memberof telemetry.v1.Registration
             * @static
             * @param {telemetry.v1.IRegistration} message Registration message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Registration.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.nodeId != null && Object.hasOwnProperty.call(message, "nodeId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.nodeId);
                if (message.basic != null && Object.hasOwnProperty.call(message, "basic"))
                    $root.telemetry.v1.BasicInfo.encode(message.basic, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.modules != null && message.modules.length)
                    for (let i = 0; i < message.modules.length; ++i)
                        $root.telemetry.v1.ModuleRegistration.encode(message.modules[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.atUnixNano != null && Object.hasOwnProperty.call(message, "atUnixNano"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int64(message.atUnixNano);
                return writer;
            };

            /**
             * Encodes the specified Registration message, length delimited. Does not implicitly {@link telemetry.v1.Registration.verify|verify} messages.
             * @function encodeDelimited
             * @memberof telemetry.v1.Registration
             * @static
             * @param {telemetry.v1.IRegistration} message Registration message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Registration.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Registration message from the specified reader or buffer.
             * @function decode
             * @memberof telemetry.v1.Registration
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {telemetry.v1.Registration} Registration
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Registration.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.telemetry.v1.Registration();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.nodeId = reader.string();
                            break;
                        }
                    case 2: {
                            message.basic = $root.telemetry.v1.BasicInfo.decode(reader, reader.uint32());
                            break;
                        }
                    case 3: {
                            if (!(message.modules && message.modules.length))
                                message.modules = [];
                            message.modules.push($root.telemetry.v1.ModuleRegistration.decode(reader, reader.uint32()));
                            break;
                        }
                    case 4: {
                            message.atUnixNano = reader.int64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Registration message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof telemetry.v1.Registration
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {telemetry.v1.Registration} Registration
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Registration.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Registration message.
             * @function verify
             * @memberof telemetry.v1.Registration
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Registration.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.nodeId != null && message.hasOwnProperty("nodeId"))
                    if (!$util.isString(message.nodeId))
                        return "nodeId: string expected";
                if (message.basic != null && message.hasOwnProperty("basic")) {
                    let error = $root.telemetry.v1.BasicInfo.verify(message.basic);
                    if (error)
                        return "basic." + error;
                }
                if (message.modules != null && message.hasOwnProperty("modules")) {
                    if (!Array.isArray(message.modules))
                        return "modules: array expected";
                    for (let i = 0; i < message.modules.length; ++i) {
                        let error = $root.telemetry.v1.ModuleRegistration.verify(message.modules[i]);
                        if (error)
                            return "modules." + error;
                    }
                }
                if (message.atUnixNano != null && message.hasOwnProperty("atUnixNano"))
                    if (!$util.isInteger(message.atUnixNano) && !(message.atUnixNano && $util.isInteger(message.atUnixNano.low) && $util.isInteger(message.atUnixNano.high)))
                        return "atUnixNano: integer|Long expected";
                return null;
            };

            /**
             * Creates a Registration message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof telemetry.v1.Registration
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {telemetry.v1.Registration} Registration
             */
            Registration.fromObject = function fromObject(object) {
                if (object instanceof $root.telemetry.v1.Registration)
                    return object;
                let message = new $root.telemetry.v1.Registration();
                if (object.nodeId != null)
                    message.nodeId = String(object.nodeId);
                if (object.basic != null) {
                    if (typeof object.basic !== "object")
                        throw TypeError(".telemetry.v1.Registration.basic: object expected");
                    message.basic = $root.telemetry.v1.BasicInfo.fromObject(object.basic);
                }
                if (object.modules) {
                    if (!Array.isArray(object.modules))
                        throw TypeError(".telemetry.v1.Registration.modules: array expected");
                    message.modules = [];
                    for (let i = 0; i < object.modules.length; ++i) {
                        if (typeof object.modules[i] !== "object")
                            throw TypeError(".telemetry.v1.Registration.modules: object expected");
                        message.modules[i] = $root.telemetry.v1.ModuleRegistration.fromObject(object.modules[i]);
                    }
                }
                if (object.atUnixNano != null)
                    if ($util.Long)
                        (message.atUnixNano = $util.Long.fromValue(object.atUnixNano)).unsigned = false;
                    else if (typeof object.atUnixNano === "string")
                        message.atUnixNano = parseInt(object.atUnixNano, 10);
                    else if (typeof object.atUnixNano === "number")
                        message.atUnixNano = object.atUnixNano;
                    else if (typeof object.atUnixNano === "object")
                        message.atUnixNano = new $util.LongBits(object.atUnixNano.low >>> 0, object.atUnixNano.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from a Registration message. Also converts values to other types if specified.
             * @function toObject
             * @memberof telemetry.v1.Registration
             * @static
             * @param {telemetry.v1.Registration} message Registration
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Registration.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.modules = [];
                if (options.defaults) {
                    object.nodeId = "";
                    object.basic = null;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, false);
                        object.atUnixNano = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.atUnixNano = options.longs === String ? "0" : 0;
                }
                if (message.nodeId != null && message.hasOwnProperty("nodeId"))
                    object.nodeId = message.nodeId;
                if (message.basic != null && message.hasOwnProperty("basic"))
                    object.basic = $root.telemetry.v1.BasicInfo.toObject(message.basic, options);
                if (message.modules && message.modules.length) {
                    object.modules = [];
                    for (let j = 0; j < message.modules.length; ++j)
                        object.modules[j] = $root.telemetry.v1.ModuleRegistration.toObject(message.modules[j], options);
                }
                if (message.atUnixNano != null && message.hasOwnProperty("atUnixNano"))
                    if (typeof message.atUnixNano === "number")
                        object.atUnixNano = options.longs === String ? String(message.atUnixNano) : message.atUnixNano;
                    else
                        object.atUnixNano = options.longs === String ? $util.Long.prototype.toString.call(message.atUnixNano) : options.longs === Number ? new $util.LongBits(message.atUnixNano.low >>> 0, message.atUnixNano.high >>> 0).toNumber() : message.atUnixNano;
                return object;
            };

            /**
             * Converts this Registration to JSON.
             * @function toJSON
             * @memberof telemetry.v1.Registration
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Registration.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Registration
             * @function getTypeUrl
             * @memberof telemetry.v1.Registration
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Registration.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/telemetry.v1.Registration";
            };

            return Registration;
        })();

        v1.Heartbeat = (function() {

            /**
             * Properties of a Heartbeat.
             * @memberof telemetry.v1
             * @interface IHeartbeat
             * @property {string|null} [nodeId] Heartbeat nodeId
             * @property {number|Long|null} [atUnixNano] Heartbeat atUnixNano
             */

            /**
             * Constructs a new Heartbeat.
             * @memberof telemetry.v1
             * @classdesc Represents a Heartbeat.
             * @implements IHeartbeat
             * @constructor
             * @param {telemetry.v1.IHeartbeat=} [properties] Properties to set
             */
            function Heartbeat(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Heartbeat nodeId.
             * @member {string} nodeId
             * @memberof telemetry.v1.Heartbeat
             * @instance
             */
            Heartbeat.prototype.nodeId = "";

            /**
             * Heartbeat atUnixNano.
             * @member {number|Long} atUnixNano
             * @memberof telemetry.v1.Heartbeat
             * @instance
             */
            Heartbeat.prototype.atUnixNano = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new Heartbeat instance using the specified properties.
             * @function create
             * @memberof telemetry.v1.Heartbeat
             * @static
             * @param {telemetry.v1.IHeartbeat=} [properties] Properties to set
             * @returns {telemetry.v1.Heartbeat} Heartbeat instance
             */
            Heartbeat.create = function create(properties) {
                return new Heartbeat(properties);
            };

            /**
             * Encodes the specified Heartbeat message. Does not implicitly {@link telemetry.v1.Heartbeat.verify|verify} messages.
             * @function encode
             * @memberof telemetry.v1.Heartbeat
             * @static
             * @param {telemetry.v1.IHeartbeat} message Heartbeat message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Heartbeat.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.nodeId != null && Object.hasOwnProperty.call(message, "nodeId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.nodeId);
                if (message.atUnixNano != null && Object.hasOwnProperty.call(message, "atUnixNano"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.atUnixNano);
                return writer;
            };

            /**
             * Encodes the specified Heartbeat message, length delimited. Does not implicitly {@link telemetry.v1.Heartbeat.verify|verify} messages.
             * @function encodeDelimited
             * @memberof telemetry.v1.Heartbeat
             * @static
             * @param {telemetry.v1.IHeartbeat} message Heartbeat message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Heartbeat.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Heartbeat message from the specified reader or buffer.
             * @function decode
             * @memberof telemetry.v1.Heartbeat
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {telemetry.v1.Heartbeat} Heartbeat
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Heartbeat.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.telemetry.v1.Heartbeat();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.nodeId = reader.string();
                            break;
                        }
                    case 2: {
                            message.atUnixNano = reader.int64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Heartbeat message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof telemetry.v1.Heartbeat
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {telemetry.v1.Heartbeat} Heartbeat
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Heartbeat.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Heartbeat message.
             * @function verify
             * @memberof telemetry.v1.Heartbeat
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Heartbeat.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.nodeId != null && message.hasOwnProperty("nodeId"))
                    if (!$util.isString(message.nodeId))
                        return "nodeId: string expected";
                if (message.atUnixNano != null && message.hasOwnProperty("atUnixNano"))
                    if (!$util.isInteger(message.atUnixNano) && !(message.atUnixNano && $util.isInteger(message.atUnixNano.low) && $util.isInteger(message.atUnixNano.high)))
                        return "atUnixNano: integer|Long expected";
                return null;
            };

            /**
             * Creates a Heartbeat message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof telemetry.v1.Heartbeat
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {telemetry.v1.Heartbeat} Heartbeat
             */
            Heartbeat.fromObject = function fromObject(object) {
                if (object instanceof $root.telemetry.v1.Heartbeat)
                    return object;
                let message = new $root.telemetry.v1.Heartbeat();
                if (object.nodeId != null)
                    message.nodeId = String(object.nodeId);
                if (object.atUnixNano != null)
                    if ($util.Long)
                        (message.atUnixNano = $util.Long.fromValue(object.atUnixNano)).unsigned = false;
                    else if (typeof object.atUnixNano === "string")
                        message.atUnixNano = parseInt(object.atUnixNano, 10);
                    else if (typeof object.atUnixNano === "number")
                        message.atUnixNano = object.atUnixNano;
                    else if (typeof object.atUnixNano === "object")
                        message.atUnixNano = new $util.LongBits(object.atUnixNano.low >>> 0, object.atUnixNano.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from a Heartbeat message. Also converts values to other types if specified.
             * @function toObject
             * @memberof telemetry.v1.Heartbeat
             * @static
             * @param {telemetry.v1.Heartbeat} message Heartbeat
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Heartbeat.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.nodeId = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, false);
                        object.atUnixNano = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.atUnixNano = options.longs === String ? "0" : 0;
                }
                if (message.nodeId != null && message.hasOwnProperty("nodeId"))
                    object.nodeId = message.nodeId;
                if (message.atUnixNano != null && message.hasOwnProperty("atUnixNano"))
                    if (typeof message.atUnixNano === "number")
                        object.atUnixNano = options.longs === String ? String(message.atUnixNano) : message.atUnixNano;
                    else
                        object.atUnixNano = options.longs === String ? $util.Long.prototype.toString.call(message.atUnixNano) : options.longs === Number ? new $util.LongBits(message.atUnixNano.low >>> 0, message.atUnixNano.high >>> 0).toNumber() : message.atUnixNano;
                return object;
            };

            /**
             * Converts this Heartbeat to JSON.
             * @function toJSON
             * @memberof telemetry.v1.Heartbeat
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Heartbeat.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Heartbeat
             * @function getTypeUrl
             * @memberof telemetry.v1.Heartbeat
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Heartbeat.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/telemetry.v1.Heartbeat";
            };

            return Heartbeat;
        })();

        v1.MetricSample = (function() {

            /**
             * Properties of a MetricSample.
             * @memberof telemetry.v1
             * @interface IMetricSample
             * @property {string|null} [category] MetricSample category
             * @property {number|Long|null} [atUnixNano] MetricSample atUnixNano
             * @property {telemetry.module.cpu.v1.IUltraMetrics|null} [cpuUltraMetrics] MetricSample cpuUltraMetrics
             * @property {telemetry.module.cpu.v1.IMediumMetrics|null} [cpuMediumMetrics] MetricSample cpuMediumMetrics
             * @property {telemetry.module.gpu.v1.IFastMetrics|null} [gpuFastMetrics] MetricSample gpuFastMetrics
             * @property {telemetry.module.memory.v1.IMetrics|null} [memoryMetrics] MetricSample memoryMetrics
             * @property {telemetry.module.storage.v1.IMetrics|null} [storageMetrics] MetricSample storageMetrics
             * @property {telemetry.module.network.v1.IMetrics|null} [networkMetrics] MetricSample networkMetrics
             * @property {telemetry.module.process.v1.IMetrics|null} [processMetrics] MetricSample processMetrics
             */

            /**
             * Constructs a new MetricSample.
             * @memberof telemetry.v1
             * @classdesc Represents a MetricSample.
             * @implements IMetricSample
             * @constructor
             * @param {telemetry.v1.IMetricSample=} [properties] Properties to set
             */
            function MetricSample(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MetricSample category.
             * @member {string} category
             * @memberof telemetry.v1.MetricSample
             * @instance
             */
            MetricSample.prototype.category = "";

            /**
             * MetricSample atUnixNano.
             * @member {number|Long} atUnixNano
             * @memberof telemetry.v1.MetricSample
             * @instance
             */
            MetricSample.prototype.atUnixNano = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * MetricSample cpuUltraMetrics.
             * @member {telemetry.module.cpu.v1.IUltraMetrics|null|undefined} cpuUltraMetrics
             * @memberof telemetry.v1.MetricSample
             * @instance
             */
            MetricSample.prototype.cpuUltraMetrics = null;

            /**
             * MetricSample cpuMediumMetrics.
             * @member {telemetry.module.cpu.v1.IMediumMetrics|null|undefined} cpuMediumMetrics
             * @memberof telemetry.v1.MetricSample
             * @instance
             */
            MetricSample.prototype.cpuMediumMetrics = null;

            /**
             * MetricSample gpuFastMetrics.
             * @member {telemetry.module.gpu.v1.IFastMetrics|null|undefined} gpuFastMetrics
             * @memberof telemetry.v1.MetricSample
             * @instance
             */
            MetricSample.prototype.gpuFastMetrics = null;

            /**
             * MetricSample memoryMetrics.
             * @member {telemetry.module.memory.v1.IMetrics|null|undefined} memoryMetrics
             * @memberof telemetry.v1.MetricSample
             * @instance
             */
            MetricSample.prototype.memoryMetrics = null;

            /**
             * MetricSample storageMetrics.
             * @member {telemetry.module.storage.v1.IMetrics|null|undefined} storageMetrics
             * @memberof telemetry.v1.MetricSample
             * @instance
             */
            MetricSample.prototype.storageMetrics = null;

            /**
             * MetricSample networkMetrics.
             * @member {telemetry.module.network.v1.IMetrics|null|undefined} networkMetrics
             * @memberof telemetry.v1.MetricSample
             * @instance
             */
            MetricSample.prototype.networkMetrics = null;

            /**
             * MetricSample processMetrics.
             * @member {telemetry.module.process.v1.IMetrics|null|undefined} processMetrics
             * @memberof telemetry.v1.MetricSample
             * @instance
             */
            MetricSample.prototype.processMetrics = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * MetricSample payload.
             * @member {"cpuUltraMetrics"|"cpuMediumMetrics"|"gpuFastMetrics"|"memoryMetrics"|"storageMetrics"|"networkMetrics"|"processMetrics"|undefined} payload
             * @memberof telemetry.v1.MetricSample
             * @instance
             */
            Object.defineProperty(MetricSample.prototype, "payload", {
                get: $util.oneOfGetter($oneOfFields = ["cpuUltraMetrics", "cpuMediumMetrics", "gpuFastMetrics", "memoryMetrics", "storageMetrics", "networkMetrics", "processMetrics"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new MetricSample instance using the specified properties.
             * @function create
             * @memberof telemetry.v1.MetricSample
             * @static
             * @param {telemetry.v1.IMetricSample=} [properties] Properties to set
             * @returns {telemetry.v1.MetricSample} MetricSample instance
             */
            MetricSample.create = function create(properties) {
                return new MetricSample(properties);
            };

            /**
             * Encodes the specified MetricSample message. Does not implicitly {@link telemetry.v1.MetricSample.verify|verify} messages.
             * @function encode
             * @memberof telemetry.v1.MetricSample
             * @static
             * @param {telemetry.v1.IMetricSample} message MetricSample message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MetricSample.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.category != null && Object.hasOwnProperty.call(message, "category"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.category);
                if (message.atUnixNano != null && Object.hasOwnProperty.call(message, "atUnixNano"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.atUnixNano);
                if (message.cpuUltraMetrics != null && Object.hasOwnProperty.call(message, "cpuUltraMetrics"))
                    $root.telemetry.module.cpu.v1.UltraMetrics.encode(message.cpuUltraMetrics, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                if (message.cpuMediumMetrics != null && Object.hasOwnProperty.call(message, "cpuMediumMetrics"))
                    $root.telemetry.module.cpu.v1.MediumMetrics.encode(message.cpuMediumMetrics, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                if (message.gpuFastMetrics != null && Object.hasOwnProperty.call(message, "gpuFastMetrics"))
                    $root.telemetry.module.gpu.v1.FastMetrics.encode(message.gpuFastMetrics, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
                if (message.memoryMetrics != null && Object.hasOwnProperty.call(message, "memoryMetrics"))
                    $root.telemetry.module.memory.v1.Metrics.encode(message.memoryMetrics, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
                if (message.storageMetrics != null && Object.hasOwnProperty.call(message, "storageMetrics"))
                    $root.telemetry.module.storage.v1.Metrics.encode(message.storageMetrics, writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
                if (message.networkMetrics != null && Object.hasOwnProperty.call(message, "networkMetrics"))
                    $root.telemetry.module.network.v1.Metrics.encode(message.networkMetrics, writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
                if (message.processMetrics != null && Object.hasOwnProperty.call(message, "processMetrics"))
                    $root.telemetry.module.process.v1.Metrics.encode(message.processMetrics, writer.uint32(/* id 16, wireType 2 =*/130).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified MetricSample message, length delimited. Does not implicitly {@link telemetry.v1.MetricSample.verify|verify} messages.
             * @function encodeDelimited
             * @memberof telemetry.v1.MetricSample
             * @static
             * @param {telemetry.v1.IMetricSample} message MetricSample message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MetricSample.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MetricSample message from the specified reader or buffer.
             * @function decode
             * @memberof telemetry.v1.MetricSample
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {telemetry.v1.MetricSample} MetricSample
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MetricSample.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.telemetry.v1.MetricSample();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.category = reader.string();
                            break;
                        }
                    case 2: {
                            message.atUnixNano = reader.int64();
                            break;
                        }
                    case 10: {
                            message.cpuUltraMetrics = $root.telemetry.module.cpu.v1.UltraMetrics.decode(reader, reader.uint32());
                            break;
                        }
                    case 11: {
                            message.cpuMediumMetrics = $root.telemetry.module.cpu.v1.MediumMetrics.decode(reader, reader.uint32());
                            break;
                        }
                    case 12: {
                            message.gpuFastMetrics = $root.telemetry.module.gpu.v1.FastMetrics.decode(reader, reader.uint32());
                            break;
                        }
                    case 13: {
                            message.memoryMetrics = $root.telemetry.module.memory.v1.Metrics.decode(reader, reader.uint32());
                            break;
                        }
                    case 14: {
                            message.storageMetrics = $root.telemetry.module.storage.v1.Metrics.decode(reader, reader.uint32());
                            break;
                        }
                    case 15: {
                            message.networkMetrics = $root.telemetry.module.network.v1.Metrics.decode(reader, reader.uint32());
                            break;
                        }
                    case 16: {
                            message.processMetrics = $root.telemetry.module.process.v1.Metrics.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MetricSample message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof telemetry.v1.MetricSample
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {telemetry.v1.MetricSample} MetricSample
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MetricSample.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MetricSample message.
             * @function verify
             * @memberof telemetry.v1.MetricSample
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MetricSample.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.category != null && message.hasOwnProperty("category"))
                    if (!$util.isString(message.category))
                        return "category: string expected";
                if (message.atUnixNano != null && message.hasOwnProperty("atUnixNano"))
                    if (!$util.isInteger(message.atUnixNano) && !(message.atUnixNano && $util.isInteger(message.atUnixNano.low) && $util.isInteger(message.atUnixNano.high)))
                        return "atUnixNano: integer|Long expected";
                if (message.cpuUltraMetrics != null && message.hasOwnProperty("cpuUltraMetrics")) {
                    properties.payload = 1;
                    {
                        let error = $root.telemetry.module.cpu.v1.UltraMetrics.verify(message.cpuUltraMetrics);
                        if (error)
                            return "cpuUltraMetrics." + error;
                    }
                }
                if (message.cpuMediumMetrics != null && message.hasOwnProperty("cpuMediumMetrics")) {
                    if (properties.payload === 1)
                        return "payload: multiple values";
                    properties.payload = 1;
                    {
                        let error = $root.telemetry.module.cpu.v1.MediumMetrics.verify(message.cpuMediumMetrics);
                        if (error)
                            return "cpuMediumMetrics." + error;
                    }
                }
                if (message.gpuFastMetrics != null && message.hasOwnProperty("gpuFastMetrics")) {
                    if (properties.payload === 1)
                        return "payload: multiple values";
                    properties.payload = 1;
                    {
                        let error = $root.telemetry.module.gpu.v1.FastMetrics.verify(message.gpuFastMetrics);
                        if (error)
                            return "gpuFastMetrics." + error;
                    }
                }
                if (message.memoryMetrics != null && message.hasOwnProperty("memoryMetrics")) {
                    if (properties.payload === 1)
                        return "payload: multiple values";
                    properties.payload = 1;
                    {
                        let error = $root.telemetry.module.memory.v1.Metrics.verify(message.memoryMetrics);
                        if (error)
                            return "memoryMetrics." + error;
                    }
                }
                if (message.storageMetrics != null && message.hasOwnProperty("storageMetrics")) {
                    if (properties.payload === 1)
                        return "payload: multiple values";
                    properties.payload = 1;
                    {
                        let error = $root.telemetry.module.storage.v1.Metrics.verify(message.storageMetrics);
                        if (error)
                            return "storageMetrics." + error;
                    }
                }
                if (message.networkMetrics != null && message.hasOwnProperty("networkMetrics")) {
                    if (properties.payload === 1)
                        return "payload: multiple values";
                    properties.payload = 1;
                    {
                        let error = $root.telemetry.module.network.v1.Metrics.verify(message.networkMetrics);
                        if (error)
                            return "networkMetrics." + error;
                    }
                }
                if (message.processMetrics != null && message.hasOwnProperty("processMetrics")) {
                    if (properties.payload === 1)
                        return "payload: multiple values";
                    properties.payload = 1;
                    {
                        let error = $root.telemetry.module.process.v1.Metrics.verify(message.processMetrics);
                        if (error)
                            return "processMetrics." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a MetricSample message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof telemetry.v1.MetricSample
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {telemetry.v1.MetricSample} MetricSample
             */
            MetricSample.fromObject = function fromObject(object) {
                if (object instanceof $root.telemetry.v1.MetricSample)
                    return object;
                let message = new $root.telemetry.v1.MetricSample();
                if (object.category != null)
                    message.category = String(object.category);
                if (object.atUnixNano != null)
                    if ($util.Long)
                        (message.atUnixNano = $util.Long.fromValue(object.atUnixNano)).unsigned = false;
                    else if (typeof object.atUnixNano === "string")
                        message.atUnixNano = parseInt(object.atUnixNano, 10);
                    else if (typeof object.atUnixNano === "number")
                        message.atUnixNano = object.atUnixNano;
                    else if (typeof object.atUnixNano === "object")
                        message.atUnixNano = new $util.LongBits(object.atUnixNano.low >>> 0, object.atUnixNano.high >>> 0).toNumber();
                if (object.cpuUltraMetrics != null) {
                    if (typeof object.cpuUltraMetrics !== "object")
                        throw TypeError(".telemetry.v1.MetricSample.cpuUltraMetrics: object expected");
                    message.cpuUltraMetrics = $root.telemetry.module.cpu.v1.UltraMetrics.fromObject(object.cpuUltraMetrics);
                }
                if (object.cpuMediumMetrics != null) {
                    if (typeof object.cpuMediumMetrics !== "object")
                        throw TypeError(".telemetry.v1.MetricSample.cpuMediumMetrics: object expected");
                    message.cpuMediumMetrics = $root.telemetry.module.cpu.v1.MediumMetrics.fromObject(object.cpuMediumMetrics);
                }
                if (object.gpuFastMetrics != null) {
                    if (typeof object.gpuFastMetrics !== "object")
                        throw TypeError(".telemetry.v1.MetricSample.gpuFastMetrics: object expected");
                    message.gpuFastMetrics = $root.telemetry.module.gpu.v1.FastMetrics.fromObject(object.gpuFastMetrics);
                }
                if (object.memoryMetrics != null) {
                    if (typeof object.memoryMetrics !== "object")
                        throw TypeError(".telemetry.v1.MetricSample.memoryMetrics: object expected");
                    message.memoryMetrics = $root.telemetry.module.memory.v1.Metrics.fromObject(object.memoryMetrics);
                }
                if (object.storageMetrics != null) {
                    if (typeof object.storageMetrics !== "object")
                        throw TypeError(".telemetry.v1.MetricSample.storageMetrics: object expected");
                    message.storageMetrics = $root.telemetry.module.storage.v1.Metrics.fromObject(object.storageMetrics);
                }
                if (object.networkMetrics != null) {
                    if (typeof object.networkMetrics !== "object")
                        throw TypeError(".telemetry.v1.MetricSample.networkMetrics: object expected");
                    message.networkMetrics = $root.telemetry.module.network.v1.Metrics.fromObject(object.networkMetrics);
                }
                if (object.processMetrics != null) {
                    if (typeof object.processMetrics !== "object")
                        throw TypeError(".telemetry.v1.MetricSample.processMetrics: object expected");
                    message.processMetrics = $root.telemetry.module.process.v1.Metrics.fromObject(object.processMetrics);
                }
                return message;
            };

            /**
             * Creates a plain object from a MetricSample message. Also converts values to other types if specified.
             * @function toObject
             * @memberof telemetry.v1.MetricSample
             * @static
             * @param {telemetry.v1.MetricSample} message MetricSample
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MetricSample.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.category = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, false);
                        object.atUnixNano = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.atUnixNano = options.longs === String ? "0" : 0;
                }
                if (message.category != null && message.hasOwnProperty("category"))
                    object.category = message.category;
                if (message.atUnixNano != null && message.hasOwnProperty("atUnixNano"))
                    if (typeof message.atUnixNano === "number")
                        object.atUnixNano = options.longs === String ? String(message.atUnixNano) : message.atUnixNano;
                    else
                        object.atUnixNano = options.longs === String ? $util.Long.prototype.toString.call(message.atUnixNano) : options.longs === Number ? new $util.LongBits(message.atUnixNano.low >>> 0, message.atUnixNano.high >>> 0).toNumber() : message.atUnixNano;
                if (message.cpuUltraMetrics != null && message.hasOwnProperty("cpuUltraMetrics")) {
                    object.cpuUltraMetrics = $root.telemetry.module.cpu.v1.UltraMetrics.toObject(message.cpuUltraMetrics, options);
                    if (options.oneofs)
                        object.payload = "cpuUltraMetrics";
                }
                if (message.cpuMediumMetrics != null && message.hasOwnProperty("cpuMediumMetrics")) {
                    object.cpuMediumMetrics = $root.telemetry.module.cpu.v1.MediumMetrics.toObject(message.cpuMediumMetrics, options);
                    if (options.oneofs)
                        object.payload = "cpuMediumMetrics";
                }
                if (message.gpuFastMetrics != null && message.hasOwnProperty("gpuFastMetrics")) {
                    object.gpuFastMetrics = $root.telemetry.module.gpu.v1.FastMetrics.toObject(message.gpuFastMetrics, options);
                    if (options.oneofs)
                        object.payload = "gpuFastMetrics";
                }
                if (message.memoryMetrics != null && message.hasOwnProperty("memoryMetrics")) {
                    object.memoryMetrics = $root.telemetry.module.memory.v1.Metrics.toObject(message.memoryMetrics, options);
                    if (options.oneofs)
                        object.payload = "memoryMetrics";
                }
                if (message.storageMetrics != null && message.hasOwnProperty("storageMetrics")) {
                    object.storageMetrics = $root.telemetry.module.storage.v1.Metrics.toObject(message.storageMetrics, options);
                    if (options.oneofs)
                        object.payload = "storageMetrics";
                }
                if (message.networkMetrics != null && message.hasOwnProperty("networkMetrics")) {
                    object.networkMetrics = $root.telemetry.module.network.v1.Metrics.toObject(message.networkMetrics, options);
                    if (options.oneofs)
                        object.payload = "networkMetrics";
                }
                if (message.processMetrics != null && message.hasOwnProperty("processMetrics")) {
                    object.processMetrics = $root.telemetry.module.process.v1.Metrics.toObject(message.processMetrics, options);
                    if (options.oneofs)
                        object.payload = "processMetrics";
                }
                return object;
            };

            /**
             * Converts this MetricSample to JSON.
             * @function toJSON
             * @memberof telemetry.v1.MetricSample
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MetricSample.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for MetricSample
             * @function getTypeUrl
             * @memberof telemetry.v1.MetricSample
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            MetricSample.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/telemetry.v1.MetricSample";
            };

            return MetricSample;
        })();

        v1.MetricsBatch = (function() {

            /**
             * Properties of a MetricsBatch.
             * @memberof telemetry.v1
             * @interface IMetricsBatch
             * @property {string|null} [nodeId] MetricsBatch nodeId
             * @property {Array.<telemetry.v1.IMetricSample>|null} [samples] MetricsBatch samples
             * @property {number|Long|null} [sentAtUnixNano] MetricsBatch sentAtUnixNano
             */

            /**
             * Constructs a new MetricsBatch.
             * @memberof telemetry.v1
             * @classdesc Represents a MetricsBatch.
             * @implements IMetricsBatch
             * @constructor
             * @param {telemetry.v1.IMetricsBatch=} [properties] Properties to set
             */
            function MetricsBatch(properties) {
                this.samples = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MetricsBatch nodeId.
             * @member {string} nodeId
             * @memberof telemetry.v1.MetricsBatch
             * @instance
             */
            MetricsBatch.prototype.nodeId = "";

            /**
             * MetricsBatch samples.
             * @member {Array.<telemetry.v1.IMetricSample>} samples
             * @memberof telemetry.v1.MetricsBatch
             * @instance
             */
            MetricsBatch.prototype.samples = $util.emptyArray;

            /**
             * MetricsBatch sentAtUnixNano.
             * @member {number|Long} sentAtUnixNano
             * @memberof telemetry.v1.MetricsBatch
             * @instance
             */
            MetricsBatch.prototype.sentAtUnixNano = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new MetricsBatch instance using the specified properties.
             * @function create
             * @memberof telemetry.v1.MetricsBatch
             * @static
             * @param {telemetry.v1.IMetricsBatch=} [properties] Properties to set
             * @returns {telemetry.v1.MetricsBatch} MetricsBatch instance
             */
            MetricsBatch.create = function create(properties) {
                return new MetricsBatch(properties);
            };

            /**
             * Encodes the specified MetricsBatch message. Does not implicitly {@link telemetry.v1.MetricsBatch.verify|verify} messages.
             * @function encode
             * @memberof telemetry.v1.MetricsBatch
             * @static
             * @param {telemetry.v1.IMetricsBatch} message MetricsBatch message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MetricsBatch.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.nodeId != null && Object.hasOwnProperty.call(message, "nodeId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.nodeId);
                if (message.samples != null && message.samples.length)
                    for (let i = 0; i < message.samples.length; ++i)
                        $root.telemetry.v1.MetricSample.encode(message.samples[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.sentAtUnixNano != null && Object.hasOwnProperty.call(message, "sentAtUnixNano"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.sentAtUnixNano);
                return writer;
            };

            /**
             * Encodes the specified MetricsBatch message, length delimited. Does not implicitly {@link telemetry.v1.MetricsBatch.verify|verify} messages.
             * @function encodeDelimited
             * @memberof telemetry.v1.MetricsBatch
             * @static
             * @param {telemetry.v1.IMetricsBatch} message MetricsBatch message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MetricsBatch.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MetricsBatch message from the specified reader or buffer.
             * @function decode
             * @memberof telemetry.v1.MetricsBatch
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {telemetry.v1.MetricsBatch} MetricsBatch
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MetricsBatch.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.telemetry.v1.MetricsBatch();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.nodeId = reader.string();
                            break;
                        }
                    case 2: {
                            if (!(message.samples && message.samples.length))
                                message.samples = [];
                            message.samples.push($root.telemetry.v1.MetricSample.decode(reader, reader.uint32()));
                            break;
                        }
                    case 3: {
                            message.sentAtUnixNano = reader.int64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MetricsBatch message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof telemetry.v1.MetricsBatch
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {telemetry.v1.MetricsBatch} MetricsBatch
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MetricsBatch.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MetricsBatch message.
             * @function verify
             * @memberof telemetry.v1.MetricsBatch
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MetricsBatch.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.nodeId != null && message.hasOwnProperty("nodeId"))
                    if (!$util.isString(message.nodeId))
                        return "nodeId: string expected";
                if (message.samples != null && message.hasOwnProperty("samples")) {
                    if (!Array.isArray(message.samples))
                        return "samples: array expected";
                    for (let i = 0; i < message.samples.length; ++i) {
                        let error = $root.telemetry.v1.MetricSample.verify(message.samples[i]);
                        if (error)
                            return "samples." + error;
                    }
                }
                if (message.sentAtUnixNano != null && message.hasOwnProperty("sentAtUnixNano"))
                    if (!$util.isInteger(message.sentAtUnixNano) && !(message.sentAtUnixNano && $util.isInteger(message.sentAtUnixNano.low) && $util.isInteger(message.sentAtUnixNano.high)))
                        return "sentAtUnixNano: integer|Long expected";
                return null;
            };

            /**
             * Creates a MetricsBatch message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof telemetry.v1.MetricsBatch
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {telemetry.v1.MetricsBatch} MetricsBatch
             */
            MetricsBatch.fromObject = function fromObject(object) {
                if (object instanceof $root.telemetry.v1.MetricsBatch)
                    return object;
                let message = new $root.telemetry.v1.MetricsBatch();
                if (object.nodeId != null)
                    message.nodeId = String(object.nodeId);
                if (object.samples) {
                    if (!Array.isArray(object.samples))
                        throw TypeError(".telemetry.v1.MetricsBatch.samples: array expected");
                    message.samples = [];
                    for (let i = 0; i < object.samples.length; ++i) {
                        if (typeof object.samples[i] !== "object")
                            throw TypeError(".telemetry.v1.MetricsBatch.samples: object expected");
                        message.samples[i] = $root.telemetry.v1.MetricSample.fromObject(object.samples[i]);
                    }
                }
                if (object.sentAtUnixNano != null)
                    if ($util.Long)
                        (message.sentAtUnixNano = $util.Long.fromValue(object.sentAtUnixNano)).unsigned = false;
                    else if (typeof object.sentAtUnixNano === "string")
                        message.sentAtUnixNano = parseInt(object.sentAtUnixNano, 10);
                    else if (typeof object.sentAtUnixNano === "number")
                        message.sentAtUnixNano = object.sentAtUnixNano;
                    else if (typeof object.sentAtUnixNano === "object")
                        message.sentAtUnixNano = new $util.LongBits(object.sentAtUnixNano.low >>> 0, object.sentAtUnixNano.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from a MetricsBatch message. Also converts values to other types if specified.
             * @function toObject
             * @memberof telemetry.v1.MetricsBatch
             * @static
             * @param {telemetry.v1.MetricsBatch} message MetricsBatch
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MetricsBatch.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.samples = [];
                if (options.defaults) {
                    object.nodeId = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, false);
                        object.sentAtUnixNano = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.sentAtUnixNano = options.longs === String ? "0" : 0;
                }
                if (message.nodeId != null && message.hasOwnProperty("nodeId"))
                    object.nodeId = message.nodeId;
                if (message.samples && message.samples.length) {
                    object.samples = [];
                    for (let j = 0; j < message.samples.length; ++j)
                        object.samples[j] = $root.telemetry.v1.MetricSample.toObject(message.samples[j], options);
                }
                if (message.sentAtUnixNano != null && message.hasOwnProperty("sentAtUnixNano"))
                    if (typeof message.sentAtUnixNano === "number")
                        object.sentAtUnixNano = options.longs === String ? String(message.sentAtUnixNano) : message.sentAtUnixNano;
                    else
                        object.sentAtUnixNano = options.longs === String ? $util.Long.prototype.toString.call(message.sentAtUnixNano) : options.longs === Number ? new $util.LongBits(message.sentAtUnixNano.low >>> 0, message.sentAtUnixNano.high >>> 0).toNumber() : message.sentAtUnixNano;
                return object;
            };

            /**
             * Converts this MetricsBatch to JSON.
             * @function toJSON
             * @memberof telemetry.v1.MetricsBatch
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MetricsBatch.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for MetricsBatch
             * @function getTypeUrl
             * @memberof telemetry.v1.MetricsBatch
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            MetricsBatch.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/telemetry.v1.MetricsBatch";
            };

            return MetricsBatch;
        })();

        v1.Command = (function() {

            /**
             * Properties of a Command.
             * @memberof telemetry.v1
             * @interface ICommand
             * @property {string|null} [id] Command id
             * @property {string|null} [nodeId] Command nodeId
             * @property {string|null} [type] Command type
             * @property {number|Long|null} [issuedAtUnixNano] Command issuedAtUnixNano
             * @property {telemetry.module.cpu.v1.IScalingRangeCommand|null} [cpuScalingRange] Command cpuScalingRange
             * @property {telemetry.module.cpu.v1.IGovernorCommand|null} [cpuGovernor] Command cpuGovernor
             * @property {telemetry.module.cpu.v1.IUncoreRangeCommand|null} [cpuUncoreRange] Command cpuUncoreRange
             * @property {telemetry.module.cpu.v1.IPowerCapCommand|null} [cpuPowerCap] Command cpuPowerCap
             * @property {telemetry.module.gpu.v1.IClockRangeCommand|null} [gpuClockRange] Command gpuClockRange
             * @property {telemetry.module.gpu.v1.IPowerCapCommand|null} [gpuPowerCap] Command gpuPowerCap
             * @property {telemetry.module.process.v1.ISignalCommand|null} [processSignal] Command processSignal
             */

            /**
             * Constructs a new Command.
             * @memberof telemetry.v1
             * @classdesc Represents a Command.
             * @implements ICommand
             * @constructor
             * @param {telemetry.v1.ICommand=} [properties] Properties to set
             */
            function Command(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Command id.
             * @member {string} id
             * @memberof telemetry.v1.Command
             * @instance
             */
            Command.prototype.id = "";

            /**
             * Command nodeId.
             * @member {string} nodeId
             * @memberof telemetry.v1.Command
             * @instance
             */
            Command.prototype.nodeId = "";

            /**
             * Command type.
             * @member {string} type
             * @memberof telemetry.v1.Command
             * @instance
             */
            Command.prototype.type = "";

            /**
             * Command issuedAtUnixNano.
             * @member {number|Long} issuedAtUnixNano
             * @memberof telemetry.v1.Command
             * @instance
             */
            Command.prototype.issuedAtUnixNano = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Command cpuScalingRange.
             * @member {telemetry.module.cpu.v1.IScalingRangeCommand|null|undefined} cpuScalingRange
             * @memberof telemetry.v1.Command
             * @instance
             */
            Command.prototype.cpuScalingRange = null;

            /**
             * Command cpuGovernor.
             * @member {telemetry.module.cpu.v1.IGovernorCommand|null|undefined} cpuGovernor
             * @memberof telemetry.v1.Command
             * @instance
             */
            Command.prototype.cpuGovernor = null;

            /**
             * Command cpuUncoreRange.
             * @member {telemetry.module.cpu.v1.IUncoreRangeCommand|null|undefined} cpuUncoreRange
             * @memberof telemetry.v1.Command
             * @instance
             */
            Command.prototype.cpuUncoreRange = null;

            /**
             * Command cpuPowerCap.
             * @member {telemetry.module.cpu.v1.IPowerCapCommand|null|undefined} cpuPowerCap
             * @memberof telemetry.v1.Command
             * @instance
             */
            Command.prototype.cpuPowerCap = null;

            /**
             * Command gpuClockRange.
             * @member {telemetry.module.gpu.v1.IClockRangeCommand|null|undefined} gpuClockRange
             * @memberof telemetry.v1.Command
             * @instance
             */
            Command.prototype.gpuClockRange = null;

            /**
             * Command gpuPowerCap.
             * @member {telemetry.module.gpu.v1.IPowerCapCommand|null|undefined} gpuPowerCap
             * @memberof telemetry.v1.Command
             * @instance
             */
            Command.prototype.gpuPowerCap = null;

            /**
             * Command processSignal.
             * @member {telemetry.module.process.v1.ISignalCommand|null|undefined} processSignal
             * @memberof telemetry.v1.Command
             * @instance
             */
            Command.prototype.processSignal = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * Command payload.
             * @member {"cpuScalingRange"|"cpuGovernor"|"cpuUncoreRange"|"cpuPowerCap"|"gpuClockRange"|"gpuPowerCap"|"processSignal"|undefined} payload
             * @memberof telemetry.v1.Command
             * @instance
             */
            Object.defineProperty(Command.prototype, "payload", {
                get: $util.oneOfGetter($oneOfFields = ["cpuScalingRange", "cpuGovernor", "cpuUncoreRange", "cpuPowerCap", "gpuClockRange", "gpuPowerCap", "processSignal"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new Command instance using the specified properties.
             * @function create
             * @memberof telemetry.v1.Command
             * @static
             * @param {telemetry.v1.ICommand=} [properties] Properties to set
             * @returns {telemetry.v1.Command} Command instance
             */
            Command.create = function create(properties) {
                return new Command(properties);
            };

            /**
             * Encodes the specified Command message. Does not implicitly {@link telemetry.v1.Command.verify|verify} messages.
             * @function encode
             * @memberof telemetry.v1.Command
             * @static
             * @param {telemetry.v1.ICommand} message Command message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Command.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                if (message.nodeId != null && Object.hasOwnProperty.call(message, "nodeId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.nodeId);
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.type);
                if (message.issuedAtUnixNano != null && Object.hasOwnProperty.call(message, "issuedAtUnixNano"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int64(message.issuedAtUnixNano);
                if (message.cpuScalingRange != null && Object.hasOwnProperty.call(message, "cpuScalingRange"))
                    $root.telemetry.module.cpu.v1.ScalingRangeCommand.encode(message.cpuScalingRange, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                if (message.cpuGovernor != null && Object.hasOwnProperty.call(message, "cpuGovernor"))
                    $root.telemetry.module.cpu.v1.GovernorCommand.encode(message.cpuGovernor, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                if (message.cpuUncoreRange != null && Object.hasOwnProperty.call(message, "cpuUncoreRange"))
                    $root.telemetry.module.cpu.v1.UncoreRangeCommand.encode(message.cpuUncoreRange, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
                if (message.cpuPowerCap != null && Object.hasOwnProperty.call(message, "cpuPowerCap"))
                    $root.telemetry.module.cpu.v1.PowerCapCommand.encode(message.cpuPowerCap, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
                if (message.gpuClockRange != null && Object.hasOwnProperty.call(message, "gpuClockRange"))
                    $root.telemetry.module.gpu.v1.ClockRangeCommand.encode(message.gpuClockRange, writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
                if (message.gpuPowerCap != null && Object.hasOwnProperty.call(message, "gpuPowerCap"))
                    $root.telemetry.module.gpu.v1.PowerCapCommand.encode(message.gpuPowerCap, writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
                if (message.processSignal != null && Object.hasOwnProperty.call(message, "processSignal"))
                    $root.telemetry.module.process.v1.SignalCommand.encode(message.processSignal, writer.uint32(/* id 16, wireType 2 =*/130).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Command message, length delimited. Does not implicitly {@link telemetry.v1.Command.verify|verify} messages.
             * @function encodeDelimited
             * @memberof telemetry.v1.Command
             * @static
             * @param {telemetry.v1.ICommand} message Command message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Command.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Command message from the specified reader or buffer.
             * @function decode
             * @memberof telemetry.v1.Command
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {telemetry.v1.Command} Command
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Command.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.telemetry.v1.Command();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.id = reader.string();
                            break;
                        }
                    case 2: {
                            message.nodeId = reader.string();
                            break;
                        }
                    case 3: {
                            message.type = reader.string();
                            break;
                        }
                    case 4: {
                            message.issuedAtUnixNano = reader.int64();
                            break;
                        }
                    case 10: {
                            message.cpuScalingRange = $root.telemetry.module.cpu.v1.ScalingRangeCommand.decode(reader, reader.uint32());
                            break;
                        }
                    case 11: {
                            message.cpuGovernor = $root.telemetry.module.cpu.v1.GovernorCommand.decode(reader, reader.uint32());
                            break;
                        }
                    case 12: {
                            message.cpuUncoreRange = $root.telemetry.module.cpu.v1.UncoreRangeCommand.decode(reader, reader.uint32());
                            break;
                        }
                    case 13: {
                            message.cpuPowerCap = $root.telemetry.module.cpu.v1.PowerCapCommand.decode(reader, reader.uint32());
                            break;
                        }
                    case 14: {
                            message.gpuClockRange = $root.telemetry.module.gpu.v1.ClockRangeCommand.decode(reader, reader.uint32());
                            break;
                        }
                    case 15: {
                            message.gpuPowerCap = $root.telemetry.module.gpu.v1.PowerCapCommand.decode(reader, reader.uint32());
                            break;
                        }
                    case 16: {
                            message.processSignal = $root.telemetry.module.process.v1.SignalCommand.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Command message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof telemetry.v1.Command
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {telemetry.v1.Command} Command
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Command.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Command message.
             * @function verify
             * @memberof telemetry.v1.Command
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Command.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isString(message.id))
                        return "id: string expected";
                if (message.nodeId != null && message.hasOwnProperty("nodeId"))
                    if (!$util.isString(message.nodeId))
                        return "nodeId: string expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    if (!$util.isString(message.type))
                        return "type: string expected";
                if (message.issuedAtUnixNano != null && message.hasOwnProperty("issuedAtUnixNano"))
                    if (!$util.isInteger(message.issuedAtUnixNano) && !(message.issuedAtUnixNano && $util.isInteger(message.issuedAtUnixNano.low) && $util.isInteger(message.issuedAtUnixNano.high)))
                        return "issuedAtUnixNano: integer|Long expected";
                if (message.cpuScalingRange != null && message.hasOwnProperty("cpuScalingRange")) {
                    properties.payload = 1;
                    {
                        let error = $root.telemetry.module.cpu.v1.ScalingRangeCommand.verify(message.cpuScalingRange);
                        if (error)
                            return "cpuScalingRange." + error;
                    }
                }
                if (message.cpuGovernor != null && message.hasOwnProperty("cpuGovernor")) {
                    if (properties.payload === 1)
                        return "payload: multiple values";
                    properties.payload = 1;
                    {
                        let error = $root.telemetry.module.cpu.v1.GovernorCommand.verify(message.cpuGovernor);
                        if (error)
                            return "cpuGovernor." + error;
                    }
                }
                if (message.cpuUncoreRange != null && message.hasOwnProperty("cpuUncoreRange")) {
                    if (properties.payload === 1)
                        return "payload: multiple values";
                    properties.payload = 1;
                    {
                        let error = $root.telemetry.module.cpu.v1.UncoreRangeCommand.verify(message.cpuUncoreRange);
                        if (error)
                            return "cpuUncoreRange." + error;
                    }
                }
                if (message.cpuPowerCap != null && message.hasOwnProperty("cpuPowerCap")) {
                    if (properties.payload === 1)
                        return "payload: multiple values";
                    properties.payload = 1;
                    {
                        let error = $root.telemetry.module.cpu.v1.PowerCapCommand.verify(message.cpuPowerCap);
                        if (error)
                            return "cpuPowerCap." + error;
                    }
                }
                if (message.gpuClockRange != null && message.hasOwnProperty("gpuClockRange")) {
                    if (properties.payload === 1)
                        return "payload: multiple values";
                    properties.payload = 1;
                    {
                        let error = $root.telemetry.module.gpu.v1.ClockRangeCommand.verify(message.gpuClockRange);
                        if (error)
                            return "gpuClockRange." + error;
                    }
                }
                if (message.gpuPowerCap != null && message.hasOwnProperty("gpuPowerCap")) {
                    if (properties.payload === 1)
                        return "payload: multiple values";
                    properties.payload = 1;
                    {
                        let error = $root.telemetry.module.gpu.v1.PowerCapCommand.verify(message.gpuPowerCap);
                        if (error)
                            return "gpuPowerCap." + error;
                    }
                }
                if (message.processSignal != null && message.hasOwnProperty("processSignal")) {
                    if (properties.payload === 1)
                        return "payload: multiple values";
                    properties.payload = 1;
                    {
                        let error = $root.telemetry.module.process.v1.SignalCommand.verify(message.processSignal);
                        if (error)
                            return "processSignal." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a Command message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof telemetry.v1.Command
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {telemetry.v1.Command} Command
             */
            Command.fromObject = function fromObject(object) {
                if (object instanceof $root.telemetry.v1.Command)
                    return object;
                let message = new $root.telemetry.v1.Command();
                if (object.id != null)
                    message.id = String(object.id);
                if (object.nodeId != null)
                    message.nodeId = String(object.nodeId);
                if (object.type != null)
                    message.type = String(object.type);
                if (object.issuedAtUnixNano != null)
                    if ($util.Long)
                        (message.issuedAtUnixNano = $util.Long.fromValue(object.issuedAtUnixNano)).unsigned = false;
                    else if (typeof object.issuedAtUnixNano === "string")
                        message.issuedAtUnixNano = parseInt(object.issuedAtUnixNano, 10);
                    else if (typeof object.issuedAtUnixNano === "number")
                        message.issuedAtUnixNano = object.issuedAtUnixNano;
                    else if (typeof object.issuedAtUnixNano === "object")
                        message.issuedAtUnixNano = new $util.LongBits(object.issuedAtUnixNano.low >>> 0, object.issuedAtUnixNano.high >>> 0).toNumber();
                if (object.cpuScalingRange != null) {
                    if (typeof object.cpuScalingRange !== "object")
                        throw TypeError(".telemetry.v1.Command.cpuScalingRange: object expected");
                    message.cpuScalingRange = $root.telemetry.module.cpu.v1.ScalingRangeCommand.fromObject(object.cpuScalingRange);
                }
                if (object.cpuGovernor != null) {
                    if (typeof object.cpuGovernor !== "object")
                        throw TypeError(".telemetry.v1.Command.cpuGovernor: object expected");
                    message.cpuGovernor = $root.telemetry.module.cpu.v1.GovernorCommand.fromObject(object.cpuGovernor);
                }
                if (object.cpuUncoreRange != null) {
                    if (typeof object.cpuUncoreRange !== "object")
                        throw TypeError(".telemetry.v1.Command.cpuUncoreRange: object expected");
                    message.cpuUncoreRange = $root.telemetry.module.cpu.v1.UncoreRangeCommand.fromObject(object.cpuUncoreRange);
                }
                if (object.cpuPowerCap != null) {
                    if (typeof object.cpuPowerCap !== "object")
                        throw TypeError(".telemetry.v1.Command.cpuPowerCap: object expected");
                    message.cpuPowerCap = $root.telemetry.module.cpu.v1.PowerCapCommand.fromObject(object.cpuPowerCap);
                }
                if (object.gpuClockRange != null) {
                    if (typeof object.gpuClockRange !== "object")
                        throw TypeError(".telemetry.v1.Command.gpuClockRange: object expected");
                    message.gpuClockRange = $root.telemetry.module.gpu.v1.ClockRangeCommand.fromObject(object.gpuClockRange);
                }
                if (object.gpuPowerCap != null) {
                    if (typeof object.gpuPowerCap !== "object")
                        throw TypeError(".telemetry.v1.Command.gpuPowerCap: object expected");
                    message.gpuPowerCap = $root.telemetry.module.gpu.v1.PowerCapCommand.fromObject(object.gpuPowerCap);
                }
                if (object.processSignal != null) {
                    if (typeof object.processSignal !== "object")
                        throw TypeError(".telemetry.v1.Command.processSignal: object expected");
                    message.processSignal = $root.telemetry.module.process.v1.SignalCommand.fromObject(object.processSignal);
                }
                return message;
            };

            /**
             * Creates a plain object from a Command message. Also converts values to other types if specified.
             * @function toObject
             * @memberof telemetry.v1.Command
             * @static
             * @param {telemetry.v1.Command} message Command
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Command.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.id = "";
                    object.nodeId = "";
                    object.type = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, false);
                        object.issuedAtUnixNano = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.issuedAtUnixNano = options.longs === String ? "0" : 0;
                }
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                if (message.nodeId != null && message.hasOwnProperty("nodeId"))
                    object.nodeId = message.nodeId;
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = message.type;
                if (message.issuedAtUnixNano != null && message.hasOwnProperty("issuedAtUnixNano"))
                    if (typeof message.issuedAtUnixNano === "number")
                        object.issuedAtUnixNano = options.longs === String ? String(message.issuedAtUnixNano) : message.issuedAtUnixNano;
                    else
                        object.issuedAtUnixNano = options.longs === String ? $util.Long.prototype.toString.call(message.issuedAtUnixNano) : options.longs === Number ? new $util.LongBits(message.issuedAtUnixNano.low >>> 0, message.issuedAtUnixNano.high >>> 0).toNumber() : message.issuedAtUnixNano;
                if (message.cpuScalingRange != null && message.hasOwnProperty("cpuScalingRange")) {
                    object.cpuScalingRange = $root.telemetry.module.cpu.v1.ScalingRangeCommand.toObject(message.cpuScalingRange, options);
                    if (options.oneofs)
                        object.payload = "cpuScalingRange";
                }
                if (message.cpuGovernor != null && message.hasOwnProperty("cpuGovernor")) {
                    object.cpuGovernor = $root.telemetry.module.cpu.v1.GovernorCommand.toObject(message.cpuGovernor, options);
                    if (options.oneofs)
                        object.payload = "cpuGovernor";
                }
                if (message.cpuUncoreRange != null && message.hasOwnProperty("cpuUncoreRange")) {
                    object.cpuUncoreRange = $root.telemetry.module.cpu.v1.UncoreRangeCommand.toObject(message.cpuUncoreRange, options);
                    if (options.oneofs)
                        object.payload = "cpuUncoreRange";
                }
                if (message.cpuPowerCap != null && message.hasOwnProperty("cpuPowerCap")) {
                    object.cpuPowerCap = $root.telemetry.module.cpu.v1.PowerCapCommand.toObject(message.cpuPowerCap, options);
                    if (options.oneofs)
                        object.payload = "cpuPowerCap";
                }
                if (message.gpuClockRange != null && message.hasOwnProperty("gpuClockRange")) {
                    object.gpuClockRange = $root.telemetry.module.gpu.v1.ClockRangeCommand.toObject(message.gpuClockRange, options);
                    if (options.oneofs)
                        object.payload = "gpuClockRange";
                }
                if (message.gpuPowerCap != null && message.hasOwnProperty("gpuPowerCap")) {
                    object.gpuPowerCap = $root.telemetry.module.gpu.v1.PowerCapCommand.toObject(message.gpuPowerCap, options);
                    if (options.oneofs)
                        object.payload = "gpuPowerCap";
                }
                if (message.processSignal != null && message.hasOwnProperty("processSignal")) {
                    object.processSignal = $root.telemetry.module.process.v1.SignalCommand.toObject(message.processSignal, options);
                    if (options.oneofs)
                        object.payload = "processSignal";
                }
                return object;
            };

            /**
             * Converts this Command to JSON.
             * @function toJSON
             * @memberof telemetry.v1.Command
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Command.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Command
             * @function getTypeUrl
             * @memberof telemetry.v1.Command
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Command.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/telemetry.v1.Command";
            };

            return Command;
        })();

        v1.CommandResult = (function() {

            /**
             * Properties of a CommandResult.
             * @memberof telemetry.v1
             * @interface ICommandResult
             * @property {string|null} [commandId] CommandResult commandId
             * @property {string|null} [nodeId] CommandResult nodeId
             * @property {string|null} [type] CommandResult type
             * @property {boolean|null} [success] CommandResult success
             * @property {string|null} [error] CommandResult error
             * @property {number|Long|null} [finishedAtUnixNano] CommandResult finishedAtUnixNano
             */

            /**
             * Constructs a new CommandResult.
             * @memberof telemetry.v1
             * @classdesc Represents a CommandResult.
             * @implements ICommandResult
             * @constructor
             * @param {telemetry.v1.ICommandResult=} [properties] Properties to set
             */
            function CommandResult(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CommandResult commandId.
             * @member {string} commandId
             * @memberof telemetry.v1.CommandResult
             * @instance
             */
            CommandResult.prototype.commandId = "";

            /**
             * CommandResult nodeId.
             * @member {string} nodeId
             * @memberof telemetry.v1.CommandResult
             * @instance
             */
            CommandResult.prototype.nodeId = "";

            /**
             * CommandResult type.
             * @member {string} type
             * @memberof telemetry.v1.CommandResult
             * @instance
             */
            CommandResult.prototype.type = "";

            /**
             * CommandResult success.
             * @member {boolean} success
             * @memberof telemetry.v1.CommandResult
             * @instance
             */
            CommandResult.prototype.success = false;

            /**
             * CommandResult error.
             * @member {string} error
             * @memberof telemetry.v1.CommandResult
             * @instance
             */
            CommandResult.prototype.error = "";

            /**
             * CommandResult finishedAtUnixNano.
             * @member {number|Long} finishedAtUnixNano
             * @memberof telemetry.v1.CommandResult
             * @instance
             */
            CommandResult.prototype.finishedAtUnixNano = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new CommandResult instance using the specified properties.
             * @function create
             * @memberof telemetry.v1.CommandResult
             * @static
             * @param {telemetry.v1.ICommandResult=} [properties] Properties to set
             * @returns {telemetry.v1.CommandResult} CommandResult instance
             */
            CommandResult.create = function create(properties) {
                return new CommandResult(properties);
            };

            /**
             * Encodes the specified CommandResult message. Does not implicitly {@link telemetry.v1.CommandResult.verify|verify} messages.
             * @function encode
             * @memberof telemetry.v1.CommandResult
             * @static
             * @param {telemetry.v1.ICommandResult} message CommandResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CommandResult.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.commandId != null && Object.hasOwnProperty.call(message, "commandId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.commandId);
                if (message.nodeId != null && Object.hasOwnProperty.call(message, "nodeId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.nodeId);
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.type);
                if (message.success != null && Object.hasOwnProperty.call(message, "success"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.success);
                if (message.error != null && Object.hasOwnProperty.call(message, "error"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.error);
                if (message.finishedAtUnixNano != null && Object.hasOwnProperty.call(message, "finishedAtUnixNano"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int64(message.finishedAtUnixNano);
                return writer;
            };

            /**
             * Encodes the specified CommandResult message, length delimited. Does not implicitly {@link telemetry.v1.CommandResult.verify|verify} messages.
             * @function encodeDelimited
             * @memberof telemetry.v1.CommandResult
             * @static
             * @param {telemetry.v1.ICommandResult} message CommandResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CommandResult.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CommandResult message from the specified reader or buffer.
             * @function decode
             * @memberof telemetry.v1.CommandResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {telemetry.v1.CommandResult} CommandResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CommandResult.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.telemetry.v1.CommandResult();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.commandId = reader.string();
                            break;
                        }
                    case 2: {
                            message.nodeId = reader.string();
                            break;
                        }
                    case 3: {
                            message.type = reader.string();
                            break;
                        }
                    case 4: {
                            message.success = reader.bool();
                            break;
                        }
                    case 5: {
                            message.error = reader.string();
                            break;
                        }
                    case 6: {
                            message.finishedAtUnixNano = reader.int64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CommandResult message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof telemetry.v1.CommandResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {telemetry.v1.CommandResult} CommandResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CommandResult.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CommandResult message.
             * @function verify
             * @memberof telemetry.v1.CommandResult
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CommandResult.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.commandId != null && message.hasOwnProperty("commandId"))
                    if (!$util.isString(message.commandId))
                        return "commandId: string expected";
                if (message.nodeId != null && message.hasOwnProperty("nodeId"))
                    if (!$util.isString(message.nodeId))
                        return "nodeId: string expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    if (!$util.isString(message.type))
                        return "type: string expected";
                if (message.success != null && message.hasOwnProperty("success"))
                    if (typeof message.success !== "boolean")
                        return "success: boolean expected";
                if (message.error != null && message.hasOwnProperty("error"))
                    if (!$util.isString(message.error))
                        return "error: string expected";
                if (message.finishedAtUnixNano != null && message.hasOwnProperty("finishedAtUnixNano"))
                    if (!$util.isInteger(message.finishedAtUnixNano) && !(message.finishedAtUnixNano && $util.isInteger(message.finishedAtUnixNano.low) && $util.isInteger(message.finishedAtUnixNano.high)))
                        return "finishedAtUnixNano: integer|Long expected";
                return null;
            };

            /**
             * Creates a CommandResult message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof telemetry.v1.CommandResult
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {telemetry.v1.CommandResult} CommandResult
             */
            CommandResult.fromObject = function fromObject(object) {
                if (object instanceof $root.telemetry.v1.CommandResult)
                    return object;
                let message = new $root.telemetry.v1.CommandResult();
                if (object.commandId != null)
                    message.commandId = String(object.commandId);
                if (object.nodeId != null)
                    message.nodeId = String(object.nodeId);
                if (object.type != null)
                    message.type = String(object.type);
                if (object.success != null)
                    message.success = Boolean(object.success);
                if (object.error != null)
                    message.error = String(object.error);
                if (object.finishedAtUnixNano != null)
                    if ($util.Long)
                        (message.finishedAtUnixNano = $util.Long.fromValue(object.finishedAtUnixNano)).unsigned = false;
                    else if (typeof object.finishedAtUnixNano === "string")
                        message.finishedAtUnixNano = parseInt(object.finishedAtUnixNano, 10);
                    else if (typeof object.finishedAtUnixNano === "number")
                        message.finishedAtUnixNano = object.finishedAtUnixNano;
                    else if (typeof object.finishedAtUnixNano === "object")
                        message.finishedAtUnixNano = new $util.LongBits(object.finishedAtUnixNano.low >>> 0, object.finishedAtUnixNano.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from a CommandResult message. Also converts values to other types if specified.
             * @function toObject
             * @memberof telemetry.v1.CommandResult
             * @static
             * @param {telemetry.v1.CommandResult} message CommandResult
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CommandResult.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.commandId = "";
                    object.nodeId = "";
                    object.type = "";
                    object.success = false;
                    object.error = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, false);
                        object.finishedAtUnixNano = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.finishedAtUnixNano = options.longs === String ? "0" : 0;
                }
                if (message.commandId != null && message.hasOwnProperty("commandId"))
                    object.commandId = message.commandId;
                if (message.nodeId != null && message.hasOwnProperty("nodeId"))
                    object.nodeId = message.nodeId;
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = message.type;
                if (message.success != null && message.hasOwnProperty("success"))
                    object.success = message.success;
                if (message.error != null && message.hasOwnProperty("error"))
                    object.error = message.error;
                if (message.finishedAtUnixNano != null && message.hasOwnProperty("finishedAtUnixNano"))
                    if (typeof message.finishedAtUnixNano === "number")
                        object.finishedAtUnixNano = options.longs === String ? String(message.finishedAtUnixNano) : message.finishedAtUnixNano;
                    else
                        object.finishedAtUnixNano = options.longs === String ? $util.Long.prototype.toString.call(message.finishedAtUnixNano) : options.longs === Number ? new $util.LongBits(message.finishedAtUnixNano.low >>> 0, message.finishedAtUnixNano.high >>> 0).toNumber() : message.finishedAtUnixNano;
                return object;
            };

            /**
             * Converts this CommandResult to JSON.
             * @function toJSON
             * @memberof telemetry.v1.CommandResult
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CommandResult.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for CommandResult
             * @function getTypeUrl
             * @memberof telemetry.v1.CommandResult
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            CommandResult.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/telemetry.v1.CommandResult";
            };

            return CommandResult;
        })();

        v1.ServerAck = (function() {

            /**
             * Properties of a ServerAck.
             * @memberof telemetry.v1
             * @interface IServerAck
             * @property {string|null} [nodeId] ServerAck nodeId
             * @property {number|Long|null} [atUnixNano] ServerAck atUnixNano
             */

            /**
             * Constructs a new ServerAck.
             * @memberof telemetry.v1
             * @classdesc Represents a ServerAck.
             * @implements IServerAck
             * @constructor
             * @param {telemetry.v1.IServerAck=} [properties] Properties to set
             */
            function ServerAck(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ServerAck nodeId.
             * @member {string} nodeId
             * @memberof telemetry.v1.ServerAck
             * @instance
             */
            ServerAck.prototype.nodeId = "";

            /**
             * ServerAck atUnixNano.
             * @member {number|Long} atUnixNano
             * @memberof telemetry.v1.ServerAck
             * @instance
             */
            ServerAck.prototype.atUnixNano = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new ServerAck instance using the specified properties.
             * @function create
             * @memberof telemetry.v1.ServerAck
             * @static
             * @param {telemetry.v1.IServerAck=} [properties] Properties to set
             * @returns {telemetry.v1.ServerAck} ServerAck instance
             */
            ServerAck.create = function create(properties) {
                return new ServerAck(properties);
            };

            /**
             * Encodes the specified ServerAck message. Does not implicitly {@link telemetry.v1.ServerAck.verify|verify} messages.
             * @function encode
             * @memberof telemetry.v1.ServerAck
             * @static
             * @param {telemetry.v1.IServerAck} message ServerAck message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ServerAck.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.nodeId != null && Object.hasOwnProperty.call(message, "nodeId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.nodeId);
                if (message.atUnixNano != null && Object.hasOwnProperty.call(message, "atUnixNano"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.atUnixNano);
                return writer;
            };

            /**
             * Encodes the specified ServerAck message, length delimited. Does not implicitly {@link telemetry.v1.ServerAck.verify|verify} messages.
             * @function encodeDelimited
             * @memberof telemetry.v1.ServerAck
             * @static
             * @param {telemetry.v1.IServerAck} message ServerAck message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ServerAck.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ServerAck message from the specified reader or buffer.
             * @function decode
             * @memberof telemetry.v1.ServerAck
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {telemetry.v1.ServerAck} ServerAck
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ServerAck.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.telemetry.v1.ServerAck();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.nodeId = reader.string();
                            break;
                        }
                    case 2: {
                            message.atUnixNano = reader.int64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ServerAck message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof telemetry.v1.ServerAck
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {telemetry.v1.ServerAck} ServerAck
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ServerAck.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ServerAck message.
             * @function verify
             * @memberof telemetry.v1.ServerAck
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ServerAck.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.nodeId != null && message.hasOwnProperty("nodeId"))
                    if (!$util.isString(message.nodeId))
                        return "nodeId: string expected";
                if (message.atUnixNano != null && message.hasOwnProperty("atUnixNano"))
                    if (!$util.isInteger(message.atUnixNano) && !(message.atUnixNano && $util.isInteger(message.atUnixNano.low) && $util.isInteger(message.atUnixNano.high)))
                        return "atUnixNano: integer|Long expected";
                return null;
            };

            /**
             * Creates a ServerAck message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof telemetry.v1.ServerAck
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {telemetry.v1.ServerAck} ServerAck
             */
            ServerAck.fromObject = function fromObject(object) {
                if (object instanceof $root.telemetry.v1.ServerAck)
                    return object;
                let message = new $root.telemetry.v1.ServerAck();
                if (object.nodeId != null)
                    message.nodeId = String(object.nodeId);
                if (object.atUnixNano != null)
                    if ($util.Long)
                        (message.atUnixNano = $util.Long.fromValue(object.atUnixNano)).unsigned = false;
                    else if (typeof object.atUnixNano === "string")
                        message.atUnixNano = parseInt(object.atUnixNano, 10);
                    else if (typeof object.atUnixNano === "number")
                        message.atUnixNano = object.atUnixNano;
                    else if (typeof object.atUnixNano === "object")
                        message.atUnixNano = new $util.LongBits(object.atUnixNano.low >>> 0, object.atUnixNano.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from a ServerAck message. Also converts values to other types if specified.
             * @function toObject
             * @memberof telemetry.v1.ServerAck
             * @static
             * @param {telemetry.v1.ServerAck} message ServerAck
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ServerAck.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.nodeId = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, false);
                        object.atUnixNano = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.atUnixNano = options.longs === String ? "0" : 0;
                }
                if (message.nodeId != null && message.hasOwnProperty("nodeId"))
                    object.nodeId = message.nodeId;
                if (message.atUnixNano != null && message.hasOwnProperty("atUnixNano"))
                    if (typeof message.atUnixNano === "number")
                        object.atUnixNano = options.longs === String ? String(message.atUnixNano) : message.atUnixNano;
                    else
                        object.atUnixNano = options.longs === String ? $util.Long.prototype.toString.call(message.atUnixNano) : options.longs === Number ? new $util.LongBits(message.atUnixNano.low >>> 0, message.atUnixNano.high >>> 0).toNumber() : message.atUnixNano;
                return object;
            };

            /**
             * Converts this ServerAck to JSON.
             * @function toJSON
             * @memberof telemetry.v1.ServerAck
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ServerAck.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ServerAck
             * @function getTypeUrl
             * @memberof telemetry.v1.ServerAck
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ServerAck.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/telemetry.v1.ServerAck";
            };

            return ServerAck;
        })();

        v1.AgentMessage = (function() {

            /**
             * Properties of an AgentMessage.
             * @memberof telemetry.v1
             * @interface IAgentMessage
             * @property {string|null} [kind] AgentMessage kind
             * @property {telemetry.v1.IRegistration|null} [registration] AgentMessage registration
             * @property {telemetry.v1.IMetricsBatch|null} [metrics] AgentMessage metrics
             * @property {telemetry.v1.ICommandResult|null} [result] AgentMessage result
             * @property {telemetry.v1.IHeartbeat|null} [heartbeat] AgentMessage heartbeat
             */

            /**
             * Constructs a new AgentMessage.
             * @memberof telemetry.v1
             * @classdesc Represents an AgentMessage.
             * @implements IAgentMessage
             * @constructor
             * @param {telemetry.v1.IAgentMessage=} [properties] Properties to set
             */
            function AgentMessage(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AgentMessage kind.
             * @member {string} kind
             * @memberof telemetry.v1.AgentMessage
             * @instance
             */
            AgentMessage.prototype.kind = "";

            /**
             * AgentMessage registration.
             * @member {telemetry.v1.IRegistration|null|undefined} registration
             * @memberof telemetry.v1.AgentMessage
             * @instance
             */
            AgentMessage.prototype.registration = null;

            /**
             * AgentMessage metrics.
             * @member {telemetry.v1.IMetricsBatch|null|undefined} metrics
             * @memberof telemetry.v1.AgentMessage
             * @instance
             */
            AgentMessage.prototype.metrics = null;

            /**
             * AgentMessage result.
             * @member {telemetry.v1.ICommandResult|null|undefined} result
             * @memberof telemetry.v1.AgentMessage
             * @instance
             */
            AgentMessage.prototype.result = null;

            /**
             * AgentMessage heartbeat.
             * @member {telemetry.v1.IHeartbeat|null|undefined} heartbeat
             * @memberof telemetry.v1.AgentMessage
             * @instance
             */
            AgentMessage.prototype.heartbeat = null;

            /**
             * Creates a new AgentMessage instance using the specified properties.
             * @function create
             * @memberof telemetry.v1.AgentMessage
             * @static
             * @param {telemetry.v1.IAgentMessage=} [properties] Properties to set
             * @returns {telemetry.v1.AgentMessage} AgentMessage instance
             */
            AgentMessage.create = function create(properties) {
                return new AgentMessage(properties);
            };

            /**
             * Encodes the specified AgentMessage message. Does not implicitly {@link telemetry.v1.AgentMessage.verify|verify} messages.
             * @function encode
             * @memberof telemetry.v1.AgentMessage
             * @static
             * @param {telemetry.v1.IAgentMessage} message AgentMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AgentMessage.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.kind != null && Object.hasOwnProperty.call(message, "kind"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.kind);
                if (message.registration != null && Object.hasOwnProperty.call(message, "registration"))
                    $root.telemetry.v1.Registration.encode(message.registration, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.metrics != null && Object.hasOwnProperty.call(message, "metrics"))
                    $root.telemetry.v1.MetricsBatch.encode(message.metrics, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.result != null && Object.hasOwnProperty.call(message, "result"))
                    $root.telemetry.v1.CommandResult.encode(message.result, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.heartbeat != null && Object.hasOwnProperty.call(message, "heartbeat"))
                    $root.telemetry.v1.Heartbeat.encode(message.heartbeat, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified AgentMessage message, length delimited. Does not implicitly {@link telemetry.v1.AgentMessage.verify|verify} messages.
             * @function encodeDelimited
             * @memberof telemetry.v1.AgentMessage
             * @static
             * @param {telemetry.v1.IAgentMessage} message AgentMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AgentMessage.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AgentMessage message from the specified reader or buffer.
             * @function decode
             * @memberof telemetry.v1.AgentMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {telemetry.v1.AgentMessage} AgentMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AgentMessage.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.telemetry.v1.AgentMessage();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.kind = reader.string();
                            break;
                        }
                    case 2: {
                            message.registration = $root.telemetry.v1.Registration.decode(reader, reader.uint32());
                            break;
                        }
                    case 3: {
                            message.metrics = $root.telemetry.v1.MetricsBatch.decode(reader, reader.uint32());
                            break;
                        }
                    case 4: {
                            message.result = $root.telemetry.v1.CommandResult.decode(reader, reader.uint32());
                            break;
                        }
                    case 5: {
                            message.heartbeat = $root.telemetry.v1.Heartbeat.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AgentMessage message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof telemetry.v1.AgentMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {telemetry.v1.AgentMessage} AgentMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AgentMessage.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AgentMessage message.
             * @function verify
             * @memberof telemetry.v1.AgentMessage
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AgentMessage.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.kind != null && message.hasOwnProperty("kind"))
                    if (!$util.isString(message.kind))
                        return "kind: string expected";
                if (message.registration != null && message.hasOwnProperty("registration")) {
                    let error = $root.telemetry.v1.Registration.verify(message.registration);
                    if (error)
                        return "registration." + error;
                }
                if (message.metrics != null && message.hasOwnProperty("metrics")) {
                    let error = $root.telemetry.v1.MetricsBatch.verify(message.metrics);
                    if (error)
                        return "metrics." + error;
                }
                if (message.result != null && message.hasOwnProperty("result")) {
                    let error = $root.telemetry.v1.CommandResult.verify(message.result);
                    if (error)
                        return "result." + error;
                }
                if (message.heartbeat != null && message.hasOwnProperty("heartbeat")) {
                    let error = $root.telemetry.v1.Heartbeat.verify(message.heartbeat);
                    if (error)
                        return "heartbeat." + error;
                }
                return null;
            };

            /**
             * Creates an AgentMessage message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof telemetry.v1.AgentMessage
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {telemetry.v1.AgentMessage} AgentMessage
             */
            AgentMessage.fromObject = function fromObject(object) {
                if (object instanceof $root.telemetry.v1.AgentMessage)
                    return object;
                let message = new $root.telemetry.v1.AgentMessage();
                if (object.kind != null)
                    message.kind = String(object.kind);
                if (object.registration != null) {
                    if (typeof object.registration !== "object")
                        throw TypeError(".telemetry.v1.AgentMessage.registration: object expected");
                    message.registration = $root.telemetry.v1.Registration.fromObject(object.registration);
                }
                if (object.metrics != null) {
                    if (typeof object.metrics !== "object")
                        throw TypeError(".telemetry.v1.AgentMessage.metrics: object expected");
                    message.metrics = $root.telemetry.v1.MetricsBatch.fromObject(object.metrics);
                }
                if (object.result != null) {
                    if (typeof object.result !== "object")
                        throw TypeError(".telemetry.v1.AgentMessage.result: object expected");
                    message.result = $root.telemetry.v1.CommandResult.fromObject(object.result);
                }
                if (object.heartbeat != null) {
                    if (typeof object.heartbeat !== "object")
                        throw TypeError(".telemetry.v1.AgentMessage.heartbeat: object expected");
                    message.heartbeat = $root.telemetry.v1.Heartbeat.fromObject(object.heartbeat);
                }
                return message;
            };

            /**
             * Creates a plain object from an AgentMessage message. Also converts values to other types if specified.
             * @function toObject
             * @memberof telemetry.v1.AgentMessage
             * @static
             * @param {telemetry.v1.AgentMessage} message AgentMessage
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AgentMessage.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.kind = "";
                    object.registration = null;
                    object.metrics = null;
                    object.result = null;
                    object.heartbeat = null;
                }
                if (message.kind != null && message.hasOwnProperty("kind"))
                    object.kind = message.kind;
                if (message.registration != null && message.hasOwnProperty("registration"))
                    object.registration = $root.telemetry.v1.Registration.toObject(message.registration, options);
                if (message.metrics != null && message.hasOwnProperty("metrics"))
                    object.metrics = $root.telemetry.v1.MetricsBatch.toObject(message.metrics, options);
                if (message.result != null && message.hasOwnProperty("result"))
                    object.result = $root.telemetry.v1.CommandResult.toObject(message.result, options);
                if (message.heartbeat != null && message.hasOwnProperty("heartbeat"))
                    object.heartbeat = $root.telemetry.v1.Heartbeat.toObject(message.heartbeat, options);
                return object;
            };

            /**
             * Converts this AgentMessage to JSON.
             * @function toJSON
             * @memberof telemetry.v1.AgentMessage
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AgentMessage.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for AgentMessage
             * @function getTypeUrl
             * @memberof telemetry.v1.AgentMessage
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            AgentMessage.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/telemetry.v1.AgentMessage";
            };

            return AgentMessage;
        })();

        v1.ServerMessage = (function() {

            /**
             * Properties of a ServerMessage.
             * @memberof telemetry.v1
             * @interface IServerMessage
             * @property {string|null} [kind] ServerMessage kind
             * @property {telemetry.v1.ICommand|null} [command] ServerMessage command
             * @property {telemetry.v1.IServerAck|null} [ack] ServerMessage ack
             */

            /**
             * Constructs a new ServerMessage.
             * @memberof telemetry.v1
             * @classdesc Represents a ServerMessage.
             * @implements IServerMessage
             * @constructor
             * @param {telemetry.v1.IServerMessage=} [properties] Properties to set
             */
            function ServerMessage(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ServerMessage kind.
             * @member {string} kind
             * @memberof telemetry.v1.ServerMessage
             * @instance
             */
            ServerMessage.prototype.kind = "";

            /**
             * ServerMessage command.
             * @member {telemetry.v1.ICommand|null|undefined} command
             * @memberof telemetry.v1.ServerMessage
             * @instance
             */
            ServerMessage.prototype.command = null;

            /**
             * ServerMessage ack.
             * @member {telemetry.v1.IServerAck|null|undefined} ack
             * @memberof telemetry.v1.ServerMessage
             * @instance
             */
            ServerMessage.prototype.ack = null;

            /**
             * Creates a new ServerMessage instance using the specified properties.
             * @function create
             * @memberof telemetry.v1.ServerMessage
             * @static
             * @param {telemetry.v1.IServerMessage=} [properties] Properties to set
             * @returns {telemetry.v1.ServerMessage} ServerMessage instance
             */
            ServerMessage.create = function create(properties) {
                return new ServerMessage(properties);
            };

            /**
             * Encodes the specified ServerMessage message. Does not implicitly {@link telemetry.v1.ServerMessage.verify|verify} messages.
             * @function encode
             * @memberof telemetry.v1.ServerMessage
             * @static
             * @param {telemetry.v1.IServerMessage} message ServerMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ServerMessage.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.kind != null && Object.hasOwnProperty.call(message, "kind"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.kind);
                if (message.command != null && Object.hasOwnProperty.call(message, "command"))
                    $root.telemetry.v1.Command.encode(message.command, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.ack != null && Object.hasOwnProperty.call(message, "ack"))
                    $root.telemetry.v1.ServerAck.encode(message.ack, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ServerMessage message, length delimited. Does not implicitly {@link telemetry.v1.ServerMessage.verify|verify} messages.
             * @function encodeDelimited
             * @memberof telemetry.v1.ServerMessage
             * @static
             * @param {telemetry.v1.IServerMessage} message ServerMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ServerMessage.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ServerMessage message from the specified reader or buffer.
             * @function decode
             * @memberof telemetry.v1.ServerMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {telemetry.v1.ServerMessage} ServerMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ServerMessage.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.telemetry.v1.ServerMessage();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.kind = reader.string();
                            break;
                        }
                    case 2: {
                            message.command = $root.telemetry.v1.Command.decode(reader, reader.uint32());
                            break;
                        }
                    case 3: {
                            message.ack = $root.telemetry.v1.ServerAck.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ServerMessage message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof telemetry.v1.ServerMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {telemetry.v1.ServerMessage} ServerMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ServerMessage.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ServerMessage message.
             * @function verify
             * @memberof telemetry.v1.ServerMessage
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ServerMessage.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.kind != null && message.hasOwnProperty("kind"))
                    if (!$util.isString(message.kind))
                        return "kind: string expected";
                if (message.command != null && message.hasOwnProperty("command")) {
                    let error = $root.telemetry.v1.Command.verify(message.command);
                    if (error)
                        return "command." + error;
                }
                if (message.ack != null && message.hasOwnProperty("ack")) {
                    let error = $root.telemetry.v1.ServerAck.verify(message.ack);
                    if (error)
                        return "ack." + error;
                }
                return null;
            };

            /**
             * Creates a ServerMessage message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof telemetry.v1.ServerMessage
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {telemetry.v1.ServerMessage} ServerMessage
             */
            ServerMessage.fromObject = function fromObject(object) {
                if (object instanceof $root.telemetry.v1.ServerMessage)
                    return object;
                let message = new $root.telemetry.v1.ServerMessage();
                if (object.kind != null)
                    message.kind = String(object.kind);
                if (object.command != null) {
                    if (typeof object.command !== "object")
                        throw TypeError(".telemetry.v1.ServerMessage.command: object expected");
                    message.command = $root.telemetry.v1.Command.fromObject(object.command);
                }
                if (object.ack != null) {
                    if (typeof object.ack !== "object")
                        throw TypeError(".telemetry.v1.ServerMessage.ack: object expected");
                    message.ack = $root.telemetry.v1.ServerAck.fromObject(object.ack);
                }
                return message;
            };

            /**
             * Creates a plain object from a ServerMessage message. Also converts values to other types if specified.
             * @function toObject
             * @memberof telemetry.v1.ServerMessage
             * @static
             * @param {telemetry.v1.ServerMessage} message ServerMessage
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ServerMessage.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.kind = "";
                    object.command = null;
                    object.ack = null;
                }
                if (message.kind != null && message.hasOwnProperty("kind"))
                    object.kind = message.kind;
                if (message.command != null && message.hasOwnProperty("command"))
                    object.command = $root.telemetry.v1.Command.toObject(message.command, options);
                if (message.ack != null && message.hasOwnProperty("ack"))
                    object.ack = $root.telemetry.v1.ServerAck.toObject(message.ack, options);
                return object;
            };

            /**
             * Converts this ServerMessage to JSON.
             * @function toJSON
             * @memberof telemetry.v1.ServerMessage
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ServerMessage.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ServerMessage
             * @function getTypeUrl
             * @memberof telemetry.v1.ServerMessage
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ServerMessage.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/telemetry.v1.ServerMessage";
            };

            return ServerMessage;
        })();

        v1.TelemetryService = (function() {

            /**
             * Constructs a new TelemetryService service.
             * @memberof telemetry.v1
             * @classdesc Represents a TelemetryService
             * @extends $protobuf.rpc.Service
             * @constructor
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             */
            function TelemetryService(rpcImpl, requestDelimited, responseDelimited) {
                $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
            }

            (TelemetryService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = TelemetryService;

            /**
             * Creates new TelemetryService service using the specified rpc implementation.
             * @function create
             * @memberof telemetry.v1.TelemetryService
             * @static
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             * @returns {TelemetryService} RPC service. Useful where requests and/or responses are streamed.
             */
            TelemetryService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                return new this(rpcImpl, requestDelimited, responseDelimited);
            };

            /**
             * Callback as used by {@link telemetry.v1.TelemetryService#streamTelemetry}.
             * @memberof telemetry.v1.TelemetryService
             * @typedef StreamTelemetryCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {telemetry.v1.ServerMessage} [response] ServerMessage
             */

            /**
             * Calls StreamTelemetry.
             * @function streamTelemetry
             * @memberof telemetry.v1.TelemetryService
             * @instance
             * @param {telemetry.v1.IAgentMessage} request AgentMessage message or plain object
             * @param {telemetry.v1.TelemetryService.StreamTelemetryCallback} callback Node-style callback called with the error, if any, and ServerMessage
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(TelemetryService.prototype.streamTelemetry = function streamTelemetry(request, callback) {
                return this.rpcCall(streamTelemetry, $root.telemetry.v1.AgentMessage, $root.telemetry.v1.ServerMessage, request, callback);
            }, "name", { value: "StreamTelemetry" });

            /**
             * Calls StreamTelemetry.
             * @function streamTelemetry
             * @memberof telemetry.v1.TelemetryService
             * @instance
             * @param {telemetry.v1.IAgentMessage} request AgentMessage message or plain object
             * @returns {Promise<telemetry.v1.ServerMessage>} Promise
             * @variation 2
             */

            return TelemetryService;
        })();

        return v1;
    })();

    telemetry.module = (function() {

        /**
         * Namespace module.
         * @memberof telemetry
         * @namespace
         */
        const module = {};

        module.cpu = (function() {

            /**
             * Namespace cpu.
             * @memberof telemetry.module
             * @namespace
             */
            const cpu = {};

            cpu.v1 = (function() {

                /**
                 * Namespace v1.
                 * @memberof telemetry.module.cpu
                 * @namespace
                 */
                const v1 = {};

                v1.CollectorSpec = (function() {

                    /**
                     * Properties of a CollectorSpec.
                     * @memberof telemetry.module.cpu.v1
                     * @interface ICollectorSpec
                     * @property {string|null} [category] CollectorSpec category
                     * @property {string|null} [interval] CollectorSpec interval
                     */

                    /**
                     * Constructs a new CollectorSpec.
                     * @memberof telemetry.module.cpu.v1
                     * @classdesc Represents a CollectorSpec.
                     * @implements ICollectorSpec
                     * @constructor
                     * @param {telemetry.module.cpu.v1.ICollectorSpec=} [properties] Properties to set
                     */
                    function CollectorSpec(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * CollectorSpec category.
                     * @member {string} category
                     * @memberof telemetry.module.cpu.v1.CollectorSpec
                     * @instance
                     */
                    CollectorSpec.prototype.category = "";

                    /**
                     * CollectorSpec interval.
                     * @member {string} interval
                     * @memberof telemetry.module.cpu.v1.CollectorSpec
                     * @instance
                     */
                    CollectorSpec.prototype.interval = "";

                    /**
                     * Creates a new CollectorSpec instance using the specified properties.
                     * @function create
                     * @memberof telemetry.module.cpu.v1.CollectorSpec
                     * @static
                     * @param {telemetry.module.cpu.v1.ICollectorSpec=} [properties] Properties to set
                     * @returns {telemetry.module.cpu.v1.CollectorSpec} CollectorSpec instance
                     */
                    CollectorSpec.create = function create(properties) {
                        return new CollectorSpec(properties);
                    };

                    /**
                     * Encodes the specified CollectorSpec message. Does not implicitly {@link telemetry.module.cpu.v1.CollectorSpec.verify|verify} messages.
                     * @function encode
                     * @memberof telemetry.module.cpu.v1.CollectorSpec
                     * @static
                     * @param {telemetry.module.cpu.v1.ICollectorSpec} message CollectorSpec message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    CollectorSpec.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.category != null && Object.hasOwnProperty.call(message, "category"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.category);
                        if (message.interval != null && Object.hasOwnProperty.call(message, "interval"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.interval);
                        return writer;
                    };

                    /**
                     * Encodes the specified CollectorSpec message, length delimited. Does not implicitly {@link telemetry.module.cpu.v1.CollectorSpec.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof telemetry.module.cpu.v1.CollectorSpec
                     * @static
                     * @param {telemetry.module.cpu.v1.ICollectorSpec} message CollectorSpec message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    CollectorSpec.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a CollectorSpec message from the specified reader or buffer.
                     * @function decode
                     * @memberof telemetry.module.cpu.v1.CollectorSpec
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {telemetry.module.cpu.v1.CollectorSpec} CollectorSpec
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    CollectorSpec.decode = function decode(reader, length, error) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.telemetry.module.cpu.v1.CollectorSpec();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            if (tag === error)
                                break;
                            switch (tag >>> 3) {
                            case 1: {
                                    message.category = reader.string();
                                    break;
                                }
                            case 2: {
                                    message.interval = reader.string();
                                    break;
                                }
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a CollectorSpec message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof telemetry.module.cpu.v1.CollectorSpec
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {telemetry.module.cpu.v1.CollectorSpec} CollectorSpec
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    CollectorSpec.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a CollectorSpec message.
                     * @function verify
                     * @memberof telemetry.module.cpu.v1.CollectorSpec
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    CollectorSpec.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.category != null && message.hasOwnProperty("category"))
                            if (!$util.isString(message.category))
                                return "category: string expected";
                        if (message.interval != null && message.hasOwnProperty("interval"))
                            if (!$util.isString(message.interval))
                                return "interval: string expected";
                        return null;
                    };

                    /**
                     * Creates a CollectorSpec message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof telemetry.module.cpu.v1.CollectorSpec
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {telemetry.module.cpu.v1.CollectorSpec} CollectorSpec
                     */
                    CollectorSpec.fromObject = function fromObject(object) {
                        if (object instanceof $root.telemetry.module.cpu.v1.CollectorSpec)
                            return object;
                        let message = new $root.telemetry.module.cpu.v1.CollectorSpec();
                        if (object.category != null)
                            message.category = String(object.category);
                        if (object.interval != null)
                            message.interval = String(object.interval);
                        return message;
                    };

                    /**
                     * Creates a plain object from a CollectorSpec message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof telemetry.module.cpu.v1.CollectorSpec
                     * @static
                     * @param {telemetry.module.cpu.v1.CollectorSpec} message CollectorSpec
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    CollectorSpec.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.category = "";
                            object.interval = "";
                        }
                        if (message.category != null && message.hasOwnProperty("category"))
                            object.category = message.category;
                        if (message.interval != null && message.hasOwnProperty("interval"))
                            object.interval = message.interval;
                        return object;
                    };

                    /**
                     * Converts this CollectorSpec to JSON.
                     * @function toJSON
                     * @memberof telemetry.module.cpu.v1.CollectorSpec
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    CollectorSpec.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Gets the default type url for CollectorSpec
                     * @function getTypeUrl
                     * @memberof telemetry.module.cpu.v1.CollectorSpec
                     * @static
                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                     * @returns {string} The default type url
                     */
                    CollectorSpec.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                        if (typeUrlPrefix === undefined) {
                            typeUrlPrefix = "type.googleapis.com";
                        }
                        return typeUrlPrefix + "/telemetry.module.cpu.v1.CollectorSpec";
                    };

                    return CollectorSpec;
                })();

                v1.ControllerSpec = (function() {

                    /**
                     * Properties of a ControllerSpec.
                     * @memberof telemetry.module.cpu.v1
                     * @interface IControllerSpec
                     * @property {string|null} [type] ControllerSpec type
                     */

                    /**
                     * Constructs a new ControllerSpec.
                     * @memberof telemetry.module.cpu.v1
                     * @classdesc Represents a ControllerSpec.
                     * @implements IControllerSpec
                     * @constructor
                     * @param {telemetry.module.cpu.v1.IControllerSpec=} [properties] Properties to set
                     */
                    function ControllerSpec(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * ControllerSpec type.
                     * @member {string} type
                     * @memberof telemetry.module.cpu.v1.ControllerSpec
                     * @instance
                     */
                    ControllerSpec.prototype.type = "";

                    /**
                     * Creates a new ControllerSpec instance using the specified properties.
                     * @function create
                     * @memberof telemetry.module.cpu.v1.ControllerSpec
                     * @static
                     * @param {telemetry.module.cpu.v1.IControllerSpec=} [properties] Properties to set
                     * @returns {telemetry.module.cpu.v1.ControllerSpec} ControllerSpec instance
                     */
                    ControllerSpec.create = function create(properties) {
                        return new ControllerSpec(properties);
                    };

                    /**
                     * Encodes the specified ControllerSpec message. Does not implicitly {@link telemetry.module.cpu.v1.ControllerSpec.verify|verify} messages.
                     * @function encode
                     * @memberof telemetry.module.cpu.v1.ControllerSpec
                     * @static
                     * @param {telemetry.module.cpu.v1.IControllerSpec} message ControllerSpec message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ControllerSpec.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.type);
                        return writer;
                    };

                    /**
                     * Encodes the specified ControllerSpec message, length delimited. Does not implicitly {@link telemetry.module.cpu.v1.ControllerSpec.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof telemetry.module.cpu.v1.ControllerSpec
                     * @static
                     * @param {telemetry.module.cpu.v1.IControllerSpec} message ControllerSpec message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ControllerSpec.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a ControllerSpec message from the specified reader or buffer.
                     * @function decode
                     * @memberof telemetry.module.cpu.v1.ControllerSpec
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {telemetry.module.cpu.v1.ControllerSpec} ControllerSpec
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ControllerSpec.decode = function decode(reader, length, error) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.telemetry.module.cpu.v1.ControllerSpec();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            if (tag === error)
                                break;
                            switch (tag >>> 3) {
                            case 1: {
                                    message.type = reader.string();
                                    break;
                                }
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a ControllerSpec message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof telemetry.module.cpu.v1.ControllerSpec
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {telemetry.module.cpu.v1.ControllerSpec} ControllerSpec
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ControllerSpec.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a ControllerSpec message.
                     * @function verify
                     * @memberof telemetry.module.cpu.v1.ControllerSpec
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    ControllerSpec.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.type != null && message.hasOwnProperty("type"))
                            if (!$util.isString(message.type))
                                return "type: string expected";
                        return null;
                    };

                    /**
                     * Creates a ControllerSpec message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof telemetry.module.cpu.v1.ControllerSpec
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {telemetry.module.cpu.v1.ControllerSpec} ControllerSpec
                     */
                    ControllerSpec.fromObject = function fromObject(object) {
                        if (object instanceof $root.telemetry.module.cpu.v1.ControllerSpec)
                            return object;
                        let message = new $root.telemetry.module.cpu.v1.ControllerSpec();
                        if (object.type != null)
                            message.type = String(object.type);
                        return message;
                    };

                    /**
                     * Creates a plain object from a ControllerSpec message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof telemetry.module.cpu.v1.ControllerSpec
                     * @static
                     * @param {telemetry.module.cpu.v1.ControllerSpec} message ControllerSpec
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    ControllerSpec.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults)
                            object.type = "";
                        if (message.type != null && message.hasOwnProperty("type"))
                            object.type = message.type;
                        return object;
                    };

                    /**
                     * Converts this ControllerSpec to JSON.
                     * @function toJSON
                     * @memberof telemetry.module.cpu.v1.ControllerSpec
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    ControllerSpec.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Gets the default type url for ControllerSpec
                     * @function getTypeUrl
                     * @memberof telemetry.module.cpu.v1.ControllerSpec
                     * @static
                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                     * @returns {string} The default type url
                     */
                    ControllerSpec.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                        if (typeUrlPrefix === undefined) {
                            typeUrlPrefix = "type.googleapis.com";
                        }
                        return typeUrlPrefix + "/telemetry.module.cpu.v1.ControllerSpec";
                    };

                    return ControllerSpec;
                })();

                v1.CpuDevice = (function() {

                    /**
                     * Properties of a CpuDevice.
                     * @memberof telemetry.module.cpu.v1
                     * @interface ICpuDevice
                     * @property {number|null} [packageId] CpuDevice packageId
                     * @property {Array.<number>|null} [coreIds] CpuDevice coreIds
                     * @property {number|null} [coreCount] CpuDevice coreCount
                     * @property {number|null} [threadCount] CpuDevice threadCount
                     * @property {string|null} [vendor] CpuDevice vendor
                     * @property {string|null} [model] CpuDevice model
                     */

                    /**
                     * Constructs a new CpuDevice.
                     * @memberof telemetry.module.cpu.v1
                     * @classdesc Represents a CpuDevice.
                     * @implements ICpuDevice
                     * @constructor
                     * @param {telemetry.module.cpu.v1.ICpuDevice=} [properties] Properties to set
                     */
                    function CpuDevice(properties) {
                        this.coreIds = [];
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * CpuDevice packageId.
                     * @member {number} packageId
                     * @memberof telemetry.module.cpu.v1.CpuDevice
                     * @instance
                     */
                    CpuDevice.prototype.packageId = 0;

                    /**
                     * CpuDevice coreIds.
                     * @member {Array.<number>} coreIds
                     * @memberof telemetry.module.cpu.v1.CpuDevice
                     * @instance
                     */
                    CpuDevice.prototype.coreIds = $util.emptyArray;

                    /**
                     * CpuDevice coreCount.
                     * @member {number} coreCount
                     * @memberof telemetry.module.cpu.v1.CpuDevice
                     * @instance
                     */
                    CpuDevice.prototype.coreCount = 0;

                    /**
                     * CpuDevice threadCount.
                     * @member {number} threadCount
                     * @memberof telemetry.module.cpu.v1.CpuDevice
                     * @instance
                     */
                    CpuDevice.prototype.threadCount = 0;

                    /**
                     * CpuDevice vendor.
                     * @member {string} vendor
                     * @memberof telemetry.module.cpu.v1.CpuDevice
                     * @instance
                     */
                    CpuDevice.prototype.vendor = "";

                    /**
                     * CpuDevice model.
                     * @member {string} model
                     * @memberof telemetry.module.cpu.v1.CpuDevice
                     * @instance
                     */
                    CpuDevice.prototype.model = "";

                    /**
                     * Creates a new CpuDevice instance using the specified properties.
                     * @function create
                     * @memberof telemetry.module.cpu.v1.CpuDevice
                     * @static
                     * @param {telemetry.module.cpu.v1.ICpuDevice=} [properties] Properties to set
                     * @returns {telemetry.module.cpu.v1.CpuDevice} CpuDevice instance
                     */
                    CpuDevice.create = function create(properties) {
                        return new CpuDevice(properties);
                    };

                    /**
                     * Encodes the specified CpuDevice message. Does not implicitly {@link telemetry.module.cpu.v1.CpuDevice.verify|verify} messages.
                     * @function encode
                     * @memberof telemetry.module.cpu.v1.CpuDevice
                     * @static
                     * @param {telemetry.module.cpu.v1.ICpuDevice} message CpuDevice message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    CpuDevice.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.packageId != null && Object.hasOwnProperty.call(message, "packageId"))
                            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.packageId);
                        if (message.coreIds != null && message.coreIds.length) {
                            writer.uint32(/* id 2, wireType 2 =*/18).fork();
                            for (let i = 0; i < message.coreIds.length; ++i)
                                writer.int32(message.coreIds[i]);
                            writer.ldelim();
                        }
                        if (message.coreCount != null && Object.hasOwnProperty.call(message, "coreCount"))
                            writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.coreCount);
                        if (message.threadCount != null && Object.hasOwnProperty.call(message, "threadCount"))
                            writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.threadCount);
                        if (message.vendor != null && Object.hasOwnProperty.call(message, "vendor"))
                            writer.uint32(/* id 5, wireType 2 =*/42).string(message.vendor);
                        if (message.model != null && Object.hasOwnProperty.call(message, "model"))
                            writer.uint32(/* id 6, wireType 2 =*/50).string(message.model);
                        return writer;
                    };

                    /**
                     * Encodes the specified CpuDevice message, length delimited. Does not implicitly {@link telemetry.module.cpu.v1.CpuDevice.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof telemetry.module.cpu.v1.CpuDevice
                     * @static
                     * @param {telemetry.module.cpu.v1.ICpuDevice} message CpuDevice message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    CpuDevice.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a CpuDevice message from the specified reader or buffer.
                     * @function decode
                     * @memberof telemetry.module.cpu.v1.CpuDevice
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {telemetry.module.cpu.v1.CpuDevice} CpuDevice
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    CpuDevice.decode = function decode(reader, length, error) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.telemetry.module.cpu.v1.CpuDevice();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            if (tag === error)
                                break;
                            switch (tag >>> 3) {
                            case 1: {
                                    message.packageId = reader.int32();
                                    break;
                                }
                            case 2: {
                                    if (!(message.coreIds && message.coreIds.length))
                                        message.coreIds = [];
                                    if ((tag & 7) === 2) {
                                        let end2 = reader.uint32() + reader.pos;
                                        while (reader.pos < end2)
                                            message.coreIds.push(reader.int32());
                                    } else
                                        message.coreIds.push(reader.int32());
                                    break;
                                }
                            case 3: {
                                    message.coreCount = reader.uint32();
                                    break;
                                }
                            case 4: {
                                    message.threadCount = reader.uint32();
                                    break;
                                }
                            case 5: {
                                    message.vendor = reader.string();
                                    break;
                                }
                            case 6: {
                                    message.model = reader.string();
                                    break;
                                }
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a CpuDevice message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof telemetry.module.cpu.v1.CpuDevice
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {telemetry.module.cpu.v1.CpuDevice} CpuDevice
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    CpuDevice.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a CpuDevice message.
                     * @function verify
                     * @memberof telemetry.module.cpu.v1.CpuDevice
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    CpuDevice.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.packageId != null && message.hasOwnProperty("packageId"))
                            if (!$util.isInteger(message.packageId))
                                return "packageId: integer expected";
                        if (message.coreIds != null && message.hasOwnProperty("coreIds")) {
                            if (!Array.isArray(message.coreIds))
                                return "coreIds: array expected";
                            for (let i = 0; i < message.coreIds.length; ++i)
                                if (!$util.isInteger(message.coreIds[i]))
                                    return "coreIds: integer[] expected";
                        }
                        if (message.coreCount != null && message.hasOwnProperty("coreCount"))
                            if (!$util.isInteger(message.coreCount))
                                return "coreCount: integer expected";
                        if (message.threadCount != null && message.hasOwnProperty("threadCount"))
                            if (!$util.isInteger(message.threadCount))
                                return "threadCount: integer expected";
                        if (message.vendor != null && message.hasOwnProperty("vendor"))
                            if (!$util.isString(message.vendor))
                                return "vendor: string expected";
                        if (message.model != null && message.hasOwnProperty("model"))
                            if (!$util.isString(message.model))
                                return "model: string expected";
                        return null;
                    };

                    /**
                     * Creates a CpuDevice message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof telemetry.module.cpu.v1.CpuDevice
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {telemetry.module.cpu.v1.CpuDevice} CpuDevice
                     */
                    CpuDevice.fromObject = function fromObject(object) {
                        if (object instanceof $root.telemetry.module.cpu.v1.CpuDevice)
                            return object;
                        let message = new $root.telemetry.module.cpu.v1.CpuDevice();
                        if (object.packageId != null)
                            message.packageId = object.packageId | 0;
                        if (object.coreIds) {
                            if (!Array.isArray(object.coreIds))
                                throw TypeError(".telemetry.module.cpu.v1.CpuDevice.coreIds: array expected");
                            message.coreIds = [];
                            for (let i = 0; i < object.coreIds.length; ++i)
                                message.coreIds[i] = object.coreIds[i] | 0;
                        }
                        if (object.coreCount != null)
                            message.coreCount = object.coreCount >>> 0;
                        if (object.threadCount != null)
                            message.threadCount = object.threadCount >>> 0;
                        if (object.vendor != null)
                            message.vendor = String(object.vendor);
                        if (object.model != null)
                            message.model = String(object.model);
                        return message;
                    };

                    /**
                     * Creates a plain object from a CpuDevice message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof telemetry.module.cpu.v1.CpuDevice
                     * @static
                     * @param {telemetry.module.cpu.v1.CpuDevice} message CpuDevice
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    CpuDevice.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.arrays || options.defaults)
                            object.coreIds = [];
                        if (options.defaults) {
                            object.packageId = 0;
                            object.coreCount = 0;
                            object.threadCount = 0;
                            object.vendor = "";
                            object.model = "";
                        }
                        if (message.packageId != null && message.hasOwnProperty("packageId"))
                            object.packageId = message.packageId;
                        if (message.coreIds && message.coreIds.length) {
                            object.coreIds = [];
                            for (let j = 0; j < message.coreIds.length; ++j)
                                object.coreIds[j] = message.coreIds[j];
                        }
                        if (message.coreCount != null && message.hasOwnProperty("coreCount"))
                            object.coreCount = message.coreCount;
                        if (message.threadCount != null && message.hasOwnProperty("threadCount"))
                            object.threadCount = message.threadCount;
                        if (message.vendor != null && message.hasOwnProperty("vendor"))
                            object.vendor = message.vendor;
                        if (message.model != null && message.hasOwnProperty("model"))
                            object.model = message.model;
                        return object;
                    };

                    /**
                     * Converts this CpuDevice to JSON.
                     * @function toJSON
                     * @memberof telemetry.module.cpu.v1.CpuDevice
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    CpuDevice.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Gets the default type url for CpuDevice
                     * @function getTypeUrl
                     * @memberof telemetry.module.cpu.v1.CpuDevice
                     * @static
                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                     * @returns {string} The default type url
                     */
                    CpuDevice.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                        if (typeUrlPrefix === undefined) {
                            typeUrlPrefix = "type.googleapis.com";
                        }
                        return typeUrlPrefix + "/telemetry.module.cpu.v1.CpuDevice";
                    };

                    return CpuDevice;
                })();

                v1.StaticInfo = (function() {

                    /**
                     * Properties of a StaticInfo.
                     * @memberof telemetry.module.cpu.v1
                     * @interface IStaticInfo
                     * @property {string|null} [vendor] StaticInfo vendor
                     * @property {string|null} [model] StaticInfo model
                     * @property {number|null} [packages] StaticInfo packages
                     * @property {number|null} [physicalCores] StaticInfo physicalCores
                     * @property {number|null} [logicalCores] StaticInfo logicalCores
                     * @property {number|null} [threadsPerCore] StaticInfo threadsPerCore
                     * @property {number|Long|null} [cpuinfoMinKhz] StaticInfo cpuinfoMinKhz
                     * @property {number|Long|null} [cpuinfoMaxKhz] StaticInfo cpuinfoMaxKhz
                     * @property {boolean|null} [supportsIntelUncore] StaticInfo supportsIntelUncore
                     * @property {boolean|null} [supportsRapl] StaticInfo supportsRapl
                     */

                    /**
                     * Constructs a new StaticInfo.
                     * @memberof telemetry.module.cpu.v1
                     * @classdesc Represents a StaticInfo.
                     * @implements IStaticInfo
                     * @constructor
                     * @param {telemetry.module.cpu.v1.IStaticInfo=} [properties] Properties to set
                     */
                    function StaticInfo(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * StaticInfo vendor.
                     * @member {string} vendor
                     * @memberof telemetry.module.cpu.v1.StaticInfo
                     * @instance
                     */
                    StaticInfo.prototype.vendor = "";

                    /**
                     * StaticInfo model.
                     * @member {string} model
                     * @memberof telemetry.module.cpu.v1.StaticInfo
                     * @instance
                     */
                    StaticInfo.prototype.model = "";

                    /**
                     * StaticInfo packages.
                     * @member {number} packages
                     * @memberof telemetry.module.cpu.v1.StaticInfo
                     * @instance
                     */
                    StaticInfo.prototype.packages = 0;

                    /**
                     * StaticInfo physicalCores.
                     * @member {number} physicalCores
                     * @memberof telemetry.module.cpu.v1.StaticInfo
                     * @instance
                     */
                    StaticInfo.prototype.physicalCores = 0;

                    /**
                     * StaticInfo logicalCores.
                     * @member {number} logicalCores
                     * @memberof telemetry.module.cpu.v1.StaticInfo
                     * @instance
                     */
                    StaticInfo.prototype.logicalCores = 0;

                    /**
                     * StaticInfo threadsPerCore.
                     * @member {number} threadsPerCore
                     * @memberof telemetry.module.cpu.v1.StaticInfo
                     * @instance
                     */
                    StaticInfo.prototype.threadsPerCore = 0;

                    /**
                     * StaticInfo cpuinfoMinKhz.
                     * @member {number|Long} cpuinfoMinKhz
                     * @memberof telemetry.module.cpu.v1.StaticInfo
                     * @instance
                     */
                    StaticInfo.prototype.cpuinfoMinKhz = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                    /**
                     * StaticInfo cpuinfoMaxKhz.
                     * @member {number|Long} cpuinfoMaxKhz
                     * @memberof telemetry.module.cpu.v1.StaticInfo
                     * @instance
                     */
                    StaticInfo.prototype.cpuinfoMaxKhz = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                    /**
                     * StaticInfo supportsIntelUncore.
                     * @member {boolean} supportsIntelUncore
                     * @memberof telemetry.module.cpu.v1.StaticInfo
                     * @instance
                     */
                    StaticInfo.prototype.supportsIntelUncore = false;

                    /**
                     * StaticInfo supportsRapl.
                     * @member {boolean} supportsRapl
                     * @memberof telemetry.module.cpu.v1.StaticInfo
                     * @instance
                     */
                    StaticInfo.prototype.supportsRapl = false;

                    /**
                     * Creates a new StaticInfo instance using the specified properties.
                     * @function create
                     * @memberof telemetry.module.cpu.v1.StaticInfo
                     * @static
                     * @param {telemetry.module.cpu.v1.IStaticInfo=} [properties] Properties to set
                     * @returns {telemetry.module.cpu.v1.StaticInfo} StaticInfo instance
                     */
                    StaticInfo.create = function create(properties) {
                        return new StaticInfo(properties);
                    };

                    /**
                     * Encodes the specified StaticInfo message. Does not implicitly {@link telemetry.module.cpu.v1.StaticInfo.verify|verify} messages.
                     * @function encode
                     * @memberof telemetry.module.cpu.v1.StaticInfo
                     * @static
                     * @param {telemetry.module.cpu.v1.IStaticInfo} message StaticInfo message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    StaticInfo.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.vendor != null && Object.hasOwnProperty.call(message, "vendor"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.vendor);
                        if (message.model != null && Object.hasOwnProperty.call(message, "model"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.model);
                        if (message.packages != null && Object.hasOwnProperty.call(message, "packages"))
                            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.packages);
                        if (message.physicalCores != null && Object.hasOwnProperty.call(message, "physicalCores"))
                            writer.uint32(/* id 4, wireType 0 =*/32).int32(message.physicalCores);
                        if (message.logicalCores != null && Object.hasOwnProperty.call(message, "logicalCores"))
                            writer.uint32(/* id 5, wireType 0 =*/40).int32(message.logicalCores);
                        if (message.threadsPerCore != null && Object.hasOwnProperty.call(message, "threadsPerCore"))
                            writer.uint32(/* id 6, wireType 0 =*/48).int32(message.threadsPerCore);
                        if (message.cpuinfoMinKhz != null && Object.hasOwnProperty.call(message, "cpuinfoMinKhz"))
                            writer.uint32(/* id 7, wireType 0 =*/56).uint64(message.cpuinfoMinKhz);
                        if (message.cpuinfoMaxKhz != null && Object.hasOwnProperty.call(message, "cpuinfoMaxKhz"))
                            writer.uint32(/* id 8, wireType 0 =*/64).uint64(message.cpuinfoMaxKhz);
                        if (message.supportsIntelUncore != null && Object.hasOwnProperty.call(message, "supportsIntelUncore"))
                            writer.uint32(/* id 9, wireType 0 =*/72).bool(message.supportsIntelUncore);
                        if (message.supportsRapl != null && Object.hasOwnProperty.call(message, "supportsRapl"))
                            writer.uint32(/* id 10, wireType 0 =*/80).bool(message.supportsRapl);
                        return writer;
                    };

                    /**
                     * Encodes the specified StaticInfo message, length delimited. Does not implicitly {@link telemetry.module.cpu.v1.StaticInfo.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof telemetry.module.cpu.v1.StaticInfo
                     * @static
                     * @param {telemetry.module.cpu.v1.IStaticInfo} message StaticInfo message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    StaticInfo.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a StaticInfo message from the specified reader or buffer.
                     * @function decode
                     * @memberof telemetry.module.cpu.v1.StaticInfo
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {telemetry.module.cpu.v1.StaticInfo} StaticInfo
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    StaticInfo.decode = function decode(reader, length, error) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.telemetry.module.cpu.v1.StaticInfo();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            if (tag === error)
                                break;
                            switch (tag >>> 3) {
                            case 1: {
                                    message.vendor = reader.string();
                                    break;
                                }
                            case 2: {
                                    message.model = reader.string();
                                    break;
                                }
                            case 3: {
                                    message.packages = reader.int32();
                                    break;
                                }
                            case 4: {
                                    message.physicalCores = reader.int32();
                                    break;
                                }
                            case 5: {
                                    message.logicalCores = reader.int32();
                                    break;
                                }
                            case 6: {
                                    message.threadsPerCore = reader.int32();
                                    break;
                                }
                            case 7: {
                                    message.cpuinfoMinKhz = reader.uint64();
                                    break;
                                }
                            case 8: {
                                    message.cpuinfoMaxKhz = reader.uint64();
                                    break;
                                }
                            case 9: {
                                    message.supportsIntelUncore = reader.bool();
                                    break;
                                }
                            case 10: {
                                    message.supportsRapl = reader.bool();
                                    break;
                                }
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a StaticInfo message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof telemetry.module.cpu.v1.StaticInfo
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {telemetry.module.cpu.v1.StaticInfo} StaticInfo
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    StaticInfo.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a StaticInfo message.
                     * @function verify
                     * @memberof telemetry.module.cpu.v1.StaticInfo
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    StaticInfo.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.vendor != null && message.hasOwnProperty("vendor"))
                            if (!$util.isString(message.vendor))
                                return "vendor: string expected";
                        if (message.model != null && message.hasOwnProperty("model"))
                            if (!$util.isString(message.model))
                                return "model: string expected";
                        if (message.packages != null && message.hasOwnProperty("packages"))
                            if (!$util.isInteger(message.packages))
                                return "packages: integer expected";
                        if (message.physicalCores != null && message.hasOwnProperty("physicalCores"))
                            if (!$util.isInteger(message.physicalCores))
                                return "physicalCores: integer expected";
                        if (message.logicalCores != null && message.hasOwnProperty("logicalCores"))
                            if (!$util.isInteger(message.logicalCores))
                                return "logicalCores: integer expected";
                        if (message.threadsPerCore != null && message.hasOwnProperty("threadsPerCore"))
                            if (!$util.isInteger(message.threadsPerCore))
                                return "threadsPerCore: integer expected";
                        if (message.cpuinfoMinKhz != null && message.hasOwnProperty("cpuinfoMinKhz"))
                            if (!$util.isInteger(message.cpuinfoMinKhz) && !(message.cpuinfoMinKhz && $util.isInteger(message.cpuinfoMinKhz.low) && $util.isInteger(message.cpuinfoMinKhz.high)))
                                return "cpuinfoMinKhz: integer|Long expected";
                        if (message.cpuinfoMaxKhz != null && message.hasOwnProperty("cpuinfoMaxKhz"))
                            if (!$util.isInteger(message.cpuinfoMaxKhz) && !(message.cpuinfoMaxKhz && $util.isInteger(message.cpuinfoMaxKhz.low) && $util.isInteger(message.cpuinfoMaxKhz.high)))
                                return "cpuinfoMaxKhz: integer|Long expected";
                        if (message.supportsIntelUncore != null && message.hasOwnProperty("supportsIntelUncore"))
                            if (typeof message.supportsIntelUncore !== "boolean")
                                return "supportsIntelUncore: boolean expected";
                        if (message.supportsRapl != null && message.hasOwnProperty("supportsRapl"))
                            if (typeof message.supportsRapl !== "boolean")
                                return "supportsRapl: boolean expected";
                        return null;
                    };

                    /**
                     * Creates a StaticInfo message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof telemetry.module.cpu.v1.StaticInfo
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {telemetry.module.cpu.v1.StaticInfo} StaticInfo
                     */
                    StaticInfo.fromObject = function fromObject(object) {
                        if (object instanceof $root.telemetry.module.cpu.v1.StaticInfo)
                            return object;
                        let message = new $root.telemetry.module.cpu.v1.StaticInfo();
                        if (object.vendor != null)
                            message.vendor = String(object.vendor);
                        if (object.model != null)
                            message.model = String(object.model);
                        if (object.packages != null)
                            message.packages = object.packages | 0;
                        if (object.physicalCores != null)
                            message.physicalCores = object.physicalCores | 0;
                        if (object.logicalCores != null)
                            message.logicalCores = object.logicalCores | 0;
                        if (object.threadsPerCore != null)
                            message.threadsPerCore = object.threadsPerCore | 0;
                        if (object.cpuinfoMinKhz != null)
                            if ($util.Long)
                                (message.cpuinfoMinKhz = $util.Long.fromValue(object.cpuinfoMinKhz)).unsigned = true;
                            else if (typeof object.cpuinfoMinKhz === "string")
                                message.cpuinfoMinKhz = parseInt(object.cpuinfoMinKhz, 10);
                            else if (typeof object.cpuinfoMinKhz === "number")
                                message.cpuinfoMinKhz = object.cpuinfoMinKhz;
                            else if (typeof object.cpuinfoMinKhz === "object")
                                message.cpuinfoMinKhz = new $util.LongBits(object.cpuinfoMinKhz.low >>> 0, object.cpuinfoMinKhz.high >>> 0).toNumber(true);
                        if (object.cpuinfoMaxKhz != null)
                            if ($util.Long)
                                (message.cpuinfoMaxKhz = $util.Long.fromValue(object.cpuinfoMaxKhz)).unsigned = true;
                            else if (typeof object.cpuinfoMaxKhz === "string")
                                message.cpuinfoMaxKhz = parseInt(object.cpuinfoMaxKhz, 10);
                            else if (typeof object.cpuinfoMaxKhz === "number")
                                message.cpuinfoMaxKhz = object.cpuinfoMaxKhz;
                            else if (typeof object.cpuinfoMaxKhz === "object")
                                message.cpuinfoMaxKhz = new $util.LongBits(object.cpuinfoMaxKhz.low >>> 0, object.cpuinfoMaxKhz.high >>> 0).toNumber(true);
                        if (object.supportsIntelUncore != null)
                            message.supportsIntelUncore = Boolean(object.supportsIntelUncore);
                        if (object.supportsRapl != null)
                            message.supportsRapl = Boolean(object.supportsRapl);
                        return message;
                    };

                    /**
                     * Creates a plain object from a StaticInfo message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof telemetry.module.cpu.v1.StaticInfo
                     * @static
                     * @param {telemetry.module.cpu.v1.StaticInfo} message StaticInfo
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    StaticInfo.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.vendor = "";
                            object.model = "";
                            object.packages = 0;
                            object.physicalCores = 0;
                            object.logicalCores = 0;
                            object.threadsPerCore = 0;
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, true);
                                object.cpuinfoMinKhz = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.cpuinfoMinKhz = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, true);
                                object.cpuinfoMaxKhz = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.cpuinfoMaxKhz = options.longs === String ? "0" : 0;
                            object.supportsIntelUncore = false;
                            object.supportsRapl = false;
                        }
                        if (message.vendor != null && message.hasOwnProperty("vendor"))
                            object.vendor = message.vendor;
                        if (message.model != null && message.hasOwnProperty("model"))
                            object.model = message.model;
                        if (message.packages != null && message.hasOwnProperty("packages"))
                            object.packages = message.packages;
                        if (message.physicalCores != null && message.hasOwnProperty("physicalCores"))
                            object.physicalCores = message.physicalCores;
                        if (message.logicalCores != null && message.hasOwnProperty("logicalCores"))
                            object.logicalCores = message.logicalCores;
                        if (message.threadsPerCore != null && message.hasOwnProperty("threadsPerCore"))
                            object.threadsPerCore = message.threadsPerCore;
                        if (message.cpuinfoMinKhz != null && message.hasOwnProperty("cpuinfoMinKhz"))
                            if (typeof message.cpuinfoMinKhz === "number")
                                object.cpuinfoMinKhz = options.longs === String ? String(message.cpuinfoMinKhz) : message.cpuinfoMinKhz;
                            else
                                object.cpuinfoMinKhz = options.longs === String ? $util.Long.prototype.toString.call(message.cpuinfoMinKhz) : options.longs === Number ? new $util.LongBits(message.cpuinfoMinKhz.low >>> 0, message.cpuinfoMinKhz.high >>> 0).toNumber(true) : message.cpuinfoMinKhz;
                        if (message.cpuinfoMaxKhz != null && message.hasOwnProperty("cpuinfoMaxKhz"))
                            if (typeof message.cpuinfoMaxKhz === "number")
                                object.cpuinfoMaxKhz = options.longs === String ? String(message.cpuinfoMaxKhz) : message.cpuinfoMaxKhz;
                            else
                                object.cpuinfoMaxKhz = options.longs === String ? $util.Long.prototype.toString.call(message.cpuinfoMaxKhz) : options.longs === Number ? new $util.LongBits(message.cpuinfoMaxKhz.low >>> 0, message.cpuinfoMaxKhz.high >>> 0).toNumber(true) : message.cpuinfoMaxKhz;
                        if (message.supportsIntelUncore != null && message.hasOwnProperty("supportsIntelUncore"))
                            object.supportsIntelUncore = message.supportsIntelUncore;
                        if (message.supportsRapl != null && message.hasOwnProperty("supportsRapl"))
                            object.supportsRapl = message.supportsRapl;
                        return object;
                    };

                    /**
                     * Converts this StaticInfo to JSON.
                     * @function toJSON
                     * @memberof telemetry.module.cpu.v1.StaticInfo
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    StaticInfo.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Gets the default type url for StaticInfo
                     * @function getTypeUrl
                     * @memberof telemetry.module.cpu.v1.StaticInfo
                     * @static
                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                     * @returns {string} The default type url
                     */
                    StaticInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                        if (typeUrlPrefix === undefined) {
                            typeUrlPrefix = "type.googleapis.com";
                        }
                        return typeUrlPrefix + "/telemetry.module.cpu.v1.StaticInfo";
                    };

                    return StaticInfo;
                })();

                v1.ModuleRegistration = (function() {

                    /**
                     * Properties of a ModuleRegistration.
                     * @memberof telemetry.module.cpu.v1
                     * @interface IModuleRegistration
                     * @property {telemetry.module.cpu.v1.IStaticInfo|null} ["static"] ModuleRegistration static
                     * @property {Array.<telemetry.module.cpu.v1.ICollectorSpec>|null} [collectors] ModuleRegistration collectors
                     * @property {Array.<telemetry.module.cpu.v1.IControllerSpec>|null} [controllers] ModuleRegistration controllers
                     * @property {Array.<telemetry.module.cpu.v1.ICpuDevice>|null} [devices] ModuleRegistration devices
                     * @property {Array.<telemetry.module.cpu.v1.IPackageControl>|null} [packageControls] ModuleRegistration packageControls
                     */

                    /**
                     * Constructs a new ModuleRegistration.
                     * @memberof telemetry.module.cpu.v1
                     * @classdesc Represents a ModuleRegistration.
                     * @implements IModuleRegistration
                     * @constructor
                     * @param {telemetry.module.cpu.v1.IModuleRegistration=} [properties] Properties to set
                     */
                    function ModuleRegistration(properties) {
                        this.collectors = [];
                        this.controllers = [];
                        this.devices = [];
                        this.packageControls = [];
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * ModuleRegistration static.
                     * @member {telemetry.module.cpu.v1.IStaticInfo|null|undefined} static
                     * @memberof telemetry.module.cpu.v1.ModuleRegistration
                     * @instance
                     */
                    ModuleRegistration.prototype["static"] = null;

                    /**
                     * ModuleRegistration collectors.
                     * @member {Array.<telemetry.module.cpu.v1.ICollectorSpec>} collectors
                     * @memberof telemetry.module.cpu.v1.ModuleRegistration
                     * @instance
                     */
                    ModuleRegistration.prototype.collectors = $util.emptyArray;

                    /**
                     * ModuleRegistration controllers.
                     * @member {Array.<telemetry.module.cpu.v1.IControllerSpec>} controllers
                     * @memberof telemetry.module.cpu.v1.ModuleRegistration
                     * @instance
                     */
                    ModuleRegistration.prototype.controllers = $util.emptyArray;

                    /**
                     * ModuleRegistration devices.
                     * @member {Array.<telemetry.module.cpu.v1.ICpuDevice>} devices
                     * @memberof telemetry.module.cpu.v1.ModuleRegistration
                     * @instance
                     */
                    ModuleRegistration.prototype.devices = $util.emptyArray;

                    /**
                     * ModuleRegistration packageControls.
                     * @member {Array.<telemetry.module.cpu.v1.IPackageControl>} packageControls
                     * @memberof telemetry.module.cpu.v1.ModuleRegistration
                     * @instance
                     */
                    ModuleRegistration.prototype.packageControls = $util.emptyArray;

                    /**
                     * Creates a new ModuleRegistration instance using the specified properties.
                     * @function create
                     * @memberof telemetry.module.cpu.v1.ModuleRegistration
                     * @static
                     * @param {telemetry.module.cpu.v1.IModuleRegistration=} [properties] Properties to set
                     * @returns {telemetry.module.cpu.v1.ModuleRegistration} ModuleRegistration instance
                     */
                    ModuleRegistration.create = function create(properties) {
                        return new ModuleRegistration(properties);
                    };

                    /**
                     * Encodes the specified ModuleRegistration message. Does not implicitly {@link telemetry.module.cpu.v1.ModuleRegistration.verify|verify} messages.
                     * @function encode
                     * @memberof telemetry.module.cpu.v1.ModuleRegistration
                     * @static
                     * @param {telemetry.module.cpu.v1.IModuleRegistration} message ModuleRegistration message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ModuleRegistration.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message["static"] != null && Object.hasOwnProperty.call(message, "static"))
                            $root.telemetry.module.cpu.v1.StaticInfo.encode(message["static"], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.collectors != null && message.collectors.length)
                            for (let i = 0; i < message.collectors.length; ++i)
                                $root.telemetry.module.cpu.v1.CollectorSpec.encode(message.collectors[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                        if (message.controllers != null && message.controllers.length)
                            for (let i = 0; i < message.controllers.length; ++i)
                                $root.telemetry.module.cpu.v1.ControllerSpec.encode(message.controllers[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                        if (message.devices != null && message.devices.length)
                            for (let i = 0; i < message.devices.length; ++i)
                                $root.telemetry.module.cpu.v1.CpuDevice.encode(message.devices[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                        if (message.packageControls != null && message.packageControls.length)
                            for (let i = 0; i < message.packageControls.length; ++i)
                                $root.telemetry.module.cpu.v1.PackageControl.encode(message.packageControls[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                        return writer;
                    };

                    /**
                     * Encodes the specified ModuleRegistration message, length delimited. Does not implicitly {@link telemetry.module.cpu.v1.ModuleRegistration.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof telemetry.module.cpu.v1.ModuleRegistration
                     * @static
                     * @param {telemetry.module.cpu.v1.IModuleRegistration} message ModuleRegistration message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ModuleRegistration.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a ModuleRegistration message from the specified reader or buffer.
                     * @function decode
                     * @memberof telemetry.module.cpu.v1.ModuleRegistration
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {telemetry.module.cpu.v1.ModuleRegistration} ModuleRegistration
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ModuleRegistration.decode = function decode(reader, length, error) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.telemetry.module.cpu.v1.ModuleRegistration();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            if (tag === error)
                                break;
                            switch (tag >>> 3) {
                            case 1: {
                                    message["static"] = $root.telemetry.module.cpu.v1.StaticInfo.decode(reader, reader.uint32());
                                    break;
                                }
                            case 2: {
                                    if (!(message.collectors && message.collectors.length))
                                        message.collectors = [];
                                    message.collectors.push($root.telemetry.module.cpu.v1.CollectorSpec.decode(reader, reader.uint32()));
                                    break;
                                }
                            case 3: {
                                    if (!(message.controllers && message.controllers.length))
                                        message.controllers = [];
                                    message.controllers.push($root.telemetry.module.cpu.v1.ControllerSpec.decode(reader, reader.uint32()));
                                    break;
                                }
                            case 4: {
                                    if (!(message.devices && message.devices.length))
                                        message.devices = [];
                                    message.devices.push($root.telemetry.module.cpu.v1.CpuDevice.decode(reader, reader.uint32()));
                                    break;
                                }
                            case 5: {
                                    if (!(message.packageControls && message.packageControls.length))
                                        message.packageControls = [];
                                    message.packageControls.push($root.telemetry.module.cpu.v1.PackageControl.decode(reader, reader.uint32()));
                                    break;
                                }
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a ModuleRegistration message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof telemetry.module.cpu.v1.ModuleRegistration
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {telemetry.module.cpu.v1.ModuleRegistration} ModuleRegistration
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ModuleRegistration.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a ModuleRegistration message.
                     * @function verify
                     * @memberof telemetry.module.cpu.v1.ModuleRegistration
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    ModuleRegistration.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message["static"] != null && message.hasOwnProperty("static")) {
                            let error = $root.telemetry.module.cpu.v1.StaticInfo.verify(message["static"]);
                            if (error)
                                return "static." + error;
                        }
                        if (message.collectors != null && message.hasOwnProperty("collectors")) {
                            if (!Array.isArray(message.collectors))
                                return "collectors: array expected";
                            for (let i = 0; i < message.collectors.length; ++i) {
                                let error = $root.telemetry.module.cpu.v1.CollectorSpec.verify(message.collectors[i]);
                                if (error)
                                    return "collectors." + error;
                            }
                        }
                        if (message.controllers != null && message.hasOwnProperty("controllers")) {
                            if (!Array.isArray(message.controllers))
                                return "controllers: array expected";
                            for (let i = 0; i < message.controllers.length; ++i) {
                                let error = $root.telemetry.module.cpu.v1.ControllerSpec.verify(message.controllers[i]);
                                if (error)
                                    return "controllers." + error;
                            }
                        }
                        if (message.devices != null && message.hasOwnProperty("devices")) {
                            if (!Array.isArray(message.devices))
                                return "devices: array expected";
                            for (let i = 0; i < message.devices.length; ++i) {
                                let error = $root.telemetry.module.cpu.v1.CpuDevice.verify(message.devices[i]);
                                if (error)
                                    return "devices." + error;
                            }
                        }
                        if (message.packageControls != null && message.hasOwnProperty("packageControls")) {
                            if (!Array.isArray(message.packageControls))
                                return "packageControls: array expected";
                            for (let i = 0; i < message.packageControls.length; ++i) {
                                let error = $root.telemetry.module.cpu.v1.PackageControl.verify(message.packageControls[i]);
                                if (error)
                                    return "packageControls." + error;
                            }
                        }
                        return null;
                    };

                    /**
                     * Creates a ModuleRegistration message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof telemetry.module.cpu.v1.ModuleRegistration
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {telemetry.module.cpu.v1.ModuleRegistration} ModuleRegistration
                     */
                    ModuleRegistration.fromObject = function fromObject(object) {
                        if (object instanceof $root.telemetry.module.cpu.v1.ModuleRegistration)
                            return object;
                        let message = new $root.telemetry.module.cpu.v1.ModuleRegistration();
                        if (object["static"] != null) {
                            if (typeof object["static"] !== "object")
                                throw TypeError(".telemetry.module.cpu.v1.ModuleRegistration.static: object expected");
                            message["static"] = $root.telemetry.module.cpu.v1.StaticInfo.fromObject(object["static"]);
                        }
                        if (object.collectors) {
                            if (!Array.isArray(object.collectors))
                                throw TypeError(".telemetry.module.cpu.v1.ModuleRegistration.collectors: array expected");
                            message.collectors = [];
                            for (let i = 0; i < object.collectors.length; ++i) {
                                if (typeof object.collectors[i] !== "object")
                                    throw TypeError(".telemetry.module.cpu.v1.ModuleRegistration.collectors: object expected");
                                message.collectors[i] = $root.telemetry.module.cpu.v1.CollectorSpec.fromObject(object.collectors[i]);
                            }
                        }
                        if (object.controllers) {
                            if (!Array.isArray(object.controllers))
                                throw TypeError(".telemetry.module.cpu.v1.ModuleRegistration.controllers: array expected");
                            message.controllers = [];
                            for (let i = 0; i < object.controllers.length; ++i) {
                                if (typeof object.controllers[i] !== "object")
                                    throw TypeError(".telemetry.module.cpu.v1.ModuleRegistration.controllers: object expected");
                                message.controllers[i] = $root.telemetry.module.cpu.v1.ControllerSpec.fromObject(object.controllers[i]);
                            }
                        }
                        if (object.devices) {
                            if (!Array.isArray(object.devices))
                                throw TypeError(".telemetry.module.cpu.v1.ModuleRegistration.devices: array expected");
                            message.devices = [];
                            for (let i = 0; i < object.devices.length; ++i) {
                                if (typeof object.devices[i] !== "object")
                                    throw TypeError(".telemetry.module.cpu.v1.ModuleRegistration.devices: object expected");
                                message.devices[i] = $root.telemetry.module.cpu.v1.CpuDevice.fromObject(object.devices[i]);
                            }
                        }
                        if (object.packageControls) {
                            if (!Array.isArray(object.packageControls))
                                throw TypeError(".telemetry.module.cpu.v1.ModuleRegistration.packageControls: array expected");
                            message.packageControls = [];
                            for (let i = 0; i < object.packageControls.length; ++i) {
                                if (typeof object.packageControls[i] !== "object")
                                    throw TypeError(".telemetry.module.cpu.v1.ModuleRegistration.packageControls: object expected");
                                message.packageControls[i] = $root.telemetry.module.cpu.v1.PackageControl.fromObject(object.packageControls[i]);
                            }
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a ModuleRegistration message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof telemetry.module.cpu.v1.ModuleRegistration
                     * @static
                     * @param {telemetry.module.cpu.v1.ModuleRegistration} message ModuleRegistration
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    ModuleRegistration.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.arrays || options.defaults) {
                            object.collectors = [];
                            object.controllers = [];
                            object.devices = [];
                            object.packageControls = [];
                        }
                        if (options.defaults)
                            object["static"] = null;
                        if (message["static"] != null && message.hasOwnProperty("static"))
                            object["static"] = $root.telemetry.module.cpu.v1.StaticInfo.toObject(message["static"], options);
                        if (message.collectors && message.collectors.length) {
                            object.collectors = [];
                            for (let j = 0; j < message.collectors.length; ++j)
                                object.collectors[j] = $root.telemetry.module.cpu.v1.CollectorSpec.toObject(message.collectors[j], options);
                        }
                        if (message.controllers && message.controllers.length) {
                            object.controllers = [];
                            for (let j = 0; j < message.controllers.length; ++j)
                                object.controllers[j] = $root.telemetry.module.cpu.v1.ControllerSpec.toObject(message.controllers[j], options);
                        }
                        if (message.devices && message.devices.length) {
                            object.devices = [];
                            for (let j = 0; j < message.devices.length; ++j)
                                object.devices[j] = $root.telemetry.module.cpu.v1.CpuDevice.toObject(message.devices[j], options);
                        }
                        if (message.packageControls && message.packageControls.length) {
                            object.packageControls = [];
                            for (let j = 0; j < message.packageControls.length; ++j)
                                object.packageControls[j] = $root.telemetry.module.cpu.v1.PackageControl.toObject(message.packageControls[j], options);
                        }
                        return object;
                    };

                    /**
                     * Converts this ModuleRegistration to JSON.
                     * @function toJSON
                     * @memberof telemetry.module.cpu.v1.ModuleRegistration
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    ModuleRegistration.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Gets the default type url for ModuleRegistration
                     * @function getTypeUrl
                     * @memberof telemetry.module.cpu.v1.ModuleRegistration
                     * @static
                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                     * @returns {string} The default type url
                     */
                    ModuleRegistration.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                        if (typeUrlPrefix === undefined) {
                            typeUrlPrefix = "type.googleapis.com";
                        }
                        return typeUrlPrefix + "/telemetry.module.cpu.v1.ModuleRegistration";
                    };

                    return ModuleRegistration;
                })();

                v1.PackageControl = (function() {

                    /**
                     * Properties of a PackageControl.
                     * @memberof telemetry.module.cpu.v1
                     * @interface IPackageControl
                     * @property {number|null} [packageId] PackageControl packageId
                     * @property {number|Long|null} [scalingMinKhz] PackageControl scalingMinKhz
                     * @property {number|Long|null} [scalingMaxKhz] PackageControl scalingMaxKhz
                     * @property {Array.<string>|null} [availableGovernors] PackageControl availableGovernors
                     * @property {string|null} [currentGovernor] PackageControl currentGovernor
                     * @property {string|null} [scalingDriver] PackageControl scalingDriver
                     * @property {number|Long|null} [uncoreCurrentKhz] PackageControl uncoreCurrentKhz
                     * @property {number|Long|null} [uncoreMinKhz] PackageControl uncoreMinKhz
                     * @property {number|Long|null} [uncoreMaxKhz] PackageControl uncoreMaxKhz
                     * @property {number|Long|null} [powerCapMicroW] PackageControl powerCapMicroW
                     * @property {number|Long|null} [powerCapMinMicroW] PackageControl powerCapMinMicroW
                     * @property {number|Long|null} [powerCapMaxMicroW] PackageControl powerCapMaxMicroW
                     * @property {number|Long|null} [scalingHwMinKhz] PackageControl scalingHwMinKhz
                     * @property {number|Long|null} [scalingHwMaxKhz] PackageControl scalingHwMaxKhz
                     */

                    /**
                     * Constructs a new PackageControl.
                     * @memberof telemetry.module.cpu.v1
                     * @classdesc Represents a PackageControl.
                     * @implements IPackageControl
                     * @constructor
                     * @param {telemetry.module.cpu.v1.IPackageControl=} [properties] Properties to set
                     */
                    function PackageControl(properties) {
                        this.availableGovernors = [];
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * PackageControl packageId.
                     * @member {number} packageId
                     * @memberof telemetry.module.cpu.v1.PackageControl
                     * @instance
                     */
                    PackageControl.prototype.packageId = 0;

                    /**
                     * PackageControl scalingMinKhz.
                     * @member {number|Long} scalingMinKhz
                     * @memberof telemetry.module.cpu.v1.PackageControl
                     * @instance
                     */
                    PackageControl.prototype.scalingMinKhz = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                    /**
                     * PackageControl scalingMaxKhz.
                     * @member {number|Long} scalingMaxKhz
                     * @memberof telemetry.module.cpu.v1.PackageControl
                     * @instance
                     */
                    PackageControl.prototype.scalingMaxKhz = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                    /**
                     * PackageControl availableGovernors.
                     * @member {Array.<string>} availableGovernors
                     * @memberof telemetry.module.cpu.v1.PackageControl
                     * @instance
                     */
                    PackageControl.prototype.availableGovernors = $util.emptyArray;

                    /**
                     * PackageControl currentGovernor.
                     * @member {string} currentGovernor
                     * @memberof telemetry.module.cpu.v1.PackageControl
                     * @instance
                     */
                    PackageControl.prototype.currentGovernor = "";

                    /**
                     * PackageControl scalingDriver.
                     * @member {string} scalingDriver
                     * @memberof telemetry.module.cpu.v1.PackageControl
                     * @instance
                     */
                    PackageControl.prototype.scalingDriver = "";

                    /**
                     * PackageControl uncoreCurrentKhz.
                     * @member {number|Long} uncoreCurrentKhz
                     * @memberof telemetry.module.cpu.v1.PackageControl
                     * @instance
                     */
                    PackageControl.prototype.uncoreCurrentKhz = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                    /**
                     * PackageControl uncoreMinKhz.
                     * @member {number|Long} uncoreMinKhz
                     * @memberof telemetry.module.cpu.v1.PackageControl
                     * @instance
                     */
                    PackageControl.prototype.uncoreMinKhz = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                    /**
                     * PackageControl uncoreMaxKhz.
                     * @member {number|Long} uncoreMaxKhz
                     * @memberof telemetry.module.cpu.v1.PackageControl
                     * @instance
                     */
                    PackageControl.prototype.uncoreMaxKhz = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                    /**
                     * PackageControl powerCapMicroW.
                     * @member {number|Long} powerCapMicroW
                     * @memberof telemetry.module.cpu.v1.PackageControl
                     * @instance
                     */
                    PackageControl.prototype.powerCapMicroW = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                    /**
                     * PackageControl powerCapMinMicroW.
                     * @member {number|Long} powerCapMinMicroW
                     * @memberof telemetry.module.cpu.v1.PackageControl
                     * @instance
                     */
                    PackageControl.prototype.powerCapMinMicroW = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                    /**
                     * PackageControl powerCapMaxMicroW.
                     * @member {number|Long} powerCapMaxMicroW
                     * @memberof telemetry.module.cpu.v1.PackageControl
                     * @instance
                     */
                    PackageControl.prototype.powerCapMaxMicroW = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                    /**
                     * PackageControl scalingHwMinKhz.
                     * @member {number|Long} scalingHwMinKhz
                     * @memberof telemetry.module.cpu.v1.PackageControl
                     * @instance
                     */
                    PackageControl.prototype.scalingHwMinKhz = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                    /**
                     * PackageControl scalingHwMaxKhz.
                     * @member {number|Long} scalingHwMaxKhz
                     * @memberof telemetry.module.cpu.v1.PackageControl
                     * @instance
                     */
                    PackageControl.prototype.scalingHwMaxKhz = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                    /**
                     * Creates a new PackageControl instance using the specified properties.
                     * @function create
                     * @memberof telemetry.module.cpu.v1.PackageControl
                     * @static
                     * @param {telemetry.module.cpu.v1.IPackageControl=} [properties] Properties to set
                     * @returns {telemetry.module.cpu.v1.PackageControl} PackageControl instance
                     */
                    PackageControl.create = function create(properties) {
                        return new PackageControl(properties);
                    };

                    /**
                     * Encodes the specified PackageControl message. Does not implicitly {@link telemetry.module.cpu.v1.PackageControl.verify|verify} messages.
                     * @function encode
                     * @memberof telemetry.module.cpu.v1.PackageControl
                     * @static
                     * @param {telemetry.module.cpu.v1.IPackageControl} message PackageControl message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    PackageControl.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.packageId != null && Object.hasOwnProperty.call(message, "packageId"))
                            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.packageId);
                        if (message.scalingMinKhz != null && Object.hasOwnProperty.call(message, "scalingMinKhz"))
                            writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.scalingMinKhz);
                        if (message.scalingMaxKhz != null && Object.hasOwnProperty.call(message, "scalingMaxKhz"))
                            writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.scalingMaxKhz);
                        if (message.availableGovernors != null && message.availableGovernors.length)
                            for (let i = 0; i < message.availableGovernors.length; ++i)
                                writer.uint32(/* id 4, wireType 2 =*/34).string(message.availableGovernors[i]);
                        if (message.currentGovernor != null && Object.hasOwnProperty.call(message, "currentGovernor"))
                            writer.uint32(/* id 5, wireType 2 =*/42).string(message.currentGovernor);
                        if (message.scalingDriver != null && Object.hasOwnProperty.call(message, "scalingDriver"))
                            writer.uint32(/* id 6, wireType 2 =*/50).string(message.scalingDriver);
                        if (message.uncoreCurrentKhz != null && Object.hasOwnProperty.call(message, "uncoreCurrentKhz"))
                            writer.uint32(/* id 7, wireType 0 =*/56).uint64(message.uncoreCurrentKhz);
                        if (message.uncoreMinKhz != null && Object.hasOwnProperty.call(message, "uncoreMinKhz"))
                            writer.uint32(/* id 8, wireType 0 =*/64).uint64(message.uncoreMinKhz);
                        if (message.uncoreMaxKhz != null && Object.hasOwnProperty.call(message, "uncoreMaxKhz"))
                            writer.uint32(/* id 9, wireType 0 =*/72).uint64(message.uncoreMaxKhz);
                        if (message.powerCapMicroW != null && Object.hasOwnProperty.call(message, "powerCapMicroW"))
                            writer.uint32(/* id 10, wireType 0 =*/80).uint64(message.powerCapMicroW);
                        if (message.powerCapMinMicroW != null && Object.hasOwnProperty.call(message, "powerCapMinMicroW"))
                            writer.uint32(/* id 11, wireType 0 =*/88).uint64(message.powerCapMinMicroW);
                        if (message.powerCapMaxMicroW != null && Object.hasOwnProperty.call(message, "powerCapMaxMicroW"))
                            writer.uint32(/* id 12, wireType 0 =*/96).uint64(message.powerCapMaxMicroW);
                        if (message.scalingHwMinKhz != null && Object.hasOwnProperty.call(message, "scalingHwMinKhz"))
                            writer.uint32(/* id 13, wireType 0 =*/104).uint64(message.scalingHwMinKhz);
                        if (message.scalingHwMaxKhz != null && Object.hasOwnProperty.call(message, "scalingHwMaxKhz"))
                            writer.uint32(/* id 14, wireType 0 =*/112).uint64(message.scalingHwMaxKhz);
                        return writer;
                    };

                    /**
                     * Encodes the specified PackageControl message, length delimited. Does not implicitly {@link telemetry.module.cpu.v1.PackageControl.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof telemetry.module.cpu.v1.PackageControl
                     * @static
                     * @param {telemetry.module.cpu.v1.IPackageControl} message PackageControl message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    PackageControl.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a PackageControl message from the specified reader or buffer.
                     * @function decode
                     * @memberof telemetry.module.cpu.v1.PackageControl
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {telemetry.module.cpu.v1.PackageControl} PackageControl
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    PackageControl.decode = function decode(reader, length, error) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.telemetry.module.cpu.v1.PackageControl();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            if (tag === error)
                                break;
                            switch (tag >>> 3) {
                            case 1: {
                                    message.packageId = reader.int32();
                                    break;
                                }
                            case 2: {
                                    message.scalingMinKhz = reader.uint64();
                                    break;
                                }
                            case 3: {
                                    message.scalingMaxKhz = reader.uint64();
                                    break;
                                }
                            case 4: {
                                    if (!(message.availableGovernors && message.availableGovernors.length))
                                        message.availableGovernors = [];
                                    message.availableGovernors.push(reader.string());
                                    break;
                                }
                            case 5: {
                                    message.currentGovernor = reader.string();
                                    break;
                                }
                            case 6: {
                                    message.scalingDriver = reader.string();
                                    break;
                                }
                            case 7: {
                                    message.uncoreCurrentKhz = reader.uint64();
                                    break;
                                }
                            case 8: {
                                    message.uncoreMinKhz = reader.uint64();
                                    break;
                                }
                            case 9: {
                                    message.uncoreMaxKhz = reader.uint64();
                                    break;
                                }
                            case 10: {
                                    message.powerCapMicroW = reader.uint64();
                                    break;
                                }
                            case 11: {
                                    message.powerCapMinMicroW = reader.uint64();
                                    break;
                                }
                            case 12: {
                                    message.powerCapMaxMicroW = reader.uint64();
                                    break;
                                }
                            case 13: {
                                    message.scalingHwMinKhz = reader.uint64();
                                    break;
                                }
                            case 14: {
                                    message.scalingHwMaxKhz = reader.uint64();
                                    break;
                                }
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a PackageControl message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof telemetry.module.cpu.v1.PackageControl
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {telemetry.module.cpu.v1.PackageControl} PackageControl
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    PackageControl.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a PackageControl message.
                     * @function verify
                     * @memberof telemetry.module.cpu.v1.PackageControl
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    PackageControl.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.packageId != null && message.hasOwnProperty("packageId"))
                            if (!$util.isInteger(message.packageId))
                                return "packageId: integer expected";
                        if (message.scalingMinKhz != null && message.hasOwnProperty("scalingMinKhz"))
                            if (!$util.isInteger(message.scalingMinKhz) && !(message.scalingMinKhz && $util.isInteger(message.scalingMinKhz.low) && $util.isInteger(message.scalingMinKhz.high)))
                                return "scalingMinKhz: integer|Long expected";
                        if (message.scalingMaxKhz != null && message.hasOwnProperty("scalingMaxKhz"))
                            if (!$util.isInteger(message.scalingMaxKhz) && !(message.scalingMaxKhz && $util.isInteger(message.scalingMaxKhz.low) && $util.isInteger(message.scalingMaxKhz.high)))
                                return "scalingMaxKhz: integer|Long expected";
                        if (message.availableGovernors != null && message.hasOwnProperty("availableGovernors")) {
                            if (!Array.isArray(message.availableGovernors))
                                return "availableGovernors: array expected";
                            for (let i = 0; i < message.availableGovernors.length; ++i)
                                if (!$util.isString(message.availableGovernors[i]))
                                    return "availableGovernors: string[] expected";
                        }
                        if (message.currentGovernor != null && message.hasOwnProperty("currentGovernor"))
                            if (!$util.isString(message.currentGovernor))
                                return "currentGovernor: string expected";
                        if (message.scalingDriver != null && message.hasOwnProperty("scalingDriver"))
                            if (!$util.isString(message.scalingDriver))
                                return "scalingDriver: string expected";
                        if (message.uncoreCurrentKhz != null && message.hasOwnProperty("uncoreCurrentKhz"))
                            if (!$util.isInteger(message.uncoreCurrentKhz) && !(message.uncoreCurrentKhz && $util.isInteger(message.uncoreCurrentKhz.low) && $util.isInteger(message.uncoreCurrentKhz.high)))
                                return "uncoreCurrentKhz: integer|Long expected";
                        if (message.uncoreMinKhz != null && message.hasOwnProperty("uncoreMinKhz"))
                            if (!$util.isInteger(message.uncoreMinKhz) && !(message.uncoreMinKhz && $util.isInteger(message.uncoreMinKhz.low) && $util.isInteger(message.uncoreMinKhz.high)))
                                return "uncoreMinKhz: integer|Long expected";
                        if (message.uncoreMaxKhz != null && message.hasOwnProperty("uncoreMaxKhz"))
                            if (!$util.isInteger(message.uncoreMaxKhz) && !(message.uncoreMaxKhz && $util.isInteger(message.uncoreMaxKhz.low) && $util.isInteger(message.uncoreMaxKhz.high)))
                                return "uncoreMaxKhz: integer|Long expected";
                        if (message.powerCapMicroW != null && message.hasOwnProperty("powerCapMicroW"))
                            if (!$util.isInteger(message.powerCapMicroW) && !(message.powerCapMicroW && $util.isInteger(message.powerCapMicroW.low) && $util.isInteger(message.powerCapMicroW.high)))
                                return "powerCapMicroW: integer|Long expected";
                        if (message.powerCapMinMicroW != null && message.hasOwnProperty("powerCapMinMicroW"))
                            if (!$util.isInteger(message.powerCapMinMicroW) && !(message.powerCapMinMicroW && $util.isInteger(message.powerCapMinMicroW.low) && $util.isInteger(message.powerCapMinMicroW.high)))
                                return "powerCapMinMicroW: integer|Long expected";
                        if (message.powerCapMaxMicroW != null && message.hasOwnProperty("powerCapMaxMicroW"))
                            if (!$util.isInteger(message.powerCapMaxMicroW) && !(message.powerCapMaxMicroW && $util.isInteger(message.powerCapMaxMicroW.low) && $util.isInteger(message.powerCapMaxMicroW.high)))
                                return "powerCapMaxMicroW: integer|Long expected";
                        if (message.scalingHwMinKhz != null && message.hasOwnProperty("scalingHwMinKhz"))
                            if (!$util.isInteger(message.scalingHwMinKhz) && !(message.scalingHwMinKhz && $util.isInteger(message.scalingHwMinKhz.low) && $util.isInteger(message.scalingHwMinKhz.high)))
                                return "scalingHwMinKhz: integer|Long expected";
                        if (message.scalingHwMaxKhz != null && message.hasOwnProperty("scalingHwMaxKhz"))
                            if (!$util.isInteger(message.scalingHwMaxKhz) && !(message.scalingHwMaxKhz && $util.isInteger(message.scalingHwMaxKhz.low) && $util.isInteger(message.scalingHwMaxKhz.high)))
                                return "scalingHwMaxKhz: integer|Long expected";
                        return null;
                    };

                    /**
                     * Creates a PackageControl message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof telemetry.module.cpu.v1.PackageControl
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {telemetry.module.cpu.v1.PackageControl} PackageControl
                     */
                    PackageControl.fromObject = function fromObject(object) {
                        if (object instanceof $root.telemetry.module.cpu.v1.PackageControl)
                            return object;
                        let message = new $root.telemetry.module.cpu.v1.PackageControl();
                        if (object.packageId != null)
                            message.packageId = object.packageId | 0;
                        if (object.scalingMinKhz != null)
                            if ($util.Long)
                                (message.scalingMinKhz = $util.Long.fromValue(object.scalingMinKhz)).unsigned = true;
                            else if (typeof object.scalingMinKhz === "string")
                                message.scalingMinKhz = parseInt(object.scalingMinKhz, 10);
                            else if (typeof object.scalingMinKhz === "number")
                                message.scalingMinKhz = object.scalingMinKhz;
                            else if (typeof object.scalingMinKhz === "object")
                                message.scalingMinKhz = new $util.LongBits(object.scalingMinKhz.low >>> 0, object.scalingMinKhz.high >>> 0).toNumber(true);
                        if (object.scalingMaxKhz != null)
                            if ($util.Long)
                                (message.scalingMaxKhz = $util.Long.fromValue(object.scalingMaxKhz)).unsigned = true;
                            else if (typeof object.scalingMaxKhz === "string")
                                message.scalingMaxKhz = parseInt(object.scalingMaxKhz, 10);
                            else if (typeof object.scalingMaxKhz === "number")
                                message.scalingMaxKhz = object.scalingMaxKhz;
                            else if (typeof object.scalingMaxKhz === "object")
                                message.scalingMaxKhz = new $util.LongBits(object.scalingMaxKhz.low >>> 0, object.scalingMaxKhz.high >>> 0).toNumber(true);
                        if (object.availableGovernors) {
                            if (!Array.isArray(object.availableGovernors))
                                throw TypeError(".telemetry.module.cpu.v1.PackageControl.availableGovernors: array expected");
                            message.availableGovernors = [];
                            for (let i = 0; i < object.availableGovernors.length; ++i)
                                message.availableGovernors[i] = String(object.availableGovernors[i]);
                        }
                        if (object.currentGovernor != null)
                            message.currentGovernor = String(object.currentGovernor);
                        if (object.scalingDriver != null)
                            message.scalingDriver = String(object.scalingDriver);
                        if (object.uncoreCurrentKhz != null)
                            if ($util.Long)
                                (message.uncoreCurrentKhz = $util.Long.fromValue(object.uncoreCurrentKhz)).unsigned = true;
                            else if (typeof object.uncoreCurrentKhz === "string")
                                message.uncoreCurrentKhz = parseInt(object.uncoreCurrentKhz, 10);
                            else if (typeof object.uncoreCurrentKhz === "number")
                                message.uncoreCurrentKhz = object.uncoreCurrentKhz;
                            else if (typeof object.uncoreCurrentKhz === "object")
                                message.uncoreCurrentKhz = new $util.LongBits(object.uncoreCurrentKhz.low >>> 0, object.uncoreCurrentKhz.high >>> 0).toNumber(true);
                        if (object.uncoreMinKhz != null)
                            if ($util.Long)
                                (message.uncoreMinKhz = $util.Long.fromValue(object.uncoreMinKhz)).unsigned = true;
                            else if (typeof object.uncoreMinKhz === "string")
                                message.uncoreMinKhz = parseInt(object.uncoreMinKhz, 10);
                            else if (typeof object.uncoreMinKhz === "number")
                                message.uncoreMinKhz = object.uncoreMinKhz;
                            else if (typeof object.uncoreMinKhz === "object")
                                message.uncoreMinKhz = new $util.LongBits(object.uncoreMinKhz.low >>> 0, object.uncoreMinKhz.high >>> 0).toNumber(true);
                        if (object.uncoreMaxKhz != null)
                            if ($util.Long)
                                (message.uncoreMaxKhz = $util.Long.fromValue(object.uncoreMaxKhz)).unsigned = true;
                            else if (typeof object.uncoreMaxKhz === "string")
                                message.uncoreMaxKhz = parseInt(object.uncoreMaxKhz, 10);
                            else if (typeof object.uncoreMaxKhz === "number")
                                message.uncoreMaxKhz = object.uncoreMaxKhz;
                            else if (typeof object.uncoreMaxKhz === "object")
                                message.uncoreMaxKhz = new $util.LongBits(object.uncoreMaxKhz.low >>> 0, object.uncoreMaxKhz.high >>> 0).toNumber(true);
                        if (object.powerCapMicroW != null)
                            if ($util.Long)
                                (message.powerCapMicroW = $util.Long.fromValue(object.powerCapMicroW)).unsigned = true;
                            else if (typeof object.powerCapMicroW === "string")
                                message.powerCapMicroW = parseInt(object.powerCapMicroW, 10);
                            else if (typeof object.powerCapMicroW === "number")
                                message.powerCapMicroW = object.powerCapMicroW;
                            else if (typeof object.powerCapMicroW === "object")
                                message.powerCapMicroW = new $util.LongBits(object.powerCapMicroW.low >>> 0, object.powerCapMicroW.high >>> 0).toNumber(true);
                        if (object.powerCapMinMicroW != null)
                            if ($util.Long)
                                (message.powerCapMinMicroW = $util.Long.fromValue(object.powerCapMinMicroW)).unsigned = true;
                            else if (typeof object.powerCapMinMicroW === "string")
                                message.powerCapMinMicroW = parseInt(object.powerCapMinMicroW, 10);
                            else if (typeof object.powerCapMinMicroW === "number")
                                message.powerCapMinMicroW = object.powerCapMinMicroW;
                            else if (typeof object.powerCapMinMicroW === "object")
                                message.powerCapMinMicroW = new $util.LongBits(object.powerCapMinMicroW.low >>> 0, object.powerCapMinMicroW.high >>> 0).toNumber(true);
                        if (object.powerCapMaxMicroW != null)
                            if ($util.Long)
                                (message.powerCapMaxMicroW = $util.Long.fromValue(object.powerCapMaxMicroW)).unsigned = true;
                            else if (typeof object.powerCapMaxMicroW === "string")
                                message.powerCapMaxMicroW = parseInt(object.powerCapMaxMicroW, 10);
                            else if (typeof object.powerCapMaxMicroW === "number")
                                message.powerCapMaxMicroW = object.powerCapMaxMicroW;
                            else if (typeof object.powerCapMaxMicroW === "object")
                                message.powerCapMaxMicroW = new $util.LongBits(object.powerCapMaxMicroW.low >>> 0, object.powerCapMaxMicroW.high >>> 0).toNumber(true);
                        if (object.scalingHwMinKhz != null)
                            if ($util.Long)
                                (message.scalingHwMinKhz = $util.Long.fromValue(object.scalingHwMinKhz)).unsigned = true;
                            else if (typeof object.scalingHwMinKhz === "string")
                                message.scalingHwMinKhz = parseInt(object.scalingHwMinKhz, 10);
                            else if (typeof object.scalingHwMinKhz === "number")
                                message.scalingHwMinKhz = object.scalingHwMinKhz;
                            else if (typeof object.scalingHwMinKhz === "object")
                                message.scalingHwMinKhz = new $util.LongBits(object.scalingHwMinKhz.low >>> 0, object.scalingHwMinKhz.high >>> 0).toNumber(true);
                        if (object.scalingHwMaxKhz != null)
                            if ($util.Long)
                                (message.scalingHwMaxKhz = $util.Long.fromValue(object.scalingHwMaxKhz)).unsigned = true;
                            else if (typeof object.scalingHwMaxKhz === "string")
                                message.scalingHwMaxKhz = parseInt(object.scalingHwMaxKhz, 10);
                            else if (typeof object.scalingHwMaxKhz === "number")
                                message.scalingHwMaxKhz = object.scalingHwMaxKhz;
                            else if (typeof object.scalingHwMaxKhz === "object")
                                message.scalingHwMaxKhz = new $util.LongBits(object.scalingHwMaxKhz.low >>> 0, object.scalingHwMaxKhz.high >>> 0).toNumber(true);
                        return message;
                    };

                    /**
                     * Creates a plain object from a PackageControl message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof telemetry.module.cpu.v1.PackageControl
                     * @static
                     * @param {telemetry.module.cpu.v1.PackageControl} message PackageControl
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    PackageControl.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.arrays || options.defaults)
                            object.availableGovernors = [];
                        if (options.defaults) {
                            object.packageId = 0;
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, true);
                                object.scalingMinKhz = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.scalingMinKhz = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, true);
                                object.scalingMaxKhz = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.scalingMaxKhz = options.longs === String ? "0" : 0;
                            object.currentGovernor = "";
                            object.scalingDriver = "";
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, true);
                                object.uncoreCurrentKhz = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.uncoreCurrentKhz = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, true);
                                object.uncoreMinKhz = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.uncoreMinKhz = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, true);
                                object.uncoreMaxKhz = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.uncoreMaxKhz = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, true);
                                object.powerCapMicroW = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.powerCapMicroW = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, true);
                                object.powerCapMinMicroW = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.powerCapMinMicroW = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, true);
                                object.powerCapMaxMicroW = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.powerCapMaxMicroW = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, true);
                                object.scalingHwMinKhz = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.scalingHwMinKhz = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, true);
                                object.scalingHwMaxKhz = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.scalingHwMaxKhz = options.longs === String ? "0" : 0;
                        }
                        if (message.packageId != null && message.hasOwnProperty("packageId"))
                            object.packageId = message.packageId;
                        if (message.scalingMinKhz != null && message.hasOwnProperty("scalingMinKhz"))
                            if (typeof message.scalingMinKhz === "number")
                                object.scalingMinKhz = options.longs === String ? String(message.scalingMinKhz) : message.scalingMinKhz;
                            else
                                object.scalingMinKhz = options.longs === String ? $util.Long.prototype.toString.call(message.scalingMinKhz) : options.longs === Number ? new $util.LongBits(message.scalingMinKhz.low >>> 0, message.scalingMinKhz.high >>> 0).toNumber(true) : message.scalingMinKhz;
                        if (message.scalingMaxKhz != null && message.hasOwnProperty("scalingMaxKhz"))
                            if (typeof message.scalingMaxKhz === "number")
                                object.scalingMaxKhz = options.longs === String ? String(message.scalingMaxKhz) : message.scalingMaxKhz;
                            else
                                object.scalingMaxKhz = options.longs === String ? $util.Long.prototype.toString.call(message.scalingMaxKhz) : options.longs === Number ? new $util.LongBits(message.scalingMaxKhz.low >>> 0, message.scalingMaxKhz.high >>> 0).toNumber(true) : message.scalingMaxKhz;
                        if (message.availableGovernors && message.availableGovernors.length) {
                            object.availableGovernors = [];
                            for (let j = 0; j < message.availableGovernors.length; ++j)
                                object.availableGovernors[j] = message.availableGovernors[j];
                        }
                        if (message.currentGovernor != null && message.hasOwnProperty("currentGovernor"))
                            object.currentGovernor = message.currentGovernor;
                        if (message.scalingDriver != null && message.hasOwnProperty("scalingDriver"))
                            object.scalingDriver = message.scalingDriver;
                        if (message.uncoreCurrentKhz != null && message.hasOwnProperty("uncoreCurrentKhz"))
                            if (typeof message.uncoreCurrentKhz === "number")
                                object.uncoreCurrentKhz = options.longs === String ? String(message.uncoreCurrentKhz) : message.uncoreCurrentKhz;
                            else
                                object.uncoreCurrentKhz = options.longs === String ? $util.Long.prototype.toString.call(message.uncoreCurrentKhz) : options.longs === Number ? new $util.LongBits(message.uncoreCurrentKhz.low >>> 0, message.uncoreCurrentKhz.high >>> 0).toNumber(true) : message.uncoreCurrentKhz;
                        if (message.uncoreMinKhz != null && message.hasOwnProperty("uncoreMinKhz"))
                            if (typeof message.uncoreMinKhz === "number")
                                object.uncoreMinKhz = options.longs === String ? String(message.uncoreMinKhz) : message.uncoreMinKhz;
                            else
                                object.uncoreMinKhz = options.longs === String ? $util.Long.prototype.toString.call(message.uncoreMinKhz) : options.longs === Number ? new $util.LongBits(message.uncoreMinKhz.low >>> 0, message.uncoreMinKhz.high >>> 0).toNumber(true) : message.uncoreMinKhz;
                        if (message.uncoreMaxKhz != null && message.hasOwnProperty("uncoreMaxKhz"))
                            if (typeof message.uncoreMaxKhz === "number")
                                object.uncoreMaxKhz = options.longs === String ? String(message.uncoreMaxKhz) : message.uncoreMaxKhz;
                            else
                                object.uncoreMaxKhz = options.longs === String ? $util.Long.prototype.toString.call(message.uncoreMaxKhz) : options.longs === Number ? new $util.LongBits(message.uncoreMaxKhz.low >>> 0, message.uncoreMaxKhz.high >>> 0).toNumber(true) : message.uncoreMaxKhz;
                        if (message.powerCapMicroW != null && message.hasOwnProperty("powerCapMicroW"))
                            if (typeof message.powerCapMicroW === "number")
                                object.powerCapMicroW = options.longs === String ? String(message.powerCapMicroW) : message.powerCapMicroW;
                            else
                                object.powerCapMicroW = options.longs === String ? $util.Long.prototype.toString.call(message.powerCapMicroW) : options.longs === Number ? new $util.LongBits(message.powerCapMicroW.low >>> 0, message.powerCapMicroW.high >>> 0).toNumber(true) : message.powerCapMicroW;
                        if (message.powerCapMinMicroW != null && message.hasOwnProperty("powerCapMinMicroW"))
                            if (typeof message.powerCapMinMicroW === "number")
                                object.powerCapMinMicroW = options.longs === String ? String(message.powerCapMinMicroW) : message.powerCapMinMicroW;
                            else
                                object.powerCapMinMicroW = options.longs === String ? $util.Long.prototype.toString.call(message.powerCapMinMicroW) : options.longs === Number ? new $util.LongBits(message.powerCapMinMicroW.low >>> 0, message.powerCapMinMicroW.high >>> 0).toNumber(true) : message.powerCapMinMicroW;
                        if (message.powerCapMaxMicroW != null && message.hasOwnProperty("powerCapMaxMicroW"))
                            if (typeof message.powerCapMaxMicroW === "number")
                                object.powerCapMaxMicroW = options.longs === String ? String(message.powerCapMaxMicroW) : message.powerCapMaxMicroW;
                            else
                                object.powerCapMaxMicroW = options.longs === String ? $util.Long.prototype.toString.call(message.powerCapMaxMicroW) : options.longs === Number ? new $util.LongBits(message.powerCapMaxMicroW.low >>> 0, message.powerCapMaxMicroW.high >>> 0).toNumber(true) : message.powerCapMaxMicroW;
                        if (message.scalingHwMinKhz != null && message.hasOwnProperty("scalingHwMinKhz"))
                            if (typeof message.scalingHwMinKhz === "number")
                                object.scalingHwMinKhz = options.longs === String ? String(message.scalingHwMinKhz) : message.scalingHwMinKhz;
                            else
                                object.scalingHwMinKhz = options.longs === String ? $util.Long.prototype.toString.call(message.scalingHwMinKhz) : options.longs === Number ? new $util.LongBits(message.scalingHwMinKhz.low >>> 0, message.scalingHwMinKhz.high >>> 0).toNumber(true) : message.scalingHwMinKhz;
                        if (message.scalingHwMaxKhz != null && message.hasOwnProperty("scalingHwMaxKhz"))
                            if (typeof message.scalingHwMaxKhz === "number")
                                object.scalingHwMaxKhz = options.longs === String ? String(message.scalingHwMaxKhz) : message.scalingHwMaxKhz;
                            else
                                object.scalingHwMaxKhz = options.longs === String ? $util.Long.prototype.toString.call(message.scalingHwMaxKhz) : options.longs === Number ? new $util.LongBits(message.scalingHwMaxKhz.low >>> 0, message.scalingHwMaxKhz.high >>> 0).toNumber(true) : message.scalingHwMaxKhz;
                        return object;
                    };

                    /**
                     * Converts this PackageControl to JSON.
                     * @function toJSON
                     * @memberof telemetry.module.cpu.v1.PackageControl
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    PackageControl.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Gets the default type url for PackageControl
                     * @function getTypeUrl
                     * @memberof telemetry.module.cpu.v1.PackageControl
                     * @static
                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                     * @returns {string} The default type url
                     */
                    PackageControl.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                        if (typeUrlPrefix === undefined) {
                            typeUrlPrefix = "type.googleapis.com";
                        }
                        return typeUrlPrefix + "/telemetry.module.cpu.v1.PackageControl";
                    };

                    return PackageControl;
                })();

                v1.CoreFastMetrics = (function() {

                    /**
                     * Properties of a CoreFastMetrics.
                     * @memberof telemetry.module.cpu.v1
                     * @interface ICoreFastMetrics
                     * @property {number|null} [coreId] CoreFastMetrics coreId
                     * @property {number|null} [utilization] CoreFastMetrics utilization
                     * @property {number|Long|null} [scalingCurKhz] CoreFastMetrics scalingCurKhz
                     * @property {number|null} [packageId] CoreFastMetrics packageId
                     * @property {number|Long|null} [sampledAtUnixNano] CoreFastMetrics sampledAtUnixNano
                     */

                    /**
                     * Constructs a new CoreFastMetrics.
                     * @memberof telemetry.module.cpu.v1
                     * @classdesc Represents a CoreFastMetrics.
                     * @implements ICoreFastMetrics
                     * @constructor
                     * @param {telemetry.module.cpu.v1.ICoreFastMetrics=} [properties] Properties to set
                     */
                    function CoreFastMetrics(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * CoreFastMetrics coreId.
                     * @member {number} coreId
                     * @memberof telemetry.module.cpu.v1.CoreFastMetrics
                     * @instance
                     */
                    CoreFastMetrics.prototype.coreId = 0;

                    /**
                     * CoreFastMetrics utilization.
                     * @member {number} utilization
                     * @memberof telemetry.module.cpu.v1.CoreFastMetrics
                     * @instance
                     */
                    CoreFastMetrics.prototype.utilization = 0;

                    /**
                     * CoreFastMetrics scalingCurKhz.
                     * @member {number|Long} scalingCurKhz
                     * @memberof telemetry.module.cpu.v1.CoreFastMetrics
                     * @instance
                     */
                    CoreFastMetrics.prototype.scalingCurKhz = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                    /**
                     * CoreFastMetrics packageId.
                     * @member {number} packageId
                     * @memberof telemetry.module.cpu.v1.CoreFastMetrics
                     * @instance
                     */
                    CoreFastMetrics.prototype.packageId = 0;

                    /**
                     * CoreFastMetrics sampledAtUnixNano.
                     * @member {number|Long} sampledAtUnixNano
                     * @memberof telemetry.module.cpu.v1.CoreFastMetrics
                     * @instance
                     */
                    CoreFastMetrics.prototype.sampledAtUnixNano = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                    /**
                     * Creates a new CoreFastMetrics instance using the specified properties.
                     * @function create
                     * @memberof telemetry.module.cpu.v1.CoreFastMetrics
                     * @static
                     * @param {telemetry.module.cpu.v1.ICoreFastMetrics=} [properties] Properties to set
                     * @returns {telemetry.module.cpu.v1.CoreFastMetrics} CoreFastMetrics instance
                     */
                    CoreFastMetrics.create = function create(properties) {
                        return new CoreFastMetrics(properties);
                    };

                    /**
                     * Encodes the specified CoreFastMetrics message. Does not implicitly {@link telemetry.module.cpu.v1.CoreFastMetrics.verify|verify} messages.
                     * @function encode
                     * @memberof telemetry.module.cpu.v1.CoreFastMetrics
                     * @static
                     * @param {telemetry.module.cpu.v1.ICoreFastMetrics} message CoreFastMetrics message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    CoreFastMetrics.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.coreId != null && Object.hasOwnProperty.call(message, "coreId"))
                            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.coreId);
                        if (message.utilization != null && Object.hasOwnProperty.call(message, "utilization"))
                            writer.uint32(/* id 2, wireType 1 =*/17).double(message.utilization);
                        if (message.scalingCurKhz != null && Object.hasOwnProperty.call(message, "scalingCurKhz"))
                            writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.scalingCurKhz);
                        if (message.packageId != null && Object.hasOwnProperty.call(message, "packageId"))
                            writer.uint32(/* id 4, wireType 0 =*/32).int32(message.packageId);
                        if (message.sampledAtUnixNano != null && Object.hasOwnProperty.call(message, "sampledAtUnixNano"))
                            writer.uint32(/* id 5, wireType 0 =*/40).int64(message.sampledAtUnixNano);
                        return writer;
                    };

                    /**
                     * Encodes the specified CoreFastMetrics message, length delimited. Does not implicitly {@link telemetry.module.cpu.v1.CoreFastMetrics.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof telemetry.module.cpu.v1.CoreFastMetrics
                     * @static
                     * @param {telemetry.module.cpu.v1.ICoreFastMetrics} message CoreFastMetrics message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    CoreFastMetrics.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a CoreFastMetrics message from the specified reader or buffer.
                     * @function decode
                     * @memberof telemetry.module.cpu.v1.CoreFastMetrics
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {telemetry.module.cpu.v1.CoreFastMetrics} CoreFastMetrics
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    CoreFastMetrics.decode = function decode(reader, length, error) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.telemetry.module.cpu.v1.CoreFastMetrics();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            if (tag === error)
                                break;
                            switch (tag >>> 3) {
                            case 1: {
                                    message.coreId = reader.int32();
                                    break;
                                }
                            case 2: {
                                    message.utilization = reader.double();
                                    break;
                                }
                            case 3: {
                                    message.scalingCurKhz = reader.uint64();
                                    break;
                                }
                            case 4: {
                                    message.packageId = reader.int32();
                                    break;
                                }
                            case 5: {
                                    message.sampledAtUnixNano = reader.int64();
                                    break;
                                }
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a CoreFastMetrics message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof telemetry.module.cpu.v1.CoreFastMetrics
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {telemetry.module.cpu.v1.CoreFastMetrics} CoreFastMetrics
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    CoreFastMetrics.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a CoreFastMetrics message.
                     * @function verify
                     * @memberof telemetry.module.cpu.v1.CoreFastMetrics
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    CoreFastMetrics.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.coreId != null && message.hasOwnProperty("coreId"))
                            if (!$util.isInteger(message.coreId))
                                return "coreId: integer expected";
                        if (message.utilization != null && message.hasOwnProperty("utilization"))
                            if (typeof message.utilization !== "number")
                                return "utilization: number expected";
                        if (message.scalingCurKhz != null && message.hasOwnProperty("scalingCurKhz"))
                            if (!$util.isInteger(message.scalingCurKhz) && !(message.scalingCurKhz && $util.isInteger(message.scalingCurKhz.low) && $util.isInteger(message.scalingCurKhz.high)))
                                return "scalingCurKhz: integer|Long expected";
                        if (message.packageId != null && message.hasOwnProperty("packageId"))
                            if (!$util.isInteger(message.packageId))
                                return "packageId: integer expected";
                        if (message.sampledAtUnixNano != null && message.hasOwnProperty("sampledAtUnixNano"))
                            if (!$util.isInteger(message.sampledAtUnixNano) && !(message.sampledAtUnixNano && $util.isInteger(message.sampledAtUnixNano.low) && $util.isInteger(message.sampledAtUnixNano.high)))
                                return "sampledAtUnixNano: integer|Long expected";
                        return null;
                    };

                    /**
                     * Creates a CoreFastMetrics message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof telemetry.module.cpu.v1.CoreFastMetrics
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {telemetry.module.cpu.v1.CoreFastMetrics} CoreFastMetrics
                     */
                    CoreFastMetrics.fromObject = function fromObject(object) {
                        if (object instanceof $root.telemetry.module.cpu.v1.CoreFastMetrics)
                            return object;
                        let message = new $root.telemetry.module.cpu.v1.CoreFastMetrics();
                        if (object.coreId != null)
                            message.coreId = object.coreId | 0;
                        if (object.utilization != null)
                            message.utilization = Number(object.utilization);
                        if (object.scalingCurKhz != null)
                            if ($util.Long)
                                (message.scalingCurKhz = $util.Long.fromValue(object.scalingCurKhz)).unsigned = true;
                            else if (typeof object.scalingCurKhz === "string")
                                message.scalingCurKhz = parseInt(object.scalingCurKhz, 10);
                            else if (typeof object.scalingCurKhz === "number")
                                message.scalingCurKhz = object.scalingCurKhz;
                            else if (typeof object.scalingCurKhz === "object")
                                message.scalingCurKhz = new $util.LongBits(object.scalingCurKhz.low >>> 0, object.scalingCurKhz.high >>> 0).toNumber(true);
                        if (object.packageId != null)
                            message.packageId = object.packageId | 0;
                        if (object.sampledAtUnixNano != null)
                            if ($util.Long)
                                (message.sampledAtUnixNano = $util.Long.fromValue(object.sampledAtUnixNano)).unsigned = false;
                            else if (typeof object.sampledAtUnixNano === "string")
                                message.sampledAtUnixNano = parseInt(object.sampledAtUnixNano, 10);
                            else if (typeof object.sampledAtUnixNano === "number")
                                message.sampledAtUnixNano = object.sampledAtUnixNano;
                            else if (typeof object.sampledAtUnixNano === "object")
                                message.sampledAtUnixNano = new $util.LongBits(object.sampledAtUnixNano.low >>> 0, object.sampledAtUnixNano.high >>> 0).toNumber();
                        return message;
                    };

                    /**
                     * Creates a plain object from a CoreFastMetrics message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof telemetry.module.cpu.v1.CoreFastMetrics
                     * @static
                     * @param {telemetry.module.cpu.v1.CoreFastMetrics} message CoreFastMetrics
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    CoreFastMetrics.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.coreId = 0;
                            object.utilization = 0;
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, true);
                                object.scalingCurKhz = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.scalingCurKhz = options.longs === String ? "0" : 0;
                            object.packageId = 0;
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, false);
                                object.sampledAtUnixNano = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.sampledAtUnixNano = options.longs === String ? "0" : 0;
                        }
                        if (message.coreId != null && message.hasOwnProperty("coreId"))
                            object.coreId = message.coreId;
                        if (message.utilization != null && message.hasOwnProperty("utilization"))
                            object.utilization = options.json && !isFinite(message.utilization) ? String(message.utilization) : message.utilization;
                        if (message.scalingCurKhz != null && message.hasOwnProperty("scalingCurKhz"))
                            if (typeof message.scalingCurKhz === "number")
                                object.scalingCurKhz = options.longs === String ? String(message.scalingCurKhz) : message.scalingCurKhz;
                            else
                                object.scalingCurKhz = options.longs === String ? $util.Long.prototype.toString.call(message.scalingCurKhz) : options.longs === Number ? new $util.LongBits(message.scalingCurKhz.low >>> 0, message.scalingCurKhz.high >>> 0).toNumber(true) : message.scalingCurKhz;
                        if (message.packageId != null && message.hasOwnProperty("packageId"))
                            object.packageId = message.packageId;
                        if (message.sampledAtUnixNano != null && message.hasOwnProperty("sampledAtUnixNano"))
                            if (typeof message.sampledAtUnixNano === "number")
                                object.sampledAtUnixNano = options.longs === String ? String(message.sampledAtUnixNano) : message.sampledAtUnixNano;
                            else
                                object.sampledAtUnixNano = options.longs === String ? $util.Long.prototype.toString.call(message.sampledAtUnixNano) : options.longs === Number ? new $util.LongBits(message.sampledAtUnixNano.low >>> 0, message.sampledAtUnixNano.high >>> 0).toNumber() : message.sampledAtUnixNano;
                        return object;
                    };

                    /**
                     * Converts this CoreFastMetrics to JSON.
                     * @function toJSON
                     * @memberof telemetry.module.cpu.v1.CoreFastMetrics
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    CoreFastMetrics.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Gets the default type url for CoreFastMetrics
                     * @function getTypeUrl
                     * @memberof telemetry.module.cpu.v1.CoreFastMetrics
                     * @static
                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                     * @returns {string} The default type url
                     */
                    CoreFastMetrics.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                        if (typeUrlPrefix === undefined) {
                            typeUrlPrefix = "type.googleapis.com";
                        }
                        return typeUrlPrefix + "/telemetry.module.cpu.v1.CoreFastMetrics";
                    };

                    return CoreFastMetrics;
                })();

                v1.PackageRAPL = (function() {

                    /**
                     * Properties of a PackageRAPL.
                     * @memberof telemetry.module.cpu.v1
                     * @interface IPackageRAPL
                     * @property {number|null} [packageId] PackageRAPL packageId
                     * @property {number|Long|null} [energyMicroJ] PackageRAPL energyMicroJ
                     * @property {number|Long|null} [powerCapMicroW] PackageRAPL powerCapMicroW
                     * @property {number|Long|null} [sampledAtUnixNano] PackageRAPL sampledAtUnixNano
                     */

                    /**
                     * Constructs a new PackageRAPL.
                     * @memberof telemetry.module.cpu.v1
                     * @classdesc Represents a PackageRAPL.
                     * @implements IPackageRAPL
                     * @constructor
                     * @param {telemetry.module.cpu.v1.IPackageRAPL=} [properties] Properties to set
                     */
                    function PackageRAPL(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * PackageRAPL packageId.
                     * @member {number} packageId
                     * @memberof telemetry.module.cpu.v1.PackageRAPL
                     * @instance
                     */
                    PackageRAPL.prototype.packageId = 0;

                    /**
                     * PackageRAPL energyMicroJ.
                     * @member {number|Long} energyMicroJ
                     * @memberof telemetry.module.cpu.v1.PackageRAPL
                     * @instance
                     */
                    PackageRAPL.prototype.energyMicroJ = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                    /**
                     * PackageRAPL powerCapMicroW.
                     * @member {number|Long} powerCapMicroW
                     * @memberof telemetry.module.cpu.v1.PackageRAPL
                     * @instance
                     */
                    PackageRAPL.prototype.powerCapMicroW = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                    /**
                     * PackageRAPL sampledAtUnixNano.
                     * @member {number|Long} sampledAtUnixNano
                     * @memberof telemetry.module.cpu.v1.PackageRAPL
                     * @instance
                     */
                    PackageRAPL.prototype.sampledAtUnixNano = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                    /**
                     * Creates a new PackageRAPL instance using the specified properties.
                     * @function create
                     * @memberof telemetry.module.cpu.v1.PackageRAPL
                     * @static
                     * @param {telemetry.module.cpu.v1.IPackageRAPL=} [properties] Properties to set
                     * @returns {telemetry.module.cpu.v1.PackageRAPL} PackageRAPL instance
                     */
                    PackageRAPL.create = function create(properties) {
                        return new PackageRAPL(properties);
                    };

                    /**
                     * Encodes the specified PackageRAPL message. Does not implicitly {@link telemetry.module.cpu.v1.PackageRAPL.verify|verify} messages.
                     * @function encode
                     * @memberof telemetry.module.cpu.v1.PackageRAPL
                     * @static
                     * @param {telemetry.module.cpu.v1.IPackageRAPL} message PackageRAPL message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    PackageRAPL.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.packageId != null && Object.hasOwnProperty.call(message, "packageId"))
                            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.packageId);
                        if (message.energyMicroJ != null && Object.hasOwnProperty.call(message, "energyMicroJ"))
                            writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.energyMicroJ);
                        if (message.powerCapMicroW != null && Object.hasOwnProperty.call(message, "powerCapMicroW"))
                            writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.powerCapMicroW);
                        if (message.sampledAtUnixNano != null && Object.hasOwnProperty.call(message, "sampledAtUnixNano"))
                            writer.uint32(/* id 4, wireType 0 =*/32).int64(message.sampledAtUnixNano);
                        return writer;
                    };

                    /**
                     * Encodes the specified PackageRAPL message, length delimited. Does not implicitly {@link telemetry.module.cpu.v1.PackageRAPL.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof telemetry.module.cpu.v1.PackageRAPL
                     * @static
                     * @param {telemetry.module.cpu.v1.IPackageRAPL} message PackageRAPL message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    PackageRAPL.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a PackageRAPL message from the specified reader or buffer.
                     * @function decode
                     * @memberof telemetry.module.cpu.v1.PackageRAPL
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {telemetry.module.cpu.v1.PackageRAPL} PackageRAPL
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    PackageRAPL.decode = function decode(reader, length, error) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.telemetry.module.cpu.v1.PackageRAPL();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            if (tag === error)
                                break;
                            switch (tag >>> 3) {
                            case 1: {
                                    message.packageId = reader.int32();
                                    break;
                                }
                            case 2: {
                                    message.energyMicroJ = reader.uint64();
                                    break;
                                }
                            case 3: {
                                    message.powerCapMicroW = reader.uint64();
                                    break;
                                }
                            case 4: {
                                    message.sampledAtUnixNano = reader.int64();
                                    break;
                                }
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a PackageRAPL message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof telemetry.module.cpu.v1.PackageRAPL
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {telemetry.module.cpu.v1.PackageRAPL} PackageRAPL
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    PackageRAPL.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a PackageRAPL message.
                     * @function verify
                     * @memberof telemetry.module.cpu.v1.PackageRAPL
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    PackageRAPL.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.packageId != null && message.hasOwnProperty("packageId"))
                            if (!$util.isInteger(message.packageId))
                                return "packageId: integer expected";
                        if (message.energyMicroJ != null && message.hasOwnProperty("energyMicroJ"))
                            if (!$util.isInteger(message.energyMicroJ) && !(message.energyMicroJ && $util.isInteger(message.energyMicroJ.low) && $util.isInteger(message.energyMicroJ.high)))
                                return "energyMicroJ: integer|Long expected";
                        if (message.powerCapMicroW != null && message.hasOwnProperty("powerCapMicroW"))
                            if (!$util.isInteger(message.powerCapMicroW) && !(message.powerCapMicroW && $util.isInteger(message.powerCapMicroW.low) && $util.isInteger(message.powerCapMicroW.high)))
                                return "powerCapMicroW: integer|Long expected";
                        if (message.sampledAtUnixNano != null && message.hasOwnProperty("sampledAtUnixNano"))
                            if (!$util.isInteger(message.sampledAtUnixNano) && !(message.sampledAtUnixNano && $util.isInteger(message.sampledAtUnixNano.low) && $util.isInteger(message.sampledAtUnixNano.high)))
                                return "sampledAtUnixNano: integer|Long expected";
                        return null;
                    };

                    /**
                     * Creates a PackageRAPL message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof telemetry.module.cpu.v1.PackageRAPL
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {telemetry.module.cpu.v1.PackageRAPL} PackageRAPL
                     */
                    PackageRAPL.fromObject = function fromObject(object) {
                        if (object instanceof $root.telemetry.module.cpu.v1.PackageRAPL)
                            return object;
                        let message = new $root.telemetry.module.cpu.v1.PackageRAPL();
                        if (object.packageId != null)
                            message.packageId = object.packageId | 0;
                        if (object.energyMicroJ != null)
                            if ($util.Long)
                                (message.energyMicroJ = $util.Long.fromValue(object.energyMicroJ)).unsigned = true;
                            else if (typeof object.energyMicroJ === "string")
                                message.energyMicroJ = parseInt(object.energyMicroJ, 10);
                            else if (typeof object.energyMicroJ === "number")
                                message.energyMicroJ = object.energyMicroJ;
                            else if (typeof object.energyMicroJ === "object")
                                message.energyMicroJ = new $util.LongBits(object.energyMicroJ.low >>> 0, object.energyMicroJ.high >>> 0).toNumber(true);
                        if (object.powerCapMicroW != null)
                            if ($util.Long)
                                (message.powerCapMicroW = $util.Long.fromValue(object.powerCapMicroW)).unsigned = true;
                            else if (typeof object.powerCapMicroW === "string")
                                message.powerCapMicroW = parseInt(object.powerCapMicroW, 10);
                            else if (typeof object.powerCapMicroW === "number")
                                message.powerCapMicroW = object.powerCapMicroW;
                            else if (typeof object.powerCapMicroW === "object")
                                message.powerCapMicroW = new $util.LongBits(object.powerCapMicroW.low >>> 0, object.powerCapMicroW.high >>> 0).toNumber(true);
                        if (object.sampledAtUnixNano != null)
                            if ($util.Long)
                                (message.sampledAtUnixNano = $util.Long.fromValue(object.sampledAtUnixNano)).unsigned = false;
                            else if (typeof object.sampledAtUnixNano === "string")
                                message.sampledAtUnixNano = parseInt(object.sampledAtUnixNano, 10);
                            else if (typeof object.sampledAtUnixNano === "number")
                                message.sampledAtUnixNano = object.sampledAtUnixNano;
                            else if (typeof object.sampledAtUnixNano === "object")
                                message.sampledAtUnixNano = new $util.LongBits(object.sampledAtUnixNano.low >>> 0, object.sampledAtUnixNano.high >>> 0).toNumber();
                        return message;
                    };

                    /**
                     * Creates a plain object from a PackageRAPL message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof telemetry.module.cpu.v1.PackageRAPL
                     * @static
                     * @param {telemetry.module.cpu.v1.PackageRAPL} message PackageRAPL
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    PackageRAPL.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.packageId = 0;
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, true);
                                object.energyMicroJ = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.energyMicroJ = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, true);
                                object.powerCapMicroW = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.powerCapMicroW = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, false);
                                object.sampledAtUnixNano = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.sampledAtUnixNano = options.longs === String ? "0" : 0;
                        }
                        if (message.packageId != null && message.hasOwnProperty("packageId"))
                            object.packageId = message.packageId;
                        if (message.energyMicroJ != null && message.hasOwnProperty("energyMicroJ"))
                            if (typeof message.energyMicroJ === "number")
                                object.energyMicroJ = options.longs === String ? String(message.energyMicroJ) : message.energyMicroJ;
                            else
                                object.energyMicroJ = options.longs === String ? $util.Long.prototype.toString.call(message.energyMicroJ) : options.longs === Number ? new $util.LongBits(message.energyMicroJ.low >>> 0, message.energyMicroJ.high >>> 0).toNumber(true) : message.energyMicroJ;
                        if (message.powerCapMicroW != null && message.hasOwnProperty("powerCapMicroW"))
                            if (typeof message.powerCapMicroW === "number")
                                object.powerCapMicroW = options.longs === String ? String(message.powerCapMicroW) : message.powerCapMicroW;
                            else
                                object.powerCapMicroW = options.longs === String ? $util.Long.prototype.toString.call(message.powerCapMicroW) : options.longs === Number ? new $util.LongBits(message.powerCapMicroW.low >>> 0, message.powerCapMicroW.high >>> 0).toNumber(true) : message.powerCapMicroW;
                        if (message.sampledAtUnixNano != null && message.hasOwnProperty("sampledAtUnixNano"))
                            if (typeof message.sampledAtUnixNano === "number")
                                object.sampledAtUnixNano = options.longs === String ? String(message.sampledAtUnixNano) : message.sampledAtUnixNano;
                            else
                                object.sampledAtUnixNano = options.longs === String ? $util.Long.prototype.toString.call(message.sampledAtUnixNano) : options.longs === Number ? new $util.LongBits(message.sampledAtUnixNano.low >>> 0, message.sampledAtUnixNano.high >>> 0).toNumber() : message.sampledAtUnixNano;
                        return object;
                    };

                    /**
                     * Converts this PackageRAPL to JSON.
                     * @function toJSON
                     * @memberof telemetry.module.cpu.v1.PackageRAPL
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    PackageRAPL.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Gets the default type url for PackageRAPL
                     * @function getTypeUrl
                     * @memberof telemetry.module.cpu.v1.PackageRAPL
                     * @static
                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                     * @returns {string} The default type url
                     */
                    PackageRAPL.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                        if (typeUrlPrefix === undefined) {
                            typeUrlPrefix = "type.googleapis.com";
                        }
                        return typeUrlPrefix + "/telemetry.module.cpu.v1.PackageRAPL";
                    };

                    return PackageRAPL;
                })();

                v1.PackageTemperature = (function() {

                    /**
                     * Properties of a PackageTemperature.
                     * @memberof telemetry.module.cpu.v1
                     * @interface IPackageTemperature
                     * @property {number|null} [packageId] PackageTemperature packageId
                     * @property {number|null} [milliC] PackageTemperature milliC
                     * @property {number|Long|null} [sampledAtUnixNano] PackageTemperature sampledAtUnixNano
                     */

                    /**
                     * Constructs a new PackageTemperature.
                     * @memberof telemetry.module.cpu.v1
                     * @classdesc Represents a PackageTemperature.
                     * @implements IPackageTemperature
                     * @constructor
                     * @param {telemetry.module.cpu.v1.IPackageTemperature=} [properties] Properties to set
                     */
                    function PackageTemperature(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * PackageTemperature packageId.
                     * @member {number} packageId
                     * @memberof telemetry.module.cpu.v1.PackageTemperature
                     * @instance
                     */
                    PackageTemperature.prototype.packageId = 0;

                    /**
                     * PackageTemperature milliC.
                     * @member {number} milliC
                     * @memberof telemetry.module.cpu.v1.PackageTemperature
                     * @instance
                     */
                    PackageTemperature.prototype.milliC = 0;

                    /**
                     * PackageTemperature sampledAtUnixNano.
                     * @member {number|Long} sampledAtUnixNano
                     * @memberof telemetry.module.cpu.v1.PackageTemperature
                     * @instance
                     */
                    PackageTemperature.prototype.sampledAtUnixNano = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                    /**
                     * Creates a new PackageTemperature instance using the specified properties.
                     * @function create
                     * @memberof telemetry.module.cpu.v1.PackageTemperature
                     * @static
                     * @param {telemetry.module.cpu.v1.IPackageTemperature=} [properties] Properties to set
                     * @returns {telemetry.module.cpu.v1.PackageTemperature} PackageTemperature instance
                     */
                    PackageTemperature.create = function create(properties) {
                        return new PackageTemperature(properties);
                    };

                    /**
                     * Encodes the specified PackageTemperature message. Does not implicitly {@link telemetry.module.cpu.v1.PackageTemperature.verify|verify} messages.
                     * @function encode
                     * @memberof telemetry.module.cpu.v1.PackageTemperature
                     * @static
                     * @param {telemetry.module.cpu.v1.IPackageTemperature} message PackageTemperature message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    PackageTemperature.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.packageId != null && Object.hasOwnProperty.call(message, "packageId"))
                            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.packageId);
                        if (message.milliC != null && Object.hasOwnProperty.call(message, "milliC"))
                            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.milliC);
                        if (message.sampledAtUnixNano != null && Object.hasOwnProperty.call(message, "sampledAtUnixNano"))
                            writer.uint32(/* id 3, wireType 0 =*/24).int64(message.sampledAtUnixNano);
                        return writer;
                    };

                    /**
                     * Encodes the specified PackageTemperature message, length delimited. Does not implicitly {@link telemetry.module.cpu.v1.PackageTemperature.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof telemetry.module.cpu.v1.PackageTemperature
                     * @static
                     * @param {telemetry.module.cpu.v1.IPackageTemperature} message PackageTemperature message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    PackageTemperature.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a PackageTemperature message from the specified reader or buffer.
                     * @function decode
                     * @memberof telemetry.module.cpu.v1.PackageTemperature
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {telemetry.module.cpu.v1.PackageTemperature} PackageTemperature
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    PackageTemperature.decode = function decode(reader, length, error) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.telemetry.module.cpu.v1.PackageTemperature();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            if (tag === error)
                                break;
                            switch (tag >>> 3) {
                            case 1: {
                                    message.packageId = reader.int32();
                                    break;
                                }
                            case 2: {
                                    message.milliC = reader.uint32();
                                    break;
                                }
                            case 3: {
                                    message.sampledAtUnixNano = reader.int64();
                                    break;
                                }
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a PackageTemperature message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof telemetry.module.cpu.v1.PackageTemperature
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {telemetry.module.cpu.v1.PackageTemperature} PackageTemperature
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    PackageTemperature.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a PackageTemperature message.
                     * @function verify
                     * @memberof telemetry.module.cpu.v1.PackageTemperature
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    PackageTemperature.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.packageId != null && message.hasOwnProperty("packageId"))
                            if (!$util.isInteger(message.packageId))
                                return "packageId: integer expected";
                        if (message.milliC != null && message.hasOwnProperty("milliC"))
                            if (!$util.isInteger(message.milliC))
                                return "milliC: integer expected";
                        if (message.sampledAtUnixNano != null && message.hasOwnProperty("sampledAtUnixNano"))
                            if (!$util.isInteger(message.sampledAtUnixNano) && !(message.sampledAtUnixNano && $util.isInteger(message.sampledAtUnixNano.low) && $util.isInteger(message.sampledAtUnixNano.high)))
                                return "sampledAtUnixNano: integer|Long expected";
                        return null;
                    };

                    /**
                     * Creates a PackageTemperature message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof telemetry.module.cpu.v1.PackageTemperature
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {telemetry.module.cpu.v1.PackageTemperature} PackageTemperature
                     */
                    PackageTemperature.fromObject = function fromObject(object) {
                        if (object instanceof $root.telemetry.module.cpu.v1.PackageTemperature)
                            return object;
                        let message = new $root.telemetry.module.cpu.v1.PackageTemperature();
                        if (object.packageId != null)
                            message.packageId = object.packageId | 0;
                        if (object.milliC != null)
                            message.milliC = object.milliC >>> 0;
                        if (object.sampledAtUnixNano != null)
                            if ($util.Long)
                                (message.sampledAtUnixNano = $util.Long.fromValue(object.sampledAtUnixNano)).unsigned = false;
                            else if (typeof object.sampledAtUnixNano === "string")
                                message.sampledAtUnixNano = parseInt(object.sampledAtUnixNano, 10);
                            else if (typeof object.sampledAtUnixNano === "number")
                                message.sampledAtUnixNano = object.sampledAtUnixNano;
                            else if (typeof object.sampledAtUnixNano === "object")
                                message.sampledAtUnixNano = new $util.LongBits(object.sampledAtUnixNano.low >>> 0, object.sampledAtUnixNano.high >>> 0).toNumber();
                        return message;
                    };

                    /**
                     * Creates a plain object from a PackageTemperature message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof telemetry.module.cpu.v1.PackageTemperature
                     * @static
                     * @param {telemetry.module.cpu.v1.PackageTemperature} message PackageTemperature
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    PackageTemperature.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.packageId = 0;
                            object.milliC = 0;
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, false);
                                object.sampledAtUnixNano = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.sampledAtUnixNano = options.longs === String ? "0" : 0;
                        }
                        if (message.packageId != null && message.hasOwnProperty("packageId"))
                            object.packageId = message.packageId;
                        if (message.milliC != null && message.hasOwnProperty("milliC"))
                            object.milliC = message.milliC;
                        if (message.sampledAtUnixNano != null && message.hasOwnProperty("sampledAtUnixNano"))
                            if (typeof message.sampledAtUnixNano === "number")
                                object.sampledAtUnixNano = options.longs === String ? String(message.sampledAtUnixNano) : message.sampledAtUnixNano;
                            else
                                object.sampledAtUnixNano = options.longs === String ? $util.Long.prototype.toString.call(message.sampledAtUnixNano) : options.longs === Number ? new $util.LongBits(message.sampledAtUnixNano.low >>> 0, message.sampledAtUnixNano.high >>> 0).toNumber() : message.sampledAtUnixNano;
                        return object;
                    };

                    /**
                     * Converts this PackageTemperature to JSON.
                     * @function toJSON
                     * @memberof telemetry.module.cpu.v1.PackageTemperature
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    PackageTemperature.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Gets the default type url for PackageTemperature
                     * @function getTypeUrl
                     * @memberof telemetry.module.cpu.v1.PackageTemperature
                     * @static
                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                     * @returns {string} The default type url
                     */
                    PackageTemperature.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                        if (typeUrlPrefix === undefined) {
                            typeUrlPrefix = "type.googleapis.com";
                        }
                        return typeUrlPrefix + "/telemetry.module.cpu.v1.PackageTemperature";
                    };

                    return PackageTemperature;
                })();

                v1.MediumMetrics = (function() {

                    /**
                     * Properties of a MediumMetrics.
                     * @memberof telemetry.module.cpu.v1
                     * @interface IMediumMetrics
                     * @property {Array.<telemetry.module.cpu.v1.ICoreFastMetrics>|null} [cores] MediumMetrics cores
                     * @property {Array.<telemetry.module.cpu.v1.IPackageTemperature>|null} [temperatures] MediumMetrics temperatures
                     */

                    /**
                     * Constructs a new MediumMetrics.
                     * @memberof telemetry.module.cpu.v1
                     * @classdesc Represents a MediumMetrics.
                     * @implements IMediumMetrics
                     * @constructor
                     * @param {telemetry.module.cpu.v1.IMediumMetrics=} [properties] Properties to set
                     */
                    function MediumMetrics(properties) {
                        this.cores = [];
                        this.temperatures = [];
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * MediumMetrics cores.
                     * @member {Array.<telemetry.module.cpu.v1.ICoreFastMetrics>} cores
                     * @memberof telemetry.module.cpu.v1.MediumMetrics
                     * @instance
                     */
                    MediumMetrics.prototype.cores = $util.emptyArray;

                    /**
                     * MediumMetrics temperatures.
                     * @member {Array.<telemetry.module.cpu.v1.IPackageTemperature>} temperatures
                     * @memberof telemetry.module.cpu.v1.MediumMetrics
                     * @instance
                     */
                    MediumMetrics.prototype.temperatures = $util.emptyArray;

                    /**
                     * Creates a new MediumMetrics instance using the specified properties.
                     * @function create
                     * @memberof telemetry.module.cpu.v1.MediumMetrics
                     * @static
                     * @param {telemetry.module.cpu.v1.IMediumMetrics=} [properties] Properties to set
                     * @returns {telemetry.module.cpu.v1.MediumMetrics} MediumMetrics instance
                     */
                    MediumMetrics.create = function create(properties) {
                        return new MediumMetrics(properties);
                    };

                    /**
                     * Encodes the specified MediumMetrics message. Does not implicitly {@link telemetry.module.cpu.v1.MediumMetrics.verify|verify} messages.
                     * @function encode
                     * @memberof telemetry.module.cpu.v1.MediumMetrics
                     * @static
                     * @param {telemetry.module.cpu.v1.IMediumMetrics} message MediumMetrics message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    MediumMetrics.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.cores != null && message.cores.length)
                            for (let i = 0; i < message.cores.length; ++i)
                                $root.telemetry.module.cpu.v1.CoreFastMetrics.encode(message.cores[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.temperatures != null && message.temperatures.length)
                            for (let i = 0; i < message.temperatures.length; ++i)
                                $root.telemetry.module.cpu.v1.PackageTemperature.encode(message.temperatures[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                        return writer;
                    };

                    /**
                     * Encodes the specified MediumMetrics message, length delimited. Does not implicitly {@link telemetry.module.cpu.v1.MediumMetrics.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof telemetry.module.cpu.v1.MediumMetrics
                     * @static
                     * @param {telemetry.module.cpu.v1.IMediumMetrics} message MediumMetrics message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    MediumMetrics.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a MediumMetrics message from the specified reader or buffer.
                     * @function decode
                     * @memberof telemetry.module.cpu.v1.MediumMetrics
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {telemetry.module.cpu.v1.MediumMetrics} MediumMetrics
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    MediumMetrics.decode = function decode(reader, length, error) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.telemetry.module.cpu.v1.MediumMetrics();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            if (tag === error)
                                break;
                            switch (tag >>> 3) {
                            case 1: {
                                    if (!(message.cores && message.cores.length))
                                        message.cores = [];
                                    message.cores.push($root.telemetry.module.cpu.v1.CoreFastMetrics.decode(reader, reader.uint32()));
                                    break;
                                }
                            case 2: {
                                    if (!(message.temperatures && message.temperatures.length))
                                        message.temperatures = [];
                                    message.temperatures.push($root.telemetry.module.cpu.v1.PackageTemperature.decode(reader, reader.uint32()));
                                    break;
                                }
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a MediumMetrics message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof telemetry.module.cpu.v1.MediumMetrics
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {telemetry.module.cpu.v1.MediumMetrics} MediumMetrics
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    MediumMetrics.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a MediumMetrics message.
                     * @function verify
                     * @memberof telemetry.module.cpu.v1.MediumMetrics
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    MediumMetrics.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.cores != null && message.hasOwnProperty("cores")) {
                            if (!Array.isArray(message.cores))
                                return "cores: array expected";
                            for (let i = 0; i < message.cores.length; ++i) {
                                let error = $root.telemetry.module.cpu.v1.CoreFastMetrics.verify(message.cores[i]);
                                if (error)
                                    return "cores." + error;
                            }
                        }
                        if (message.temperatures != null && message.hasOwnProperty("temperatures")) {
                            if (!Array.isArray(message.temperatures))
                                return "temperatures: array expected";
                            for (let i = 0; i < message.temperatures.length; ++i) {
                                let error = $root.telemetry.module.cpu.v1.PackageTemperature.verify(message.temperatures[i]);
                                if (error)
                                    return "temperatures." + error;
                            }
                        }
                        return null;
                    };

                    /**
                     * Creates a MediumMetrics message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof telemetry.module.cpu.v1.MediumMetrics
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {telemetry.module.cpu.v1.MediumMetrics} MediumMetrics
                     */
                    MediumMetrics.fromObject = function fromObject(object) {
                        if (object instanceof $root.telemetry.module.cpu.v1.MediumMetrics)
                            return object;
                        let message = new $root.telemetry.module.cpu.v1.MediumMetrics();
                        if (object.cores) {
                            if (!Array.isArray(object.cores))
                                throw TypeError(".telemetry.module.cpu.v1.MediumMetrics.cores: array expected");
                            message.cores = [];
                            for (let i = 0; i < object.cores.length; ++i) {
                                if (typeof object.cores[i] !== "object")
                                    throw TypeError(".telemetry.module.cpu.v1.MediumMetrics.cores: object expected");
                                message.cores[i] = $root.telemetry.module.cpu.v1.CoreFastMetrics.fromObject(object.cores[i]);
                            }
                        }
                        if (object.temperatures) {
                            if (!Array.isArray(object.temperatures))
                                throw TypeError(".telemetry.module.cpu.v1.MediumMetrics.temperatures: array expected");
                            message.temperatures = [];
                            for (let i = 0; i < object.temperatures.length; ++i) {
                                if (typeof object.temperatures[i] !== "object")
                                    throw TypeError(".telemetry.module.cpu.v1.MediumMetrics.temperatures: object expected");
                                message.temperatures[i] = $root.telemetry.module.cpu.v1.PackageTemperature.fromObject(object.temperatures[i]);
                            }
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a MediumMetrics message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof telemetry.module.cpu.v1.MediumMetrics
                     * @static
                     * @param {telemetry.module.cpu.v1.MediumMetrics} message MediumMetrics
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    MediumMetrics.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.arrays || options.defaults) {
                            object.cores = [];
                            object.temperatures = [];
                        }
                        if (message.cores && message.cores.length) {
                            object.cores = [];
                            for (let j = 0; j < message.cores.length; ++j)
                                object.cores[j] = $root.telemetry.module.cpu.v1.CoreFastMetrics.toObject(message.cores[j], options);
                        }
                        if (message.temperatures && message.temperatures.length) {
                            object.temperatures = [];
                            for (let j = 0; j < message.temperatures.length; ++j)
                                object.temperatures[j] = $root.telemetry.module.cpu.v1.PackageTemperature.toObject(message.temperatures[j], options);
                        }
                        return object;
                    };

                    /**
                     * Converts this MediumMetrics to JSON.
                     * @function toJSON
                     * @memberof telemetry.module.cpu.v1.MediumMetrics
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    MediumMetrics.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Gets the default type url for MediumMetrics
                     * @function getTypeUrl
                     * @memberof telemetry.module.cpu.v1.MediumMetrics
                     * @static
                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                     * @returns {string} The default type url
                     */
                    MediumMetrics.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                        if (typeUrlPrefix === undefined) {
                            typeUrlPrefix = "type.googleapis.com";
                        }
                        return typeUrlPrefix + "/telemetry.module.cpu.v1.MediumMetrics";
                    };

                    return MediumMetrics;
                })();

                v1.PerCoreConfig = (function() {

                    /**
                     * Properties of a PerCoreConfig.
                     * @memberof telemetry.module.cpu.v1
                     * @interface IPerCoreConfig
                     * @property {number|null} [coreId] PerCoreConfig coreId
                     * @property {number|Long|null} [scalingMinKhz] PerCoreConfig scalingMinKhz
                     * @property {number|Long|null} [scalingMaxKhz] PerCoreConfig scalingMaxKhz
                     * @property {Array.<string>|null} [availableGovernors] PerCoreConfig availableGovernors
                     * @property {string|null} [currentGovernor] PerCoreConfig currentGovernor
                     * @property {string|null} [scalingDriver] PerCoreConfig scalingDriver
                     * @property {number|null} [packageId] PerCoreConfig packageId
                     * @property {number|Long|null} [sampledAtUnixNano] PerCoreConfig sampledAtUnixNano
                     */

                    /**
                     * Constructs a new PerCoreConfig.
                     * @memberof telemetry.module.cpu.v1
                     * @classdesc Represents a PerCoreConfig.
                     * @implements IPerCoreConfig
                     * @constructor
                     * @param {telemetry.module.cpu.v1.IPerCoreConfig=} [properties] Properties to set
                     */
                    function PerCoreConfig(properties) {
                        this.availableGovernors = [];
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * PerCoreConfig coreId.
                     * @member {number} coreId
                     * @memberof telemetry.module.cpu.v1.PerCoreConfig
                     * @instance
                     */
                    PerCoreConfig.prototype.coreId = 0;

                    /**
                     * PerCoreConfig scalingMinKhz.
                     * @member {number|Long} scalingMinKhz
                     * @memberof telemetry.module.cpu.v1.PerCoreConfig
                     * @instance
                     */
                    PerCoreConfig.prototype.scalingMinKhz = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                    /**
                     * PerCoreConfig scalingMaxKhz.
                     * @member {number|Long} scalingMaxKhz
                     * @memberof telemetry.module.cpu.v1.PerCoreConfig
                     * @instance
                     */
                    PerCoreConfig.prototype.scalingMaxKhz = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                    /**
                     * PerCoreConfig availableGovernors.
                     * @member {Array.<string>} availableGovernors
                     * @memberof telemetry.module.cpu.v1.PerCoreConfig
                     * @instance
                     */
                    PerCoreConfig.prototype.availableGovernors = $util.emptyArray;

                    /**
                     * PerCoreConfig currentGovernor.
                     * @member {string} currentGovernor
                     * @memberof telemetry.module.cpu.v1.PerCoreConfig
                     * @instance
                     */
                    PerCoreConfig.prototype.currentGovernor = "";

                    /**
                     * PerCoreConfig scalingDriver.
                     * @member {string} scalingDriver
                     * @memberof telemetry.module.cpu.v1.PerCoreConfig
                     * @instance
                     */
                    PerCoreConfig.prototype.scalingDriver = "";

                    /**
                     * PerCoreConfig packageId.
                     * @member {number} packageId
                     * @memberof telemetry.module.cpu.v1.PerCoreConfig
                     * @instance
                     */
                    PerCoreConfig.prototype.packageId = 0;

                    /**
                     * PerCoreConfig sampledAtUnixNano.
                     * @member {number|Long} sampledAtUnixNano
                     * @memberof telemetry.module.cpu.v1.PerCoreConfig
                     * @instance
                     */
                    PerCoreConfig.prototype.sampledAtUnixNano = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                    /**
                     * Creates a new PerCoreConfig instance using the specified properties.
                     * @function create
                     * @memberof telemetry.module.cpu.v1.PerCoreConfig
                     * @static
                     * @param {telemetry.module.cpu.v1.IPerCoreConfig=} [properties] Properties to set
                     * @returns {telemetry.module.cpu.v1.PerCoreConfig} PerCoreConfig instance
                     */
                    PerCoreConfig.create = function create(properties) {
                        return new PerCoreConfig(properties);
                    };

                    /**
                     * Encodes the specified PerCoreConfig message. Does not implicitly {@link telemetry.module.cpu.v1.PerCoreConfig.verify|verify} messages.
                     * @function encode
                     * @memberof telemetry.module.cpu.v1.PerCoreConfig
                     * @static
                     * @param {telemetry.module.cpu.v1.IPerCoreConfig} message PerCoreConfig message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    PerCoreConfig.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.coreId != null && Object.hasOwnProperty.call(message, "coreId"))
                            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.coreId);
                        if (message.scalingMinKhz != null && Object.hasOwnProperty.call(message, "scalingMinKhz"))
                            writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.scalingMinKhz);
                        if (message.scalingMaxKhz != null && Object.hasOwnProperty.call(message, "scalingMaxKhz"))
                            writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.scalingMaxKhz);
                        if (message.availableGovernors != null && message.availableGovernors.length)
                            for (let i = 0; i < message.availableGovernors.length; ++i)
                                writer.uint32(/* id 4, wireType 2 =*/34).string(message.availableGovernors[i]);
                        if (message.currentGovernor != null && Object.hasOwnProperty.call(message, "currentGovernor"))
                            writer.uint32(/* id 5, wireType 2 =*/42).string(message.currentGovernor);
                        if (message.scalingDriver != null && Object.hasOwnProperty.call(message, "scalingDriver"))
                            writer.uint32(/* id 6, wireType 2 =*/50).string(message.scalingDriver);
                        if (message.packageId != null && Object.hasOwnProperty.call(message, "packageId"))
                            writer.uint32(/* id 7, wireType 0 =*/56).int32(message.packageId);
                        if (message.sampledAtUnixNano != null && Object.hasOwnProperty.call(message, "sampledAtUnixNano"))
                            writer.uint32(/* id 8, wireType 0 =*/64).int64(message.sampledAtUnixNano);
                        return writer;
                    };

                    /**
                     * Encodes the specified PerCoreConfig message, length delimited. Does not implicitly {@link telemetry.module.cpu.v1.PerCoreConfig.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof telemetry.module.cpu.v1.PerCoreConfig
                     * @static
                     * @param {telemetry.module.cpu.v1.IPerCoreConfig} message PerCoreConfig message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    PerCoreConfig.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a PerCoreConfig message from the specified reader or buffer.
                     * @function decode
                     * @memberof telemetry.module.cpu.v1.PerCoreConfig
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {telemetry.module.cpu.v1.PerCoreConfig} PerCoreConfig
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    PerCoreConfig.decode = function decode(reader, length, error) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.telemetry.module.cpu.v1.PerCoreConfig();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            if (tag === error)
                                break;
                            switch (tag >>> 3) {
                            case 1: {
                                    message.coreId = reader.int32();
                                    break;
                                }
                            case 2: {
                                    message.scalingMinKhz = reader.uint64();
                                    break;
                                }
                            case 3: {
                                    message.scalingMaxKhz = reader.uint64();
                                    break;
                                }
                            case 4: {
                                    if (!(message.availableGovernors && message.availableGovernors.length))
                                        message.availableGovernors = [];
                                    message.availableGovernors.push(reader.string());
                                    break;
                                }
                            case 5: {
                                    message.currentGovernor = reader.string();
                                    break;
                                }
                            case 6: {
                                    message.scalingDriver = reader.string();
                                    break;
                                }
                            case 7: {
                                    message.packageId = reader.int32();
                                    break;
                                }
                            case 8: {
                                    message.sampledAtUnixNano = reader.int64();
                                    break;
                                }
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a PerCoreConfig message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof telemetry.module.cpu.v1.PerCoreConfig
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {telemetry.module.cpu.v1.PerCoreConfig} PerCoreConfig
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    PerCoreConfig.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a PerCoreConfig message.
                     * @function verify
                     * @memberof telemetry.module.cpu.v1.PerCoreConfig
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    PerCoreConfig.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.coreId != null && message.hasOwnProperty("coreId"))
                            if (!$util.isInteger(message.coreId))
                                return "coreId: integer expected";
                        if (message.scalingMinKhz != null && message.hasOwnProperty("scalingMinKhz"))
                            if (!$util.isInteger(message.scalingMinKhz) && !(message.scalingMinKhz && $util.isInteger(message.scalingMinKhz.low) && $util.isInteger(message.scalingMinKhz.high)))
                                return "scalingMinKhz: integer|Long expected";
                        if (message.scalingMaxKhz != null && message.hasOwnProperty("scalingMaxKhz"))
                            if (!$util.isInteger(message.scalingMaxKhz) && !(message.scalingMaxKhz && $util.isInteger(message.scalingMaxKhz.low) && $util.isInteger(message.scalingMaxKhz.high)))
                                return "scalingMaxKhz: integer|Long expected";
                        if (message.availableGovernors != null && message.hasOwnProperty("availableGovernors")) {
                            if (!Array.isArray(message.availableGovernors))
                                return "availableGovernors: array expected";
                            for (let i = 0; i < message.availableGovernors.length; ++i)
                                if (!$util.isString(message.availableGovernors[i]))
                                    return "availableGovernors: string[] expected";
                        }
                        if (message.currentGovernor != null && message.hasOwnProperty("currentGovernor"))
                            if (!$util.isString(message.currentGovernor))
                                return "currentGovernor: string expected";
                        if (message.scalingDriver != null && message.hasOwnProperty("scalingDriver"))
                            if (!$util.isString(message.scalingDriver))
                                return "scalingDriver: string expected";
                        if (message.packageId != null && message.hasOwnProperty("packageId"))
                            if (!$util.isInteger(message.packageId))
                                return "packageId: integer expected";
                        if (message.sampledAtUnixNano != null && message.hasOwnProperty("sampledAtUnixNano"))
                            if (!$util.isInteger(message.sampledAtUnixNano) && !(message.sampledAtUnixNano && $util.isInteger(message.sampledAtUnixNano.low) && $util.isInteger(message.sampledAtUnixNano.high)))
                                return "sampledAtUnixNano: integer|Long expected";
                        return null;
                    };

                    /**
                     * Creates a PerCoreConfig message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof telemetry.module.cpu.v1.PerCoreConfig
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {telemetry.module.cpu.v1.PerCoreConfig} PerCoreConfig
                     */
                    PerCoreConfig.fromObject = function fromObject(object) {
                        if (object instanceof $root.telemetry.module.cpu.v1.PerCoreConfig)
                            return object;
                        let message = new $root.telemetry.module.cpu.v1.PerCoreConfig();
                        if (object.coreId != null)
                            message.coreId = object.coreId | 0;
                        if (object.scalingMinKhz != null)
                            if ($util.Long)
                                (message.scalingMinKhz = $util.Long.fromValue(object.scalingMinKhz)).unsigned = true;
                            else if (typeof object.scalingMinKhz === "string")
                                message.scalingMinKhz = parseInt(object.scalingMinKhz, 10);
                            else if (typeof object.scalingMinKhz === "number")
                                message.scalingMinKhz = object.scalingMinKhz;
                            else if (typeof object.scalingMinKhz === "object")
                                message.scalingMinKhz = new $util.LongBits(object.scalingMinKhz.low >>> 0, object.scalingMinKhz.high >>> 0).toNumber(true);
                        if (object.scalingMaxKhz != null)
                            if ($util.Long)
                                (message.scalingMaxKhz = $util.Long.fromValue(object.scalingMaxKhz)).unsigned = true;
                            else if (typeof object.scalingMaxKhz === "string")
                                message.scalingMaxKhz = parseInt(object.scalingMaxKhz, 10);
                            else if (typeof object.scalingMaxKhz === "number")
                                message.scalingMaxKhz = object.scalingMaxKhz;
                            else if (typeof object.scalingMaxKhz === "object")
                                message.scalingMaxKhz = new $util.LongBits(object.scalingMaxKhz.low >>> 0, object.scalingMaxKhz.high >>> 0).toNumber(true);
                        if (object.availableGovernors) {
                            if (!Array.isArray(object.availableGovernors))
                                throw TypeError(".telemetry.module.cpu.v1.PerCoreConfig.availableGovernors: array expected");
                            message.availableGovernors = [];
                            for (let i = 0; i < object.availableGovernors.length; ++i)
                                message.availableGovernors[i] = String(object.availableGovernors[i]);
                        }
                        if (object.currentGovernor != null)
                            message.currentGovernor = String(object.currentGovernor);
                        if (object.scalingDriver != null)
                            message.scalingDriver = String(object.scalingDriver);
                        if (object.packageId != null)
                            message.packageId = object.packageId | 0;
                        if (object.sampledAtUnixNano != null)
                            if ($util.Long)
                                (message.sampledAtUnixNano = $util.Long.fromValue(object.sampledAtUnixNano)).unsigned = false;
                            else if (typeof object.sampledAtUnixNano === "string")
                                message.sampledAtUnixNano = parseInt(object.sampledAtUnixNano, 10);
                            else if (typeof object.sampledAtUnixNano === "number")
                                message.sampledAtUnixNano = object.sampledAtUnixNano;
                            else if (typeof object.sampledAtUnixNano === "object")
                                message.sampledAtUnixNano = new $util.LongBits(object.sampledAtUnixNano.low >>> 0, object.sampledAtUnixNano.high >>> 0).toNumber();
                        return message;
                    };

                    /**
                     * Creates a plain object from a PerCoreConfig message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof telemetry.module.cpu.v1.PerCoreConfig
                     * @static
                     * @param {telemetry.module.cpu.v1.PerCoreConfig} message PerCoreConfig
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    PerCoreConfig.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.arrays || options.defaults)
                            object.availableGovernors = [];
                        if (options.defaults) {
                            object.coreId = 0;
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, true);
                                object.scalingMinKhz = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.scalingMinKhz = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, true);
                                object.scalingMaxKhz = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.scalingMaxKhz = options.longs === String ? "0" : 0;
                            object.currentGovernor = "";
                            object.scalingDriver = "";
                            object.packageId = 0;
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, false);
                                object.sampledAtUnixNano = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.sampledAtUnixNano = options.longs === String ? "0" : 0;
                        }
                        if (message.coreId != null && message.hasOwnProperty("coreId"))
                            object.coreId = message.coreId;
                        if (message.scalingMinKhz != null && message.hasOwnProperty("scalingMinKhz"))
                            if (typeof message.scalingMinKhz === "number")
                                object.scalingMinKhz = options.longs === String ? String(message.scalingMinKhz) : message.scalingMinKhz;
                            else
                                object.scalingMinKhz = options.longs === String ? $util.Long.prototype.toString.call(message.scalingMinKhz) : options.longs === Number ? new $util.LongBits(message.scalingMinKhz.low >>> 0, message.scalingMinKhz.high >>> 0).toNumber(true) : message.scalingMinKhz;
                        if (message.scalingMaxKhz != null && message.hasOwnProperty("scalingMaxKhz"))
                            if (typeof message.scalingMaxKhz === "number")
                                object.scalingMaxKhz = options.longs === String ? String(message.scalingMaxKhz) : message.scalingMaxKhz;
                            else
                                object.scalingMaxKhz = options.longs === String ? $util.Long.prototype.toString.call(message.scalingMaxKhz) : options.longs === Number ? new $util.LongBits(message.scalingMaxKhz.low >>> 0, message.scalingMaxKhz.high >>> 0).toNumber(true) : message.scalingMaxKhz;
                        if (message.availableGovernors && message.availableGovernors.length) {
                            object.availableGovernors = [];
                            for (let j = 0; j < message.availableGovernors.length; ++j)
                                object.availableGovernors[j] = message.availableGovernors[j];
                        }
                        if (message.currentGovernor != null && message.hasOwnProperty("currentGovernor"))
                            object.currentGovernor = message.currentGovernor;
                        if (message.scalingDriver != null && message.hasOwnProperty("scalingDriver"))
                            object.scalingDriver = message.scalingDriver;
                        if (message.packageId != null && message.hasOwnProperty("packageId"))
                            object.packageId = message.packageId;
                        if (message.sampledAtUnixNano != null && message.hasOwnProperty("sampledAtUnixNano"))
                            if (typeof message.sampledAtUnixNano === "number")
                                object.sampledAtUnixNano = options.longs === String ? String(message.sampledAtUnixNano) : message.sampledAtUnixNano;
                            else
                                object.sampledAtUnixNano = options.longs === String ? $util.Long.prototype.toString.call(message.sampledAtUnixNano) : options.longs === Number ? new $util.LongBits(message.sampledAtUnixNano.low >>> 0, message.sampledAtUnixNano.high >>> 0).toNumber() : message.sampledAtUnixNano;
                        return object;
                    };

                    /**
                     * Converts this PerCoreConfig to JSON.
                     * @function toJSON
                     * @memberof telemetry.module.cpu.v1.PerCoreConfig
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    PerCoreConfig.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Gets the default type url for PerCoreConfig
                     * @function getTypeUrl
                     * @memberof telemetry.module.cpu.v1.PerCoreConfig
                     * @static
                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                     * @returns {string} The default type url
                     */
                    PerCoreConfig.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                        if (typeUrlPrefix === undefined) {
                            typeUrlPrefix = "type.googleapis.com";
                        }
                        return typeUrlPrefix + "/telemetry.module.cpu.v1.PerCoreConfig";
                    };

                    return PerCoreConfig;
                })();

                v1.UncoreMetrics = (function() {

                    /**
                     * Properties of an UncoreMetrics.
                     * @memberof telemetry.module.cpu.v1
                     * @interface IUncoreMetrics
                     * @property {number|null} [packageId] UncoreMetrics packageId
                     * @property {number|Long|null} [currentKhz] UncoreMetrics currentKhz
                     * @property {number|Long|null} [minKhz] UncoreMetrics minKhz
                     * @property {number|Long|null} [maxKhz] UncoreMetrics maxKhz
                     * @property {number|Long|null} [initialMinKhz] UncoreMetrics initialMinKhz
                     * @property {number|Long|null} [initialMaxKhz] UncoreMetrics initialMaxKhz
                     * @property {number|Long|null} [sampledAtUnixNano] UncoreMetrics sampledAtUnixNano
                     */

                    /**
                     * Constructs a new UncoreMetrics.
                     * @memberof telemetry.module.cpu.v1
                     * @classdesc Represents an UncoreMetrics.
                     * @implements IUncoreMetrics
                     * @constructor
                     * @param {telemetry.module.cpu.v1.IUncoreMetrics=} [properties] Properties to set
                     */
                    function UncoreMetrics(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * UncoreMetrics packageId.
                     * @member {number} packageId
                     * @memberof telemetry.module.cpu.v1.UncoreMetrics
                     * @instance
                     */
                    UncoreMetrics.prototype.packageId = 0;

                    /**
                     * UncoreMetrics currentKhz.
                     * @member {number|Long} currentKhz
                     * @memberof telemetry.module.cpu.v1.UncoreMetrics
                     * @instance
                     */
                    UncoreMetrics.prototype.currentKhz = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                    /**
                     * UncoreMetrics minKhz.
                     * @member {number|Long} minKhz
                     * @memberof telemetry.module.cpu.v1.UncoreMetrics
                     * @instance
                     */
                    UncoreMetrics.prototype.minKhz = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                    /**
                     * UncoreMetrics maxKhz.
                     * @member {number|Long} maxKhz
                     * @memberof telemetry.module.cpu.v1.UncoreMetrics
                     * @instance
                     */
                    UncoreMetrics.prototype.maxKhz = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                    /**
                     * UncoreMetrics initialMinKhz.
                     * @member {number|Long} initialMinKhz
                     * @memberof telemetry.module.cpu.v1.UncoreMetrics
                     * @instance
                     */
                    UncoreMetrics.prototype.initialMinKhz = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                    /**
                     * UncoreMetrics initialMaxKhz.
                     * @member {number|Long} initialMaxKhz
                     * @memberof telemetry.module.cpu.v1.UncoreMetrics
                     * @instance
                     */
                    UncoreMetrics.prototype.initialMaxKhz = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                    /**
                     * UncoreMetrics sampledAtUnixNano.
                     * @member {number|Long} sampledAtUnixNano
                     * @memberof telemetry.module.cpu.v1.UncoreMetrics
                     * @instance
                     */
                    UncoreMetrics.prototype.sampledAtUnixNano = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                    /**
                     * Creates a new UncoreMetrics instance using the specified properties.
                     * @function create
                     * @memberof telemetry.module.cpu.v1.UncoreMetrics
                     * @static
                     * @param {telemetry.module.cpu.v1.IUncoreMetrics=} [properties] Properties to set
                     * @returns {telemetry.module.cpu.v1.UncoreMetrics} UncoreMetrics instance
                     */
                    UncoreMetrics.create = function create(properties) {
                        return new UncoreMetrics(properties);
                    };

                    /**
                     * Encodes the specified UncoreMetrics message. Does not implicitly {@link telemetry.module.cpu.v1.UncoreMetrics.verify|verify} messages.
                     * @function encode
                     * @memberof telemetry.module.cpu.v1.UncoreMetrics
                     * @static
                     * @param {telemetry.module.cpu.v1.IUncoreMetrics} message UncoreMetrics message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    UncoreMetrics.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.packageId != null && Object.hasOwnProperty.call(message, "packageId"))
                            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.packageId);
                        if (message.currentKhz != null && Object.hasOwnProperty.call(message, "currentKhz"))
                            writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.currentKhz);
                        if (message.minKhz != null && Object.hasOwnProperty.call(message, "minKhz"))
                            writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.minKhz);
                        if (message.maxKhz != null && Object.hasOwnProperty.call(message, "maxKhz"))
                            writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.maxKhz);
                        if (message.initialMinKhz != null && Object.hasOwnProperty.call(message, "initialMinKhz"))
                            writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.initialMinKhz);
                        if (message.initialMaxKhz != null && Object.hasOwnProperty.call(message, "initialMaxKhz"))
                            writer.uint32(/* id 6, wireType 0 =*/48).uint64(message.initialMaxKhz);
                        if (message.sampledAtUnixNano != null && Object.hasOwnProperty.call(message, "sampledAtUnixNano"))
                            writer.uint32(/* id 7, wireType 0 =*/56).int64(message.sampledAtUnixNano);
                        return writer;
                    };

                    /**
                     * Encodes the specified UncoreMetrics message, length delimited. Does not implicitly {@link telemetry.module.cpu.v1.UncoreMetrics.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof telemetry.module.cpu.v1.UncoreMetrics
                     * @static
                     * @param {telemetry.module.cpu.v1.IUncoreMetrics} message UncoreMetrics message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    UncoreMetrics.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes an UncoreMetrics message from the specified reader or buffer.
                     * @function decode
                     * @memberof telemetry.module.cpu.v1.UncoreMetrics
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {telemetry.module.cpu.v1.UncoreMetrics} UncoreMetrics
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    UncoreMetrics.decode = function decode(reader, length, error) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.telemetry.module.cpu.v1.UncoreMetrics();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            if (tag === error)
                                break;
                            switch (tag >>> 3) {
                            case 1: {
                                    message.packageId = reader.int32();
                                    break;
                                }
                            case 2: {
                                    message.currentKhz = reader.uint64();
                                    break;
                                }
                            case 3: {
                                    message.minKhz = reader.uint64();
                                    break;
                                }
                            case 4: {
                                    message.maxKhz = reader.uint64();
                                    break;
                                }
                            case 5: {
                                    message.initialMinKhz = reader.uint64();
                                    break;
                                }
                            case 6: {
                                    message.initialMaxKhz = reader.uint64();
                                    break;
                                }
                            case 7: {
                                    message.sampledAtUnixNano = reader.int64();
                                    break;
                                }
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes an UncoreMetrics message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof telemetry.module.cpu.v1.UncoreMetrics
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {telemetry.module.cpu.v1.UncoreMetrics} UncoreMetrics
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    UncoreMetrics.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies an UncoreMetrics message.
                     * @function verify
                     * @memberof telemetry.module.cpu.v1.UncoreMetrics
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    UncoreMetrics.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.packageId != null && message.hasOwnProperty("packageId"))
                            if (!$util.isInteger(message.packageId))
                                return "packageId: integer expected";
                        if (message.currentKhz != null && message.hasOwnProperty("currentKhz"))
                            if (!$util.isInteger(message.currentKhz) && !(message.currentKhz && $util.isInteger(message.currentKhz.low) && $util.isInteger(message.currentKhz.high)))
                                return "currentKhz: integer|Long expected";
                        if (message.minKhz != null && message.hasOwnProperty("minKhz"))
                            if (!$util.isInteger(message.minKhz) && !(message.minKhz && $util.isInteger(message.minKhz.low) && $util.isInteger(message.minKhz.high)))
                                return "minKhz: integer|Long expected";
                        if (message.maxKhz != null && message.hasOwnProperty("maxKhz"))
                            if (!$util.isInteger(message.maxKhz) && !(message.maxKhz && $util.isInteger(message.maxKhz.low) && $util.isInteger(message.maxKhz.high)))
                                return "maxKhz: integer|Long expected";
                        if (message.initialMinKhz != null && message.hasOwnProperty("initialMinKhz"))
                            if (!$util.isInteger(message.initialMinKhz) && !(message.initialMinKhz && $util.isInteger(message.initialMinKhz.low) && $util.isInteger(message.initialMinKhz.high)))
                                return "initialMinKhz: integer|Long expected";
                        if (message.initialMaxKhz != null && message.hasOwnProperty("initialMaxKhz"))
                            if (!$util.isInteger(message.initialMaxKhz) && !(message.initialMaxKhz && $util.isInteger(message.initialMaxKhz.low) && $util.isInteger(message.initialMaxKhz.high)))
                                return "initialMaxKhz: integer|Long expected";
                        if (message.sampledAtUnixNano != null && message.hasOwnProperty("sampledAtUnixNano"))
                            if (!$util.isInteger(message.sampledAtUnixNano) && !(message.sampledAtUnixNano && $util.isInteger(message.sampledAtUnixNano.low) && $util.isInteger(message.sampledAtUnixNano.high)))
                                return "sampledAtUnixNano: integer|Long expected";
                        return null;
                    };

                    /**
                     * Creates an UncoreMetrics message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof telemetry.module.cpu.v1.UncoreMetrics
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {telemetry.module.cpu.v1.UncoreMetrics} UncoreMetrics
                     */
                    UncoreMetrics.fromObject = function fromObject(object) {
                        if (object instanceof $root.telemetry.module.cpu.v1.UncoreMetrics)
                            return object;
                        let message = new $root.telemetry.module.cpu.v1.UncoreMetrics();
                        if (object.packageId != null)
                            message.packageId = object.packageId | 0;
                        if (object.currentKhz != null)
                            if ($util.Long)
                                (message.currentKhz = $util.Long.fromValue(object.currentKhz)).unsigned = true;
                            else if (typeof object.currentKhz === "string")
                                message.currentKhz = parseInt(object.currentKhz, 10);
                            else if (typeof object.currentKhz === "number")
                                message.currentKhz = object.currentKhz;
                            else if (typeof object.currentKhz === "object")
                                message.currentKhz = new $util.LongBits(object.currentKhz.low >>> 0, object.currentKhz.high >>> 0).toNumber(true);
                        if (object.minKhz != null)
                            if ($util.Long)
                                (message.minKhz = $util.Long.fromValue(object.minKhz)).unsigned = true;
                            else if (typeof object.minKhz === "string")
                                message.minKhz = parseInt(object.minKhz, 10);
                            else if (typeof object.minKhz === "number")
                                message.minKhz = object.minKhz;
                            else if (typeof object.minKhz === "object")
                                message.minKhz = new $util.LongBits(object.minKhz.low >>> 0, object.minKhz.high >>> 0).toNumber(true);
                        if (object.maxKhz != null)
                            if ($util.Long)
                                (message.maxKhz = $util.Long.fromValue(object.maxKhz)).unsigned = true;
                            else if (typeof object.maxKhz === "string")
                                message.maxKhz = parseInt(object.maxKhz, 10);
                            else if (typeof object.maxKhz === "number")
                                message.maxKhz = object.maxKhz;
                            else if (typeof object.maxKhz === "object")
                                message.maxKhz = new $util.LongBits(object.maxKhz.low >>> 0, object.maxKhz.high >>> 0).toNumber(true);
                        if (object.initialMinKhz != null)
                            if ($util.Long)
                                (message.initialMinKhz = $util.Long.fromValue(object.initialMinKhz)).unsigned = true;
                            else if (typeof object.initialMinKhz === "string")
                                message.initialMinKhz = parseInt(object.initialMinKhz, 10);
                            else if (typeof object.initialMinKhz === "number")
                                message.initialMinKhz = object.initialMinKhz;
                            else if (typeof object.initialMinKhz === "object")
                                message.initialMinKhz = new $util.LongBits(object.initialMinKhz.low >>> 0, object.initialMinKhz.high >>> 0).toNumber(true);
                        if (object.initialMaxKhz != null)
                            if ($util.Long)
                                (message.initialMaxKhz = $util.Long.fromValue(object.initialMaxKhz)).unsigned = true;
                            else if (typeof object.initialMaxKhz === "string")
                                message.initialMaxKhz = parseInt(object.initialMaxKhz, 10);
                            else if (typeof object.initialMaxKhz === "number")
                                message.initialMaxKhz = object.initialMaxKhz;
                            else if (typeof object.initialMaxKhz === "object")
                                message.initialMaxKhz = new $util.LongBits(object.initialMaxKhz.low >>> 0, object.initialMaxKhz.high >>> 0).toNumber(true);
                        if (object.sampledAtUnixNano != null)
                            if ($util.Long)
                                (message.sampledAtUnixNano = $util.Long.fromValue(object.sampledAtUnixNano)).unsigned = false;
                            else if (typeof object.sampledAtUnixNano === "string")
                                message.sampledAtUnixNano = parseInt(object.sampledAtUnixNano, 10);
                            else if (typeof object.sampledAtUnixNano === "number")
                                message.sampledAtUnixNano = object.sampledAtUnixNano;
                            else if (typeof object.sampledAtUnixNano === "object")
                                message.sampledAtUnixNano = new $util.LongBits(object.sampledAtUnixNano.low >>> 0, object.sampledAtUnixNano.high >>> 0).toNumber();
                        return message;
                    };

                    /**
                     * Creates a plain object from an UncoreMetrics message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof telemetry.module.cpu.v1.UncoreMetrics
                     * @static
                     * @param {telemetry.module.cpu.v1.UncoreMetrics} message UncoreMetrics
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    UncoreMetrics.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.packageId = 0;
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, true);
                                object.currentKhz = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.currentKhz = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, true);
                                object.minKhz = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.minKhz = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, true);
                                object.maxKhz = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.maxKhz = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, true);
                                object.initialMinKhz = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.initialMinKhz = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, true);
                                object.initialMaxKhz = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.initialMaxKhz = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, false);
                                object.sampledAtUnixNano = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.sampledAtUnixNano = options.longs === String ? "0" : 0;
                        }
                        if (message.packageId != null && message.hasOwnProperty("packageId"))
                            object.packageId = message.packageId;
                        if (message.currentKhz != null && message.hasOwnProperty("currentKhz"))
                            if (typeof message.currentKhz === "number")
                                object.currentKhz = options.longs === String ? String(message.currentKhz) : message.currentKhz;
                            else
                                object.currentKhz = options.longs === String ? $util.Long.prototype.toString.call(message.currentKhz) : options.longs === Number ? new $util.LongBits(message.currentKhz.low >>> 0, message.currentKhz.high >>> 0).toNumber(true) : message.currentKhz;
                        if (message.minKhz != null && message.hasOwnProperty("minKhz"))
                            if (typeof message.minKhz === "number")
                                object.minKhz = options.longs === String ? String(message.minKhz) : message.minKhz;
                            else
                                object.minKhz = options.longs === String ? $util.Long.prototype.toString.call(message.minKhz) : options.longs === Number ? new $util.LongBits(message.minKhz.low >>> 0, message.minKhz.high >>> 0).toNumber(true) : message.minKhz;
                        if (message.maxKhz != null && message.hasOwnProperty("maxKhz"))
                            if (typeof message.maxKhz === "number")
                                object.maxKhz = options.longs === String ? String(message.maxKhz) : message.maxKhz;
                            else
                                object.maxKhz = options.longs === String ? $util.Long.prototype.toString.call(message.maxKhz) : options.longs === Number ? new $util.LongBits(message.maxKhz.low >>> 0, message.maxKhz.high >>> 0).toNumber(true) : message.maxKhz;
                        if (message.initialMinKhz != null && message.hasOwnProperty("initialMinKhz"))
                            if (typeof message.initialMinKhz === "number")
                                object.initialMinKhz = options.longs === String ? String(message.initialMinKhz) : message.initialMinKhz;
                            else
                                object.initialMinKhz = options.longs === String ? $util.Long.prototype.toString.call(message.initialMinKhz) : options.longs === Number ? new $util.LongBits(message.initialMinKhz.low >>> 0, message.initialMinKhz.high >>> 0).toNumber(true) : message.initialMinKhz;
                        if (message.initialMaxKhz != null && message.hasOwnProperty("initialMaxKhz"))
                            if (typeof message.initialMaxKhz === "number")
                                object.initialMaxKhz = options.longs === String ? String(message.initialMaxKhz) : message.initialMaxKhz;
                            else
                                object.initialMaxKhz = options.longs === String ? $util.Long.prototype.toString.call(message.initialMaxKhz) : options.longs === Number ? new $util.LongBits(message.initialMaxKhz.low >>> 0, message.initialMaxKhz.high >>> 0).toNumber(true) : message.initialMaxKhz;
                        if (message.sampledAtUnixNano != null && message.hasOwnProperty("sampledAtUnixNano"))
                            if (typeof message.sampledAtUnixNano === "number")
                                object.sampledAtUnixNano = options.longs === String ? String(message.sampledAtUnixNano) : message.sampledAtUnixNano;
                            else
                                object.sampledAtUnixNano = options.longs === String ? $util.Long.prototype.toString.call(message.sampledAtUnixNano) : options.longs === Number ? new $util.LongBits(message.sampledAtUnixNano.low >>> 0, message.sampledAtUnixNano.high >>> 0).toNumber() : message.sampledAtUnixNano;
                        return object;
                    };

                    /**
                     * Converts this UncoreMetrics to JSON.
                     * @function toJSON
                     * @memberof telemetry.module.cpu.v1.UncoreMetrics
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    UncoreMetrics.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Gets the default type url for UncoreMetrics
                     * @function getTypeUrl
                     * @memberof telemetry.module.cpu.v1.UncoreMetrics
                     * @static
                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                     * @returns {string} The default type url
                     */
                    UncoreMetrics.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                        if (typeUrlPrefix === undefined) {
                            typeUrlPrefix = "type.googleapis.com";
                        }
                        return typeUrlPrefix + "/telemetry.module.cpu.v1.UncoreMetrics";
                    };

                    return UncoreMetrics;
                })();

                v1.UltraMetrics = (function() {

                    /**
                     * Properties of an UltraMetrics.
                     * @memberof telemetry.module.cpu.v1
                     * @interface IUltraMetrics
                     * @property {Array.<telemetry.module.cpu.v1.IPerCoreConfig>|null} [perCore] UltraMetrics perCore
                     * @property {Array.<telemetry.module.cpu.v1.IPackageRAPL>|null} [rapl] UltraMetrics rapl
                     * @property {Array.<telemetry.module.cpu.v1.IUncoreMetrics>|null} [uncore] UltraMetrics uncore
                     */

                    /**
                     * Constructs a new UltraMetrics.
                     * @memberof telemetry.module.cpu.v1
                     * @classdesc Represents an UltraMetrics.
                     * @implements IUltraMetrics
                     * @constructor
                     * @param {telemetry.module.cpu.v1.IUltraMetrics=} [properties] Properties to set
                     */
                    function UltraMetrics(properties) {
                        this.perCore = [];
                        this.rapl = [];
                        this.uncore = [];
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * UltraMetrics perCore.
                     * @member {Array.<telemetry.module.cpu.v1.IPerCoreConfig>} perCore
                     * @memberof telemetry.module.cpu.v1.UltraMetrics
                     * @instance
                     */
                    UltraMetrics.prototype.perCore = $util.emptyArray;

                    /**
                     * UltraMetrics rapl.
                     * @member {Array.<telemetry.module.cpu.v1.IPackageRAPL>} rapl
                     * @memberof telemetry.module.cpu.v1.UltraMetrics
                     * @instance
                     */
                    UltraMetrics.prototype.rapl = $util.emptyArray;

                    /**
                     * UltraMetrics uncore.
                     * @member {Array.<telemetry.module.cpu.v1.IUncoreMetrics>} uncore
                     * @memberof telemetry.module.cpu.v1.UltraMetrics
                     * @instance
                     */
                    UltraMetrics.prototype.uncore = $util.emptyArray;

                    /**
                     * Creates a new UltraMetrics instance using the specified properties.
                     * @function create
                     * @memberof telemetry.module.cpu.v1.UltraMetrics
                     * @static
                     * @param {telemetry.module.cpu.v1.IUltraMetrics=} [properties] Properties to set
                     * @returns {telemetry.module.cpu.v1.UltraMetrics} UltraMetrics instance
                     */
                    UltraMetrics.create = function create(properties) {
                        return new UltraMetrics(properties);
                    };

                    /**
                     * Encodes the specified UltraMetrics message. Does not implicitly {@link telemetry.module.cpu.v1.UltraMetrics.verify|verify} messages.
                     * @function encode
                     * @memberof telemetry.module.cpu.v1.UltraMetrics
                     * @static
                     * @param {telemetry.module.cpu.v1.IUltraMetrics} message UltraMetrics message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    UltraMetrics.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.perCore != null && message.perCore.length)
                            for (let i = 0; i < message.perCore.length; ++i)
                                $root.telemetry.module.cpu.v1.PerCoreConfig.encode(message.perCore[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.rapl != null && message.rapl.length)
                            for (let i = 0; i < message.rapl.length; ++i)
                                $root.telemetry.module.cpu.v1.PackageRAPL.encode(message.rapl[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                        if (message.uncore != null && message.uncore.length)
                            for (let i = 0; i < message.uncore.length; ++i)
                                $root.telemetry.module.cpu.v1.UncoreMetrics.encode(message.uncore[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                        return writer;
                    };

                    /**
                     * Encodes the specified UltraMetrics message, length delimited. Does not implicitly {@link telemetry.module.cpu.v1.UltraMetrics.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof telemetry.module.cpu.v1.UltraMetrics
                     * @static
                     * @param {telemetry.module.cpu.v1.IUltraMetrics} message UltraMetrics message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    UltraMetrics.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes an UltraMetrics message from the specified reader or buffer.
                     * @function decode
                     * @memberof telemetry.module.cpu.v1.UltraMetrics
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {telemetry.module.cpu.v1.UltraMetrics} UltraMetrics
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    UltraMetrics.decode = function decode(reader, length, error) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.telemetry.module.cpu.v1.UltraMetrics();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            if (tag === error)
                                break;
                            switch (tag >>> 3) {
                            case 1: {
                                    if (!(message.perCore && message.perCore.length))
                                        message.perCore = [];
                                    message.perCore.push($root.telemetry.module.cpu.v1.PerCoreConfig.decode(reader, reader.uint32()));
                                    break;
                                }
                            case 2: {
                                    if (!(message.rapl && message.rapl.length))
                                        message.rapl = [];
                                    message.rapl.push($root.telemetry.module.cpu.v1.PackageRAPL.decode(reader, reader.uint32()));
                                    break;
                                }
                            case 3: {
                                    if (!(message.uncore && message.uncore.length))
                                        message.uncore = [];
                                    message.uncore.push($root.telemetry.module.cpu.v1.UncoreMetrics.decode(reader, reader.uint32()));
                                    break;
                                }
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes an UltraMetrics message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof telemetry.module.cpu.v1.UltraMetrics
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {telemetry.module.cpu.v1.UltraMetrics} UltraMetrics
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    UltraMetrics.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies an UltraMetrics message.
                     * @function verify
                     * @memberof telemetry.module.cpu.v1.UltraMetrics
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    UltraMetrics.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.perCore != null && message.hasOwnProperty("perCore")) {
                            if (!Array.isArray(message.perCore))
                                return "perCore: array expected";
                            for (let i = 0; i < message.perCore.length; ++i) {
                                let error = $root.telemetry.module.cpu.v1.PerCoreConfig.verify(message.perCore[i]);
                                if (error)
                                    return "perCore." + error;
                            }
                        }
                        if (message.rapl != null && message.hasOwnProperty("rapl")) {
                            if (!Array.isArray(message.rapl))
                                return "rapl: array expected";
                            for (let i = 0; i < message.rapl.length; ++i) {
                                let error = $root.telemetry.module.cpu.v1.PackageRAPL.verify(message.rapl[i]);
                                if (error)
                                    return "rapl." + error;
                            }
                        }
                        if (message.uncore != null && message.hasOwnProperty("uncore")) {
                            if (!Array.isArray(message.uncore))
                                return "uncore: array expected";
                            for (let i = 0; i < message.uncore.length; ++i) {
                                let error = $root.telemetry.module.cpu.v1.UncoreMetrics.verify(message.uncore[i]);
                                if (error)
                                    return "uncore." + error;
                            }
                        }
                        return null;
                    };

                    /**
                     * Creates an UltraMetrics message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof telemetry.module.cpu.v1.UltraMetrics
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {telemetry.module.cpu.v1.UltraMetrics} UltraMetrics
                     */
                    UltraMetrics.fromObject = function fromObject(object) {
                        if (object instanceof $root.telemetry.module.cpu.v1.UltraMetrics)
                            return object;
                        let message = new $root.telemetry.module.cpu.v1.UltraMetrics();
                        if (object.perCore) {
                            if (!Array.isArray(object.perCore))
                                throw TypeError(".telemetry.module.cpu.v1.UltraMetrics.perCore: array expected");
                            message.perCore = [];
                            for (let i = 0; i < object.perCore.length; ++i) {
                                if (typeof object.perCore[i] !== "object")
                                    throw TypeError(".telemetry.module.cpu.v1.UltraMetrics.perCore: object expected");
                                message.perCore[i] = $root.telemetry.module.cpu.v1.PerCoreConfig.fromObject(object.perCore[i]);
                            }
                        }
                        if (object.rapl) {
                            if (!Array.isArray(object.rapl))
                                throw TypeError(".telemetry.module.cpu.v1.UltraMetrics.rapl: array expected");
                            message.rapl = [];
                            for (let i = 0; i < object.rapl.length; ++i) {
                                if (typeof object.rapl[i] !== "object")
                                    throw TypeError(".telemetry.module.cpu.v1.UltraMetrics.rapl: object expected");
                                message.rapl[i] = $root.telemetry.module.cpu.v1.PackageRAPL.fromObject(object.rapl[i]);
                            }
                        }
                        if (object.uncore) {
                            if (!Array.isArray(object.uncore))
                                throw TypeError(".telemetry.module.cpu.v1.UltraMetrics.uncore: array expected");
                            message.uncore = [];
                            for (let i = 0; i < object.uncore.length; ++i) {
                                if (typeof object.uncore[i] !== "object")
                                    throw TypeError(".telemetry.module.cpu.v1.UltraMetrics.uncore: object expected");
                                message.uncore[i] = $root.telemetry.module.cpu.v1.UncoreMetrics.fromObject(object.uncore[i]);
                            }
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from an UltraMetrics message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof telemetry.module.cpu.v1.UltraMetrics
                     * @static
                     * @param {telemetry.module.cpu.v1.UltraMetrics} message UltraMetrics
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    UltraMetrics.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.arrays || options.defaults) {
                            object.perCore = [];
                            object.rapl = [];
                            object.uncore = [];
                        }
                        if (message.perCore && message.perCore.length) {
                            object.perCore = [];
                            for (let j = 0; j < message.perCore.length; ++j)
                                object.perCore[j] = $root.telemetry.module.cpu.v1.PerCoreConfig.toObject(message.perCore[j], options);
                        }
                        if (message.rapl && message.rapl.length) {
                            object.rapl = [];
                            for (let j = 0; j < message.rapl.length; ++j)
                                object.rapl[j] = $root.telemetry.module.cpu.v1.PackageRAPL.toObject(message.rapl[j], options);
                        }
                        if (message.uncore && message.uncore.length) {
                            object.uncore = [];
                            for (let j = 0; j < message.uncore.length; ++j)
                                object.uncore[j] = $root.telemetry.module.cpu.v1.UncoreMetrics.toObject(message.uncore[j], options);
                        }
                        return object;
                    };

                    /**
                     * Converts this UltraMetrics to JSON.
                     * @function toJSON
                     * @memberof telemetry.module.cpu.v1.UltraMetrics
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    UltraMetrics.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Gets the default type url for UltraMetrics
                     * @function getTypeUrl
                     * @memberof telemetry.module.cpu.v1.UltraMetrics
                     * @static
                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                     * @returns {string} The default type url
                     */
                    UltraMetrics.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                        if (typeUrlPrefix === undefined) {
                            typeUrlPrefix = "type.googleapis.com";
                        }
                        return typeUrlPrefix + "/telemetry.module.cpu.v1.UltraMetrics";
                    };

                    return UltraMetrics;
                })();

                v1.ScalingRangeCommand = (function() {

                    /**
                     * Properties of a ScalingRangeCommand.
                     * @memberof telemetry.module.cpu.v1
                     * @interface IScalingRangeCommand
                     * @property {number|Long|null} [minKhz] ScalingRangeCommand minKhz
                     * @property {number|Long|null} [maxKhz] ScalingRangeCommand maxKhz
                     * @property {number|null} [packageId] ScalingRangeCommand packageId
                     */

                    /**
                     * Constructs a new ScalingRangeCommand.
                     * @memberof telemetry.module.cpu.v1
                     * @classdesc Represents a ScalingRangeCommand.
                     * @implements IScalingRangeCommand
                     * @constructor
                     * @param {telemetry.module.cpu.v1.IScalingRangeCommand=} [properties] Properties to set
                     */
                    function ScalingRangeCommand(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * ScalingRangeCommand minKhz.
                     * @member {number|Long} minKhz
                     * @memberof telemetry.module.cpu.v1.ScalingRangeCommand
                     * @instance
                     */
                    ScalingRangeCommand.prototype.minKhz = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                    /**
                     * ScalingRangeCommand maxKhz.
                     * @member {number|Long} maxKhz
                     * @memberof telemetry.module.cpu.v1.ScalingRangeCommand
                     * @instance
                     */
                    ScalingRangeCommand.prototype.maxKhz = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                    /**
                     * ScalingRangeCommand packageId.
                     * @member {number|null|undefined} packageId
                     * @memberof telemetry.module.cpu.v1.ScalingRangeCommand
                     * @instance
                     */
                    ScalingRangeCommand.prototype.packageId = null;

                    // OneOf field names bound to virtual getters and setters
                    let $oneOfFields;

                    // Virtual OneOf for proto3 optional field
                    Object.defineProperty(ScalingRangeCommand.prototype, "_packageId", {
                        get: $util.oneOfGetter($oneOfFields = ["packageId"]),
                        set: $util.oneOfSetter($oneOfFields)
                    });

                    /**
                     * Creates a new ScalingRangeCommand instance using the specified properties.
                     * @function create
                     * @memberof telemetry.module.cpu.v1.ScalingRangeCommand
                     * @static
                     * @param {telemetry.module.cpu.v1.IScalingRangeCommand=} [properties] Properties to set
                     * @returns {telemetry.module.cpu.v1.ScalingRangeCommand} ScalingRangeCommand instance
                     */
                    ScalingRangeCommand.create = function create(properties) {
                        return new ScalingRangeCommand(properties);
                    };

                    /**
                     * Encodes the specified ScalingRangeCommand message. Does not implicitly {@link telemetry.module.cpu.v1.ScalingRangeCommand.verify|verify} messages.
                     * @function encode
                     * @memberof telemetry.module.cpu.v1.ScalingRangeCommand
                     * @static
                     * @param {telemetry.module.cpu.v1.IScalingRangeCommand} message ScalingRangeCommand message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ScalingRangeCommand.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.minKhz != null && Object.hasOwnProperty.call(message, "minKhz"))
                            writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.minKhz);
                        if (message.maxKhz != null && Object.hasOwnProperty.call(message, "maxKhz"))
                            writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.maxKhz);
                        if (message.packageId != null && Object.hasOwnProperty.call(message, "packageId"))
                            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.packageId);
                        return writer;
                    };

                    /**
                     * Encodes the specified ScalingRangeCommand message, length delimited. Does not implicitly {@link telemetry.module.cpu.v1.ScalingRangeCommand.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof telemetry.module.cpu.v1.ScalingRangeCommand
                     * @static
                     * @param {telemetry.module.cpu.v1.IScalingRangeCommand} message ScalingRangeCommand message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ScalingRangeCommand.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a ScalingRangeCommand message from the specified reader or buffer.
                     * @function decode
                     * @memberof telemetry.module.cpu.v1.ScalingRangeCommand
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {telemetry.module.cpu.v1.ScalingRangeCommand} ScalingRangeCommand
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ScalingRangeCommand.decode = function decode(reader, length, error) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.telemetry.module.cpu.v1.ScalingRangeCommand();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            if (tag === error)
                                break;
                            switch (tag >>> 3) {
                            case 1: {
                                    message.minKhz = reader.uint64();
                                    break;
                                }
                            case 2: {
                                    message.maxKhz = reader.uint64();
                                    break;
                                }
                            case 3: {
                                    message.packageId = reader.int32();
                                    break;
                                }
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a ScalingRangeCommand message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof telemetry.module.cpu.v1.ScalingRangeCommand
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {telemetry.module.cpu.v1.ScalingRangeCommand} ScalingRangeCommand
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ScalingRangeCommand.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a ScalingRangeCommand message.
                     * @function verify
                     * @memberof telemetry.module.cpu.v1.ScalingRangeCommand
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    ScalingRangeCommand.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        let properties = {};
                        if (message.minKhz != null && message.hasOwnProperty("minKhz"))
                            if (!$util.isInteger(message.minKhz) && !(message.minKhz && $util.isInteger(message.minKhz.low) && $util.isInteger(message.minKhz.high)))
                                return "minKhz: integer|Long expected";
                        if (message.maxKhz != null && message.hasOwnProperty("maxKhz"))
                            if (!$util.isInteger(message.maxKhz) && !(message.maxKhz && $util.isInteger(message.maxKhz.low) && $util.isInteger(message.maxKhz.high)))
                                return "maxKhz: integer|Long expected";
                        if (message.packageId != null && message.hasOwnProperty("packageId")) {
                            properties._packageId = 1;
                            if (!$util.isInteger(message.packageId))
                                return "packageId: integer expected";
                        }
                        return null;
                    };

                    /**
                     * Creates a ScalingRangeCommand message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof telemetry.module.cpu.v1.ScalingRangeCommand
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {telemetry.module.cpu.v1.ScalingRangeCommand} ScalingRangeCommand
                     */
                    ScalingRangeCommand.fromObject = function fromObject(object) {
                        if (object instanceof $root.telemetry.module.cpu.v1.ScalingRangeCommand)
                            return object;
                        let message = new $root.telemetry.module.cpu.v1.ScalingRangeCommand();
                        if (object.minKhz != null)
                            if ($util.Long)
                                (message.minKhz = $util.Long.fromValue(object.minKhz)).unsigned = true;
                            else if (typeof object.minKhz === "string")
                                message.minKhz = parseInt(object.minKhz, 10);
                            else if (typeof object.minKhz === "number")
                                message.minKhz = object.minKhz;
                            else if (typeof object.minKhz === "object")
                                message.minKhz = new $util.LongBits(object.minKhz.low >>> 0, object.minKhz.high >>> 0).toNumber(true);
                        if (object.maxKhz != null)
                            if ($util.Long)
                                (message.maxKhz = $util.Long.fromValue(object.maxKhz)).unsigned = true;
                            else if (typeof object.maxKhz === "string")
                                message.maxKhz = parseInt(object.maxKhz, 10);
                            else if (typeof object.maxKhz === "number")
                                message.maxKhz = object.maxKhz;
                            else if (typeof object.maxKhz === "object")
                                message.maxKhz = new $util.LongBits(object.maxKhz.low >>> 0, object.maxKhz.high >>> 0).toNumber(true);
                        if (object.packageId != null)
                            message.packageId = object.packageId | 0;
                        return message;
                    };

                    /**
                     * Creates a plain object from a ScalingRangeCommand message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof telemetry.module.cpu.v1.ScalingRangeCommand
                     * @static
                     * @param {telemetry.module.cpu.v1.ScalingRangeCommand} message ScalingRangeCommand
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    ScalingRangeCommand.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, true);
                                object.minKhz = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.minKhz = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, true);
                                object.maxKhz = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.maxKhz = options.longs === String ? "0" : 0;
                        }
                        if (message.minKhz != null && message.hasOwnProperty("minKhz"))
                            if (typeof message.minKhz === "number")
                                object.minKhz = options.longs === String ? String(message.minKhz) : message.minKhz;
                            else
                                object.minKhz = options.longs === String ? $util.Long.prototype.toString.call(message.minKhz) : options.longs === Number ? new $util.LongBits(message.minKhz.low >>> 0, message.minKhz.high >>> 0).toNumber(true) : message.minKhz;
                        if (message.maxKhz != null && message.hasOwnProperty("maxKhz"))
                            if (typeof message.maxKhz === "number")
                                object.maxKhz = options.longs === String ? String(message.maxKhz) : message.maxKhz;
                            else
                                object.maxKhz = options.longs === String ? $util.Long.prototype.toString.call(message.maxKhz) : options.longs === Number ? new $util.LongBits(message.maxKhz.low >>> 0, message.maxKhz.high >>> 0).toNumber(true) : message.maxKhz;
                        if (message.packageId != null && message.hasOwnProperty("packageId")) {
                            object.packageId = message.packageId;
                            if (options.oneofs)
                                object._packageId = "packageId";
                        }
                        return object;
                    };

                    /**
                     * Converts this ScalingRangeCommand to JSON.
                     * @function toJSON
                     * @memberof telemetry.module.cpu.v1.ScalingRangeCommand
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    ScalingRangeCommand.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Gets the default type url for ScalingRangeCommand
                     * @function getTypeUrl
                     * @memberof telemetry.module.cpu.v1.ScalingRangeCommand
                     * @static
                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                     * @returns {string} The default type url
                     */
                    ScalingRangeCommand.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                        if (typeUrlPrefix === undefined) {
                            typeUrlPrefix = "type.googleapis.com";
                        }
                        return typeUrlPrefix + "/telemetry.module.cpu.v1.ScalingRangeCommand";
                    };

                    return ScalingRangeCommand;
                })();

                v1.GovernorCommand = (function() {

                    /**
                     * Properties of a GovernorCommand.
                     * @memberof telemetry.module.cpu.v1
                     * @interface IGovernorCommand
                     * @property {string|null} [governor] GovernorCommand governor
                     * @property {number|null} [packageId] GovernorCommand packageId
                     */

                    /**
                     * Constructs a new GovernorCommand.
                     * @memberof telemetry.module.cpu.v1
                     * @classdesc Represents a GovernorCommand.
                     * @implements IGovernorCommand
                     * @constructor
                     * @param {telemetry.module.cpu.v1.IGovernorCommand=} [properties] Properties to set
                     */
                    function GovernorCommand(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * GovernorCommand governor.
                     * @member {string} governor
                     * @memberof telemetry.module.cpu.v1.GovernorCommand
                     * @instance
                     */
                    GovernorCommand.prototype.governor = "";

                    /**
                     * GovernorCommand packageId.
                     * @member {number|null|undefined} packageId
                     * @memberof telemetry.module.cpu.v1.GovernorCommand
                     * @instance
                     */
                    GovernorCommand.prototype.packageId = null;

                    // OneOf field names bound to virtual getters and setters
                    let $oneOfFields;

                    // Virtual OneOf for proto3 optional field
                    Object.defineProperty(GovernorCommand.prototype, "_packageId", {
                        get: $util.oneOfGetter($oneOfFields = ["packageId"]),
                        set: $util.oneOfSetter($oneOfFields)
                    });

                    /**
                     * Creates a new GovernorCommand instance using the specified properties.
                     * @function create
                     * @memberof telemetry.module.cpu.v1.GovernorCommand
                     * @static
                     * @param {telemetry.module.cpu.v1.IGovernorCommand=} [properties] Properties to set
                     * @returns {telemetry.module.cpu.v1.GovernorCommand} GovernorCommand instance
                     */
                    GovernorCommand.create = function create(properties) {
                        return new GovernorCommand(properties);
                    };

                    /**
                     * Encodes the specified GovernorCommand message. Does not implicitly {@link telemetry.module.cpu.v1.GovernorCommand.verify|verify} messages.
                     * @function encode
                     * @memberof telemetry.module.cpu.v1.GovernorCommand
                     * @static
                     * @param {telemetry.module.cpu.v1.IGovernorCommand} message GovernorCommand message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    GovernorCommand.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.governor != null && Object.hasOwnProperty.call(message, "governor"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.governor);
                        if (message.packageId != null && Object.hasOwnProperty.call(message, "packageId"))
                            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.packageId);
                        return writer;
                    };

                    /**
                     * Encodes the specified GovernorCommand message, length delimited. Does not implicitly {@link telemetry.module.cpu.v1.GovernorCommand.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof telemetry.module.cpu.v1.GovernorCommand
                     * @static
                     * @param {telemetry.module.cpu.v1.IGovernorCommand} message GovernorCommand message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    GovernorCommand.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a GovernorCommand message from the specified reader or buffer.
                     * @function decode
                     * @memberof telemetry.module.cpu.v1.GovernorCommand
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {telemetry.module.cpu.v1.GovernorCommand} GovernorCommand
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    GovernorCommand.decode = function decode(reader, length, error) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.telemetry.module.cpu.v1.GovernorCommand();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            if (tag === error)
                                break;
                            switch (tag >>> 3) {
                            case 1: {
                                    message.governor = reader.string();
                                    break;
                                }
                            case 2: {
                                    message.packageId = reader.int32();
                                    break;
                                }
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a GovernorCommand message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof telemetry.module.cpu.v1.GovernorCommand
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {telemetry.module.cpu.v1.GovernorCommand} GovernorCommand
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    GovernorCommand.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a GovernorCommand message.
                     * @function verify
                     * @memberof telemetry.module.cpu.v1.GovernorCommand
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    GovernorCommand.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        let properties = {};
                        if (message.governor != null && message.hasOwnProperty("governor"))
                            if (!$util.isString(message.governor))
                                return "governor: string expected";
                        if (message.packageId != null && message.hasOwnProperty("packageId")) {
                            properties._packageId = 1;
                            if (!$util.isInteger(message.packageId))
                                return "packageId: integer expected";
                        }
                        return null;
                    };

                    /**
                     * Creates a GovernorCommand message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof telemetry.module.cpu.v1.GovernorCommand
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {telemetry.module.cpu.v1.GovernorCommand} GovernorCommand
                     */
                    GovernorCommand.fromObject = function fromObject(object) {
                        if (object instanceof $root.telemetry.module.cpu.v1.GovernorCommand)
                            return object;
                        let message = new $root.telemetry.module.cpu.v1.GovernorCommand();
                        if (object.governor != null)
                            message.governor = String(object.governor);
                        if (object.packageId != null)
                            message.packageId = object.packageId | 0;
                        return message;
                    };

                    /**
                     * Creates a plain object from a GovernorCommand message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof telemetry.module.cpu.v1.GovernorCommand
                     * @static
                     * @param {telemetry.module.cpu.v1.GovernorCommand} message GovernorCommand
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    GovernorCommand.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults)
                            object.governor = "";
                        if (message.governor != null && message.hasOwnProperty("governor"))
                            object.governor = message.governor;
                        if (message.packageId != null && message.hasOwnProperty("packageId")) {
                            object.packageId = message.packageId;
                            if (options.oneofs)
                                object._packageId = "packageId";
                        }
                        return object;
                    };

                    /**
                     * Converts this GovernorCommand to JSON.
                     * @function toJSON
                     * @memberof telemetry.module.cpu.v1.GovernorCommand
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    GovernorCommand.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Gets the default type url for GovernorCommand
                     * @function getTypeUrl
                     * @memberof telemetry.module.cpu.v1.GovernorCommand
                     * @static
                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                     * @returns {string} The default type url
                     */
                    GovernorCommand.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                        if (typeUrlPrefix === undefined) {
                            typeUrlPrefix = "type.googleapis.com";
                        }
                        return typeUrlPrefix + "/telemetry.module.cpu.v1.GovernorCommand";
                    };

                    return GovernorCommand;
                })();

                v1.UncoreRangeCommand = (function() {

                    /**
                     * Properties of an UncoreRangeCommand.
                     * @memberof telemetry.module.cpu.v1
                     * @interface IUncoreRangeCommand
                     * @property {number|null} [packageId] UncoreRangeCommand packageId
                     * @property {number|Long|null} [minKhz] UncoreRangeCommand minKhz
                     * @property {number|Long|null} [maxKhz] UncoreRangeCommand maxKhz
                     */

                    /**
                     * Constructs a new UncoreRangeCommand.
                     * @memberof telemetry.module.cpu.v1
                     * @classdesc Represents an UncoreRangeCommand.
                     * @implements IUncoreRangeCommand
                     * @constructor
                     * @param {telemetry.module.cpu.v1.IUncoreRangeCommand=} [properties] Properties to set
                     */
                    function UncoreRangeCommand(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * UncoreRangeCommand packageId.
                     * @member {number} packageId
                     * @memberof telemetry.module.cpu.v1.UncoreRangeCommand
                     * @instance
                     */
                    UncoreRangeCommand.prototype.packageId = 0;

                    /**
                     * UncoreRangeCommand minKhz.
                     * @member {number|Long} minKhz
                     * @memberof telemetry.module.cpu.v1.UncoreRangeCommand
                     * @instance
                     */
                    UncoreRangeCommand.prototype.minKhz = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                    /**
                     * UncoreRangeCommand maxKhz.
                     * @member {number|Long} maxKhz
                     * @memberof telemetry.module.cpu.v1.UncoreRangeCommand
                     * @instance
                     */
                    UncoreRangeCommand.prototype.maxKhz = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                    /**
                     * Creates a new UncoreRangeCommand instance using the specified properties.
                     * @function create
                     * @memberof telemetry.module.cpu.v1.UncoreRangeCommand
                     * @static
                     * @param {telemetry.module.cpu.v1.IUncoreRangeCommand=} [properties] Properties to set
                     * @returns {telemetry.module.cpu.v1.UncoreRangeCommand} UncoreRangeCommand instance
                     */
                    UncoreRangeCommand.create = function create(properties) {
                        return new UncoreRangeCommand(properties);
                    };

                    /**
                     * Encodes the specified UncoreRangeCommand message. Does not implicitly {@link telemetry.module.cpu.v1.UncoreRangeCommand.verify|verify} messages.
                     * @function encode
                     * @memberof telemetry.module.cpu.v1.UncoreRangeCommand
                     * @static
                     * @param {telemetry.module.cpu.v1.IUncoreRangeCommand} message UncoreRangeCommand message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    UncoreRangeCommand.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.packageId != null && Object.hasOwnProperty.call(message, "packageId"))
                            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.packageId);
                        if (message.minKhz != null && Object.hasOwnProperty.call(message, "minKhz"))
                            writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.minKhz);
                        if (message.maxKhz != null && Object.hasOwnProperty.call(message, "maxKhz"))
                            writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.maxKhz);
                        return writer;
                    };

                    /**
                     * Encodes the specified UncoreRangeCommand message, length delimited. Does not implicitly {@link telemetry.module.cpu.v1.UncoreRangeCommand.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof telemetry.module.cpu.v1.UncoreRangeCommand
                     * @static
                     * @param {telemetry.module.cpu.v1.IUncoreRangeCommand} message UncoreRangeCommand message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    UncoreRangeCommand.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes an UncoreRangeCommand message from the specified reader or buffer.
                     * @function decode
                     * @memberof telemetry.module.cpu.v1.UncoreRangeCommand
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {telemetry.module.cpu.v1.UncoreRangeCommand} UncoreRangeCommand
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    UncoreRangeCommand.decode = function decode(reader, length, error) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.telemetry.module.cpu.v1.UncoreRangeCommand();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            if (tag === error)
                                break;
                            switch (tag >>> 3) {
                            case 1: {
                                    message.packageId = reader.int32();
                                    break;
                                }
                            case 2: {
                                    message.minKhz = reader.uint64();
                                    break;
                                }
                            case 3: {
                                    message.maxKhz = reader.uint64();
                                    break;
                                }
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes an UncoreRangeCommand message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof telemetry.module.cpu.v1.UncoreRangeCommand
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {telemetry.module.cpu.v1.UncoreRangeCommand} UncoreRangeCommand
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    UncoreRangeCommand.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies an UncoreRangeCommand message.
                     * @function verify
                     * @memberof telemetry.module.cpu.v1.UncoreRangeCommand
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    UncoreRangeCommand.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.packageId != null && message.hasOwnProperty("packageId"))
                            if (!$util.isInteger(message.packageId))
                                return "packageId: integer expected";
                        if (message.minKhz != null && message.hasOwnProperty("minKhz"))
                            if (!$util.isInteger(message.minKhz) && !(message.minKhz && $util.isInteger(message.minKhz.low) && $util.isInteger(message.minKhz.high)))
                                return "minKhz: integer|Long expected";
                        if (message.maxKhz != null && message.hasOwnProperty("maxKhz"))
                            if (!$util.isInteger(message.maxKhz) && !(message.maxKhz && $util.isInteger(message.maxKhz.low) && $util.isInteger(message.maxKhz.high)))
                                return "maxKhz: integer|Long expected";
                        return null;
                    };

                    /**
                     * Creates an UncoreRangeCommand message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof telemetry.module.cpu.v1.UncoreRangeCommand
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {telemetry.module.cpu.v1.UncoreRangeCommand} UncoreRangeCommand
                     */
                    UncoreRangeCommand.fromObject = function fromObject(object) {
                        if (object instanceof $root.telemetry.module.cpu.v1.UncoreRangeCommand)
                            return object;
                        let message = new $root.telemetry.module.cpu.v1.UncoreRangeCommand();
                        if (object.packageId != null)
                            message.packageId = object.packageId | 0;
                        if (object.minKhz != null)
                            if ($util.Long)
                                (message.minKhz = $util.Long.fromValue(object.minKhz)).unsigned = true;
                            else if (typeof object.minKhz === "string")
                                message.minKhz = parseInt(object.minKhz, 10);
                            else if (typeof object.minKhz === "number")
                                message.minKhz = object.minKhz;
                            else if (typeof object.minKhz === "object")
                                message.minKhz = new $util.LongBits(object.minKhz.low >>> 0, object.minKhz.high >>> 0).toNumber(true);
                        if (object.maxKhz != null)
                            if ($util.Long)
                                (message.maxKhz = $util.Long.fromValue(object.maxKhz)).unsigned = true;
                            else if (typeof object.maxKhz === "string")
                                message.maxKhz = parseInt(object.maxKhz, 10);
                            else if (typeof object.maxKhz === "number")
                                message.maxKhz = object.maxKhz;
                            else if (typeof object.maxKhz === "object")
                                message.maxKhz = new $util.LongBits(object.maxKhz.low >>> 0, object.maxKhz.high >>> 0).toNumber(true);
                        return message;
                    };

                    /**
                     * Creates a plain object from an UncoreRangeCommand message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof telemetry.module.cpu.v1.UncoreRangeCommand
                     * @static
                     * @param {telemetry.module.cpu.v1.UncoreRangeCommand} message UncoreRangeCommand
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    UncoreRangeCommand.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.packageId = 0;
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, true);
                                object.minKhz = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.minKhz = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, true);
                                object.maxKhz = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.maxKhz = options.longs === String ? "0" : 0;
                        }
                        if (message.packageId != null && message.hasOwnProperty("packageId"))
                            object.packageId = message.packageId;
                        if (message.minKhz != null && message.hasOwnProperty("minKhz"))
                            if (typeof message.minKhz === "number")
                                object.minKhz = options.longs === String ? String(message.minKhz) : message.minKhz;
                            else
                                object.minKhz = options.longs === String ? $util.Long.prototype.toString.call(message.minKhz) : options.longs === Number ? new $util.LongBits(message.minKhz.low >>> 0, message.minKhz.high >>> 0).toNumber(true) : message.minKhz;
                        if (message.maxKhz != null && message.hasOwnProperty("maxKhz"))
                            if (typeof message.maxKhz === "number")
                                object.maxKhz = options.longs === String ? String(message.maxKhz) : message.maxKhz;
                            else
                                object.maxKhz = options.longs === String ? $util.Long.prototype.toString.call(message.maxKhz) : options.longs === Number ? new $util.LongBits(message.maxKhz.low >>> 0, message.maxKhz.high >>> 0).toNumber(true) : message.maxKhz;
                        return object;
                    };

                    /**
                     * Converts this UncoreRangeCommand to JSON.
                     * @function toJSON
                     * @memberof telemetry.module.cpu.v1.UncoreRangeCommand
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    UncoreRangeCommand.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Gets the default type url for UncoreRangeCommand
                     * @function getTypeUrl
                     * @memberof telemetry.module.cpu.v1.UncoreRangeCommand
                     * @static
                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                     * @returns {string} The default type url
                     */
                    UncoreRangeCommand.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                        if (typeUrlPrefix === undefined) {
                            typeUrlPrefix = "type.googleapis.com";
                        }
                        return typeUrlPrefix + "/telemetry.module.cpu.v1.UncoreRangeCommand";
                    };

                    return UncoreRangeCommand;
                })();

                v1.PowerCapCommand = (function() {

                    /**
                     * Properties of a PowerCapCommand.
                     * @memberof telemetry.module.cpu.v1
                     * @interface IPowerCapCommand
                     * @property {number|null} [packageId] PowerCapCommand packageId
                     * @property {number|Long|null} [microwatt] PowerCapCommand microwatt
                     */

                    /**
                     * Constructs a new PowerCapCommand.
                     * @memberof telemetry.module.cpu.v1
                     * @classdesc Represents a PowerCapCommand.
                     * @implements IPowerCapCommand
                     * @constructor
                     * @param {telemetry.module.cpu.v1.IPowerCapCommand=} [properties] Properties to set
                     */
                    function PowerCapCommand(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * PowerCapCommand packageId.
                     * @member {number} packageId
                     * @memberof telemetry.module.cpu.v1.PowerCapCommand
                     * @instance
                     */
                    PowerCapCommand.prototype.packageId = 0;

                    /**
                     * PowerCapCommand microwatt.
                     * @member {number|Long} microwatt
                     * @memberof telemetry.module.cpu.v1.PowerCapCommand
                     * @instance
                     */
                    PowerCapCommand.prototype.microwatt = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                    /**
                     * Creates a new PowerCapCommand instance using the specified properties.
                     * @function create
                     * @memberof telemetry.module.cpu.v1.PowerCapCommand
                     * @static
                     * @param {telemetry.module.cpu.v1.IPowerCapCommand=} [properties] Properties to set
                     * @returns {telemetry.module.cpu.v1.PowerCapCommand} PowerCapCommand instance
                     */
                    PowerCapCommand.create = function create(properties) {
                        return new PowerCapCommand(properties);
                    };

                    /**
                     * Encodes the specified PowerCapCommand message. Does not implicitly {@link telemetry.module.cpu.v1.PowerCapCommand.verify|verify} messages.
                     * @function encode
                     * @memberof telemetry.module.cpu.v1.PowerCapCommand
                     * @static
                     * @param {telemetry.module.cpu.v1.IPowerCapCommand} message PowerCapCommand message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    PowerCapCommand.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.packageId != null && Object.hasOwnProperty.call(message, "packageId"))
                            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.packageId);
                        if (message.microwatt != null && Object.hasOwnProperty.call(message, "microwatt"))
                            writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.microwatt);
                        return writer;
                    };

                    /**
                     * Encodes the specified PowerCapCommand message, length delimited. Does not implicitly {@link telemetry.module.cpu.v1.PowerCapCommand.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof telemetry.module.cpu.v1.PowerCapCommand
                     * @static
                     * @param {telemetry.module.cpu.v1.IPowerCapCommand} message PowerCapCommand message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    PowerCapCommand.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a PowerCapCommand message from the specified reader or buffer.
                     * @function decode
                     * @memberof telemetry.module.cpu.v1.PowerCapCommand
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {telemetry.module.cpu.v1.PowerCapCommand} PowerCapCommand
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    PowerCapCommand.decode = function decode(reader, length, error) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.telemetry.module.cpu.v1.PowerCapCommand();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            if (tag === error)
                                break;
                            switch (tag >>> 3) {
                            case 1: {
                                    message.packageId = reader.int32();
                                    break;
                                }
                            case 2: {
                                    message.microwatt = reader.uint64();
                                    break;
                                }
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a PowerCapCommand message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof telemetry.module.cpu.v1.PowerCapCommand
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {telemetry.module.cpu.v1.PowerCapCommand} PowerCapCommand
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    PowerCapCommand.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a PowerCapCommand message.
                     * @function verify
                     * @memberof telemetry.module.cpu.v1.PowerCapCommand
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    PowerCapCommand.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.packageId != null && message.hasOwnProperty("packageId"))
                            if (!$util.isInteger(message.packageId))
                                return "packageId: integer expected";
                        if (message.microwatt != null && message.hasOwnProperty("microwatt"))
                            if (!$util.isInteger(message.microwatt) && !(message.microwatt && $util.isInteger(message.microwatt.low) && $util.isInteger(message.microwatt.high)))
                                return "microwatt: integer|Long expected";
                        return null;
                    };

                    /**
                     * Creates a PowerCapCommand message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof telemetry.module.cpu.v1.PowerCapCommand
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {telemetry.module.cpu.v1.PowerCapCommand} PowerCapCommand
                     */
                    PowerCapCommand.fromObject = function fromObject(object) {
                        if (object instanceof $root.telemetry.module.cpu.v1.PowerCapCommand)
                            return object;
                        let message = new $root.telemetry.module.cpu.v1.PowerCapCommand();
                        if (object.packageId != null)
                            message.packageId = object.packageId | 0;
                        if (object.microwatt != null)
                            if ($util.Long)
                                (message.microwatt = $util.Long.fromValue(object.microwatt)).unsigned = true;
                            else if (typeof object.microwatt === "string")
                                message.microwatt = parseInt(object.microwatt, 10);
                            else if (typeof object.microwatt === "number")
                                message.microwatt = object.microwatt;
                            else if (typeof object.microwatt === "object")
                                message.microwatt = new $util.LongBits(object.microwatt.low >>> 0, object.microwatt.high >>> 0).toNumber(true);
                        return message;
                    };

                    /**
                     * Creates a plain object from a PowerCapCommand message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof telemetry.module.cpu.v1.PowerCapCommand
                     * @static
                     * @param {telemetry.module.cpu.v1.PowerCapCommand} message PowerCapCommand
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    PowerCapCommand.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.packageId = 0;
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, true);
                                object.microwatt = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.microwatt = options.longs === String ? "0" : 0;
                        }
                        if (message.packageId != null && message.hasOwnProperty("packageId"))
                            object.packageId = message.packageId;
                        if (message.microwatt != null && message.hasOwnProperty("microwatt"))
                            if (typeof message.microwatt === "number")
                                object.microwatt = options.longs === String ? String(message.microwatt) : message.microwatt;
                            else
                                object.microwatt = options.longs === String ? $util.Long.prototype.toString.call(message.microwatt) : options.longs === Number ? new $util.LongBits(message.microwatt.low >>> 0, message.microwatt.high >>> 0).toNumber(true) : message.microwatt;
                        return object;
                    };

                    /**
                     * Converts this PowerCapCommand to JSON.
                     * @function toJSON
                     * @memberof telemetry.module.cpu.v1.PowerCapCommand
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    PowerCapCommand.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Gets the default type url for PowerCapCommand
                     * @function getTypeUrl
                     * @memberof telemetry.module.cpu.v1.PowerCapCommand
                     * @static
                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                     * @returns {string} The default type url
                     */
                    PowerCapCommand.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                        if (typeUrlPrefix === undefined) {
                            typeUrlPrefix = "type.googleapis.com";
                        }
                        return typeUrlPrefix + "/telemetry.module.cpu.v1.PowerCapCommand";
                    };

                    return PowerCapCommand;
                })();

                return v1;
            })();

            return cpu;
        })();

        module.gpu = (function() {

            /**
             * Namespace gpu.
             * @memberof telemetry.module
             * @namespace
             */
            const gpu = {};

            gpu.v1 = (function() {

                /**
                 * Namespace v1.
                 * @memberof telemetry.module.gpu
                 * @namespace
                 */
                const v1 = {};

                v1.CollectorSpec = (function() {

                    /**
                     * Properties of a CollectorSpec.
                     * @memberof telemetry.module.gpu.v1
                     * @interface ICollectorSpec
                     * @property {string|null} [category] CollectorSpec category
                     * @property {string|null} [interval] CollectorSpec interval
                     */

                    /**
                     * Constructs a new CollectorSpec.
                     * @memberof telemetry.module.gpu.v1
                     * @classdesc Represents a CollectorSpec.
                     * @implements ICollectorSpec
                     * @constructor
                     * @param {telemetry.module.gpu.v1.ICollectorSpec=} [properties] Properties to set
                     */
                    function CollectorSpec(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * CollectorSpec category.
                     * @member {string} category
                     * @memberof telemetry.module.gpu.v1.CollectorSpec
                     * @instance
                     */
                    CollectorSpec.prototype.category = "";

                    /**
                     * CollectorSpec interval.
                     * @member {string} interval
                     * @memberof telemetry.module.gpu.v1.CollectorSpec
                     * @instance
                     */
                    CollectorSpec.prototype.interval = "";

                    /**
                     * Creates a new CollectorSpec instance using the specified properties.
                     * @function create
                     * @memberof telemetry.module.gpu.v1.CollectorSpec
                     * @static
                     * @param {telemetry.module.gpu.v1.ICollectorSpec=} [properties] Properties to set
                     * @returns {telemetry.module.gpu.v1.CollectorSpec} CollectorSpec instance
                     */
                    CollectorSpec.create = function create(properties) {
                        return new CollectorSpec(properties);
                    };

                    /**
                     * Encodes the specified CollectorSpec message. Does not implicitly {@link telemetry.module.gpu.v1.CollectorSpec.verify|verify} messages.
                     * @function encode
                     * @memberof telemetry.module.gpu.v1.CollectorSpec
                     * @static
                     * @param {telemetry.module.gpu.v1.ICollectorSpec} message CollectorSpec message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    CollectorSpec.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.category != null && Object.hasOwnProperty.call(message, "category"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.category);
                        if (message.interval != null && Object.hasOwnProperty.call(message, "interval"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.interval);
                        return writer;
                    };

                    /**
                     * Encodes the specified CollectorSpec message, length delimited. Does not implicitly {@link telemetry.module.gpu.v1.CollectorSpec.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof telemetry.module.gpu.v1.CollectorSpec
                     * @static
                     * @param {telemetry.module.gpu.v1.ICollectorSpec} message CollectorSpec message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    CollectorSpec.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a CollectorSpec message from the specified reader or buffer.
                     * @function decode
                     * @memberof telemetry.module.gpu.v1.CollectorSpec
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {telemetry.module.gpu.v1.CollectorSpec} CollectorSpec
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    CollectorSpec.decode = function decode(reader, length, error) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.telemetry.module.gpu.v1.CollectorSpec();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            if (tag === error)
                                break;
                            switch (tag >>> 3) {
                            case 1: {
                                    message.category = reader.string();
                                    break;
                                }
                            case 2: {
                                    message.interval = reader.string();
                                    break;
                                }
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a CollectorSpec message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof telemetry.module.gpu.v1.CollectorSpec
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {telemetry.module.gpu.v1.CollectorSpec} CollectorSpec
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    CollectorSpec.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a CollectorSpec message.
                     * @function verify
                     * @memberof telemetry.module.gpu.v1.CollectorSpec
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    CollectorSpec.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.category != null && message.hasOwnProperty("category"))
                            if (!$util.isString(message.category))
                                return "category: string expected";
                        if (message.interval != null && message.hasOwnProperty("interval"))
                            if (!$util.isString(message.interval))
                                return "interval: string expected";
                        return null;
                    };

                    /**
                     * Creates a CollectorSpec message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof telemetry.module.gpu.v1.CollectorSpec
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {telemetry.module.gpu.v1.CollectorSpec} CollectorSpec
                     */
                    CollectorSpec.fromObject = function fromObject(object) {
                        if (object instanceof $root.telemetry.module.gpu.v1.CollectorSpec)
                            return object;
                        let message = new $root.telemetry.module.gpu.v1.CollectorSpec();
                        if (object.category != null)
                            message.category = String(object.category);
                        if (object.interval != null)
                            message.interval = String(object.interval);
                        return message;
                    };

                    /**
                     * Creates a plain object from a CollectorSpec message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof telemetry.module.gpu.v1.CollectorSpec
                     * @static
                     * @param {telemetry.module.gpu.v1.CollectorSpec} message CollectorSpec
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    CollectorSpec.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.category = "";
                            object.interval = "";
                        }
                        if (message.category != null && message.hasOwnProperty("category"))
                            object.category = message.category;
                        if (message.interval != null && message.hasOwnProperty("interval"))
                            object.interval = message.interval;
                        return object;
                    };

                    /**
                     * Converts this CollectorSpec to JSON.
                     * @function toJSON
                     * @memberof telemetry.module.gpu.v1.CollectorSpec
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    CollectorSpec.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Gets the default type url for CollectorSpec
                     * @function getTypeUrl
                     * @memberof telemetry.module.gpu.v1.CollectorSpec
                     * @static
                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                     * @returns {string} The default type url
                     */
                    CollectorSpec.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                        if (typeUrlPrefix === undefined) {
                            typeUrlPrefix = "type.googleapis.com";
                        }
                        return typeUrlPrefix + "/telemetry.module.gpu.v1.CollectorSpec";
                    };

                    return CollectorSpec;
                })();

                v1.ControllerSpec = (function() {

                    /**
                     * Properties of a ControllerSpec.
                     * @memberof telemetry.module.gpu.v1
                     * @interface IControllerSpec
                     * @property {string|null} [type] ControllerSpec type
                     */

                    /**
                     * Constructs a new ControllerSpec.
                     * @memberof telemetry.module.gpu.v1
                     * @classdesc Represents a ControllerSpec.
                     * @implements IControllerSpec
                     * @constructor
                     * @param {telemetry.module.gpu.v1.IControllerSpec=} [properties] Properties to set
                     */
                    function ControllerSpec(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * ControllerSpec type.
                     * @member {string} type
                     * @memberof telemetry.module.gpu.v1.ControllerSpec
                     * @instance
                     */
                    ControllerSpec.prototype.type = "";

                    /**
                     * Creates a new ControllerSpec instance using the specified properties.
                     * @function create
                     * @memberof telemetry.module.gpu.v1.ControllerSpec
                     * @static
                     * @param {telemetry.module.gpu.v1.IControllerSpec=} [properties] Properties to set
                     * @returns {telemetry.module.gpu.v1.ControllerSpec} ControllerSpec instance
                     */
                    ControllerSpec.create = function create(properties) {
                        return new ControllerSpec(properties);
                    };

                    /**
                     * Encodes the specified ControllerSpec message. Does not implicitly {@link telemetry.module.gpu.v1.ControllerSpec.verify|verify} messages.
                     * @function encode
                     * @memberof telemetry.module.gpu.v1.ControllerSpec
                     * @static
                     * @param {telemetry.module.gpu.v1.IControllerSpec} message ControllerSpec message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ControllerSpec.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.type);
                        return writer;
                    };

                    /**
                     * Encodes the specified ControllerSpec message, length delimited. Does not implicitly {@link telemetry.module.gpu.v1.ControllerSpec.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof telemetry.module.gpu.v1.ControllerSpec
                     * @static
                     * @param {telemetry.module.gpu.v1.IControllerSpec} message ControllerSpec message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ControllerSpec.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a ControllerSpec message from the specified reader or buffer.
                     * @function decode
                     * @memberof telemetry.module.gpu.v1.ControllerSpec
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {telemetry.module.gpu.v1.ControllerSpec} ControllerSpec
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ControllerSpec.decode = function decode(reader, length, error) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.telemetry.module.gpu.v1.ControllerSpec();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            if (tag === error)
                                break;
                            switch (tag >>> 3) {
                            case 1: {
                                    message.type = reader.string();
                                    break;
                                }
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a ControllerSpec message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof telemetry.module.gpu.v1.ControllerSpec
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {telemetry.module.gpu.v1.ControllerSpec} ControllerSpec
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ControllerSpec.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a ControllerSpec message.
                     * @function verify
                     * @memberof telemetry.module.gpu.v1.ControllerSpec
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    ControllerSpec.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.type != null && message.hasOwnProperty("type"))
                            if (!$util.isString(message.type))
                                return "type: string expected";
                        return null;
                    };

                    /**
                     * Creates a ControllerSpec message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof telemetry.module.gpu.v1.ControllerSpec
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {telemetry.module.gpu.v1.ControllerSpec} ControllerSpec
                     */
                    ControllerSpec.fromObject = function fromObject(object) {
                        if (object instanceof $root.telemetry.module.gpu.v1.ControllerSpec)
                            return object;
                        let message = new $root.telemetry.module.gpu.v1.ControllerSpec();
                        if (object.type != null)
                            message.type = String(object.type);
                        return message;
                    };

                    /**
                     * Creates a plain object from a ControllerSpec message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof telemetry.module.gpu.v1.ControllerSpec
                     * @static
                     * @param {telemetry.module.gpu.v1.ControllerSpec} message ControllerSpec
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    ControllerSpec.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults)
                            object.type = "";
                        if (message.type != null && message.hasOwnProperty("type"))
                            object.type = message.type;
                        return object;
                    };

                    /**
                     * Converts this ControllerSpec to JSON.
                     * @function toJSON
                     * @memberof telemetry.module.gpu.v1.ControllerSpec
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    ControllerSpec.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Gets the default type url for ControllerSpec
                     * @function getTypeUrl
                     * @memberof telemetry.module.gpu.v1.ControllerSpec
                     * @static
                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                     * @returns {string} The default type url
                     */
                    ControllerSpec.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                        if (typeUrlPrefix === undefined) {
                            typeUrlPrefix = "type.googleapis.com";
                        }
                        return typeUrlPrefix + "/telemetry.module.gpu.v1.ControllerSpec";
                    };

                    return ControllerSpec;
                })();

                v1.StaticInfo = (function() {

                    /**
                     * Properties of a StaticInfo.
                     * @memberof telemetry.module.gpu.v1
                     * @interface IStaticInfo
                     * @property {number|null} [index] StaticInfo index
                     * @property {string|null} [name] StaticInfo name
                     * @property {string|null} [uuid] StaticInfo uuid
                     * @property {number|Long|null} [memoryTotalBytes] StaticInfo memoryTotalBytes
                     * @property {number|null} [powerMinMilliwatt] StaticInfo powerMinMilliwatt
                     * @property {number|null} [powerMaxMilliwatt] StaticInfo powerMaxMilliwatt
                     * @property {number|null} [smClockMinMhz] StaticInfo smClockMinMhz
                     * @property {number|null} [smClockMaxMhz] StaticInfo smClockMaxMhz
                     * @property {number|null} [memClockMinMhz] StaticInfo memClockMinMhz
                     * @property {number|null} [memClockMaxMhz] StaticInfo memClockMaxMhz
                     */

                    /**
                     * Constructs a new StaticInfo.
                     * @memberof telemetry.module.gpu.v1
                     * @classdesc Represents a StaticInfo.
                     * @implements IStaticInfo
                     * @constructor
                     * @param {telemetry.module.gpu.v1.IStaticInfo=} [properties] Properties to set
                     */
                    function StaticInfo(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * StaticInfo index.
                     * @member {number} index
                     * @memberof telemetry.module.gpu.v1.StaticInfo
                     * @instance
                     */
                    StaticInfo.prototype.index = 0;

                    /**
                     * StaticInfo name.
                     * @member {string} name
                     * @memberof telemetry.module.gpu.v1.StaticInfo
                     * @instance
                     */
                    StaticInfo.prototype.name = "";

                    /**
                     * StaticInfo uuid.
                     * @member {string} uuid
                     * @memberof telemetry.module.gpu.v1.StaticInfo
                     * @instance
                     */
                    StaticInfo.prototype.uuid = "";

                    /**
                     * StaticInfo memoryTotalBytes.
                     * @member {number|Long} memoryTotalBytes
                     * @memberof telemetry.module.gpu.v1.StaticInfo
                     * @instance
                     */
                    StaticInfo.prototype.memoryTotalBytes = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                    /**
                     * StaticInfo powerMinMilliwatt.
                     * @member {number} powerMinMilliwatt
                     * @memberof telemetry.module.gpu.v1.StaticInfo
                     * @instance
                     */
                    StaticInfo.prototype.powerMinMilliwatt = 0;

                    /**
                     * StaticInfo powerMaxMilliwatt.
                     * @member {number} powerMaxMilliwatt
                     * @memberof telemetry.module.gpu.v1.StaticInfo
                     * @instance
                     */
                    StaticInfo.prototype.powerMaxMilliwatt = 0;

                    /**
                     * StaticInfo smClockMinMhz.
                     * @member {number} smClockMinMhz
                     * @memberof telemetry.module.gpu.v1.StaticInfo
                     * @instance
                     */
                    StaticInfo.prototype.smClockMinMhz = 0;

                    /**
                     * StaticInfo smClockMaxMhz.
                     * @member {number} smClockMaxMhz
                     * @memberof telemetry.module.gpu.v1.StaticInfo
                     * @instance
                     */
                    StaticInfo.prototype.smClockMaxMhz = 0;

                    /**
                     * StaticInfo memClockMinMhz.
                     * @member {number} memClockMinMhz
                     * @memberof telemetry.module.gpu.v1.StaticInfo
                     * @instance
                     */
                    StaticInfo.prototype.memClockMinMhz = 0;

                    /**
                     * StaticInfo memClockMaxMhz.
                     * @member {number} memClockMaxMhz
                     * @memberof telemetry.module.gpu.v1.StaticInfo
                     * @instance
                     */
                    StaticInfo.prototype.memClockMaxMhz = 0;

                    /**
                     * Creates a new StaticInfo instance using the specified properties.
                     * @function create
                     * @memberof telemetry.module.gpu.v1.StaticInfo
                     * @static
                     * @param {telemetry.module.gpu.v1.IStaticInfo=} [properties] Properties to set
                     * @returns {telemetry.module.gpu.v1.StaticInfo} StaticInfo instance
                     */
                    StaticInfo.create = function create(properties) {
                        return new StaticInfo(properties);
                    };

                    /**
                     * Encodes the specified StaticInfo message. Does not implicitly {@link telemetry.module.gpu.v1.StaticInfo.verify|verify} messages.
                     * @function encode
                     * @memberof telemetry.module.gpu.v1.StaticInfo
                     * @static
                     * @param {telemetry.module.gpu.v1.IStaticInfo} message StaticInfo message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    StaticInfo.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.index != null && Object.hasOwnProperty.call(message, "index"))
                            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.index);
                        if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
                        if (message.uuid != null && Object.hasOwnProperty.call(message, "uuid"))
                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.uuid);
                        if (message.memoryTotalBytes != null && Object.hasOwnProperty.call(message, "memoryTotalBytes"))
                            writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.memoryTotalBytes);
                        if (message.powerMinMilliwatt != null && Object.hasOwnProperty.call(message, "powerMinMilliwatt"))
                            writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.powerMinMilliwatt);
                        if (message.powerMaxMilliwatt != null && Object.hasOwnProperty.call(message, "powerMaxMilliwatt"))
                            writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.powerMaxMilliwatt);
                        if (message.smClockMinMhz != null && Object.hasOwnProperty.call(message, "smClockMinMhz"))
                            writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.smClockMinMhz);
                        if (message.smClockMaxMhz != null && Object.hasOwnProperty.call(message, "smClockMaxMhz"))
                            writer.uint32(/* id 8, wireType 0 =*/64).uint32(message.smClockMaxMhz);
                        if (message.memClockMinMhz != null && Object.hasOwnProperty.call(message, "memClockMinMhz"))
                            writer.uint32(/* id 9, wireType 0 =*/72).uint32(message.memClockMinMhz);
                        if (message.memClockMaxMhz != null && Object.hasOwnProperty.call(message, "memClockMaxMhz"))
                            writer.uint32(/* id 10, wireType 0 =*/80).uint32(message.memClockMaxMhz);
                        return writer;
                    };

                    /**
                     * Encodes the specified StaticInfo message, length delimited. Does not implicitly {@link telemetry.module.gpu.v1.StaticInfo.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof telemetry.module.gpu.v1.StaticInfo
                     * @static
                     * @param {telemetry.module.gpu.v1.IStaticInfo} message StaticInfo message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    StaticInfo.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a StaticInfo message from the specified reader or buffer.
                     * @function decode
                     * @memberof telemetry.module.gpu.v1.StaticInfo
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {telemetry.module.gpu.v1.StaticInfo} StaticInfo
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    StaticInfo.decode = function decode(reader, length, error) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.telemetry.module.gpu.v1.StaticInfo();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            if (tag === error)
                                break;
                            switch (tag >>> 3) {
                            case 1: {
                                    message.index = reader.int32();
                                    break;
                                }
                            case 2: {
                                    message.name = reader.string();
                                    break;
                                }
                            case 3: {
                                    message.uuid = reader.string();
                                    break;
                                }
                            case 4: {
                                    message.memoryTotalBytes = reader.uint64();
                                    break;
                                }
                            case 5: {
                                    message.powerMinMilliwatt = reader.uint32();
                                    break;
                                }
                            case 6: {
                                    message.powerMaxMilliwatt = reader.uint32();
                                    break;
                                }
                            case 7: {
                                    message.smClockMinMhz = reader.uint32();
                                    break;
                                }
                            case 8: {
                                    message.smClockMaxMhz = reader.uint32();
                                    break;
                                }
                            case 9: {
                                    message.memClockMinMhz = reader.uint32();
                                    break;
                                }
                            case 10: {
                                    message.memClockMaxMhz = reader.uint32();
                                    break;
                                }
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a StaticInfo message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof telemetry.module.gpu.v1.StaticInfo
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {telemetry.module.gpu.v1.StaticInfo} StaticInfo
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    StaticInfo.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a StaticInfo message.
                     * @function verify
                     * @memberof telemetry.module.gpu.v1.StaticInfo
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    StaticInfo.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.index != null && message.hasOwnProperty("index"))
                            if (!$util.isInteger(message.index))
                                return "index: integer expected";
                        if (message.name != null && message.hasOwnProperty("name"))
                            if (!$util.isString(message.name))
                                return "name: string expected";
                        if (message.uuid != null && message.hasOwnProperty("uuid"))
                            if (!$util.isString(message.uuid))
                                return "uuid: string expected";
                        if (message.memoryTotalBytes != null && message.hasOwnProperty("memoryTotalBytes"))
                            if (!$util.isInteger(message.memoryTotalBytes) && !(message.memoryTotalBytes && $util.isInteger(message.memoryTotalBytes.low) && $util.isInteger(message.memoryTotalBytes.high)))
                                return "memoryTotalBytes: integer|Long expected";
                        if (message.powerMinMilliwatt != null && message.hasOwnProperty("powerMinMilliwatt"))
                            if (!$util.isInteger(message.powerMinMilliwatt))
                                return "powerMinMilliwatt: integer expected";
                        if (message.powerMaxMilliwatt != null && message.hasOwnProperty("powerMaxMilliwatt"))
                            if (!$util.isInteger(message.powerMaxMilliwatt))
                                return "powerMaxMilliwatt: integer expected";
                        if (message.smClockMinMhz != null && message.hasOwnProperty("smClockMinMhz"))
                            if (!$util.isInteger(message.smClockMinMhz))
                                return "smClockMinMhz: integer expected";
                        if (message.smClockMaxMhz != null && message.hasOwnProperty("smClockMaxMhz"))
                            if (!$util.isInteger(message.smClockMaxMhz))
                                return "smClockMaxMhz: integer expected";
                        if (message.memClockMinMhz != null && message.hasOwnProperty("memClockMinMhz"))
                            if (!$util.isInteger(message.memClockMinMhz))
                                return "memClockMinMhz: integer expected";
                        if (message.memClockMaxMhz != null && message.hasOwnProperty("memClockMaxMhz"))
                            if (!$util.isInteger(message.memClockMaxMhz))
                                return "memClockMaxMhz: integer expected";
                        return null;
                    };

                    /**
                     * Creates a StaticInfo message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof telemetry.module.gpu.v1.StaticInfo
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {telemetry.module.gpu.v1.StaticInfo} StaticInfo
                     */
                    StaticInfo.fromObject = function fromObject(object) {
                        if (object instanceof $root.telemetry.module.gpu.v1.StaticInfo)
                            return object;
                        let message = new $root.telemetry.module.gpu.v1.StaticInfo();
                        if (object.index != null)
                            message.index = object.index | 0;
                        if (object.name != null)
                            message.name = String(object.name);
                        if (object.uuid != null)
                            message.uuid = String(object.uuid);
                        if (object.memoryTotalBytes != null)
                            if ($util.Long)
                                (message.memoryTotalBytes = $util.Long.fromValue(object.memoryTotalBytes)).unsigned = true;
                            else if (typeof object.memoryTotalBytes === "string")
                                message.memoryTotalBytes = parseInt(object.memoryTotalBytes, 10);
                            else if (typeof object.memoryTotalBytes === "number")
                                message.memoryTotalBytes = object.memoryTotalBytes;
                            else if (typeof object.memoryTotalBytes === "object")
                                message.memoryTotalBytes = new $util.LongBits(object.memoryTotalBytes.low >>> 0, object.memoryTotalBytes.high >>> 0).toNumber(true);
                        if (object.powerMinMilliwatt != null)
                            message.powerMinMilliwatt = object.powerMinMilliwatt >>> 0;
                        if (object.powerMaxMilliwatt != null)
                            message.powerMaxMilliwatt = object.powerMaxMilliwatt >>> 0;
                        if (object.smClockMinMhz != null)
                            message.smClockMinMhz = object.smClockMinMhz >>> 0;
                        if (object.smClockMaxMhz != null)
                            message.smClockMaxMhz = object.smClockMaxMhz >>> 0;
                        if (object.memClockMinMhz != null)
                            message.memClockMinMhz = object.memClockMinMhz >>> 0;
                        if (object.memClockMaxMhz != null)
                            message.memClockMaxMhz = object.memClockMaxMhz >>> 0;
                        return message;
                    };

                    /**
                     * Creates a plain object from a StaticInfo message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof telemetry.module.gpu.v1.StaticInfo
                     * @static
                     * @param {telemetry.module.gpu.v1.StaticInfo} message StaticInfo
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    StaticInfo.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.index = 0;
                            object.name = "";
                            object.uuid = "";
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, true);
                                object.memoryTotalBytes = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.memoryTotalBytes = options.longs === String ? "0" : 0;
                            object.powerMinMilliwatt = 0;
                            object.powerMaxMilliwatt = 0;
                            object.smClockMinMhz = 0;
                            object.smClockMaxMhz = 0;
                            object.memClockMinMhz = 0;
                            object.memClockMaxMhz = 0;
                        }
                        if (message.index != null && message.hasOwnProperty("index"))
                            object.index = message.index;
                        if (message.name != null && message.hasOwnProperty("name"))
                            object.name = message.name;
                        if (message.uuid != null && message.hasOwnProperty("uuid"))
                            object.uuid = message.uuid;
                        if (message.memoryTotalBytes != null && message.hasOwnProperty("memoryTotalBytes"))
                            if (typeof message.memoryTotalBytes === "number")
                                object.memoryTotalBytes = options.longs === String ? String(message.memoryTotalBytes) : message.memoryTotalBytes;
                            else
                                object.memoryTotalBytes = options.longs === String ? $util.Long.prototype.toString.call(message.memoryTotalBytes) : options.longs === Number ? new $util.LongBits(message.memoryTotalBytes.low >>> 0, message.memoryTotalBytes.high >>> 0).toNumber(true) : message.memoryTotalBytes;
                        if (message.powerMinMilliwatt != null && message.hasOwnProperty("powerMinMilliwatt"))
                            object.powerMinMilliwatt = message.powerMinMilliwatt;
                        if (message.powerMaxMilliwatt != null && message.hasOwnProperty("powerMaxMilliwatt"))
                            object.powerMaxMilliwatt = message.powerMaxMilliwatt;
                        if (message.smClockMinMhz != null && message.hasOwnProperty("smClockMinMhz"))
                            object.smClockMinMhz = message.smClockMinMhz;
                        if (message.smClockMaxMhz != null && message.hasOwnProperty("smClockMaxMhz"))
                            object.smClockMaxMhz = message.smClockMaxMhz;
                        if (message.memClockMinMhz != null && message.hasOwnProperty("memClockMinMhz"))
                            object.memClockMinMhz = message.memClockMinMhz;
                        if (message.memClockMaxMhz != null && message.hasOwnProperty("memClockMaxMhz"))
                            object.memClockMaxMhz = message.memClockMaxMhz;
                        return object;
                    };

                    /**
                     * Converts this StaticInfo to JSON.
                     * @function toJSON
                     * @memberof telemetry.module.gpu.v1.StaticInfo
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    StaticInfo.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Gets the default type url for StaticInfo
                     * @function getTypeUrl
                     * @memberof telemetry.module.gpu.v1.StaticInfo
                     * @static
                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                     * @returns {string} The default type url
                     */
                    StaticInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                        if (typeUrlPrefix === undefined) {
                            typeUrlPrefix = "type.googleapis.com";
                        }
                        return typeUrlPrefix + "/telemetry.module.gpu.v1.StaticInfo";
                    };

                    return StaticInfo;
                })();

                v1.ModuleRegistration = (function() {

                    /**
                     * Properties of a ModuleRegistration.
                     * @memberof telemetry.module.gpu.v1
                     * @interface IModuleRegistration
                     * @property {Array.<telemetry.module.gpu.v1.IStaticInfo>|null} ["static"] ModuleRegistration static
                     * @property {Array.<telemetry.module.gpu.v1.ICollectorSpec>|null} [collectors] ModuleRegistration collectors
                     * @property {Array.<telemetry.module.gpu.v1.IControllerSpec>|null} [controllers] ModuleRegistration controllers
                     */

                    /**
                     * Constructs a new ModuleRegistration.
                     * @memberof telemetry.module.gpu.v1
                     * @classdesc Represents a ModuleRegistration.
                     * @implements IModuleRegistration
                     * @constructor
                     * @param {telemetry.module.gpu.v1.IModuleRegistration=} [properties] Properties to set
                     */
                    function ModuleRegistration(properties) {
                        this["static"] = [];
                        this.collectors = [];
                        this.controllers = [];
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * ModuleRegistration static.
                     * @member {Array.<telemetry.module.gpu.v1.IStaticInfo>} static
                     * @memberof telemetry.module.gpu.v1.ModuleRegistration
                     * @instance
                     */
                    ModuleRegistration.prototype["static"] = $util.emptyArray;

                    /**
                     * ModuleRegistration collectors.
                     * @member {Array.<telemetry.module.gpu.v1.ICollectorSpec>} collectors
                     * @memberof telemetry.module.gpu.v1.ModuleRegistration
                     * @instance
                     */
                    ModuleRegistration.prototype.collectors = $util.emptyArray;

                    /**
                     * ModuleRegistration controllers.
                     * @member {Array.<telemetry.module.gpu.v1.IControllerSpec>} controllers
                     * @memberof telemetry.module.gpu.v1.ModuleRegistration
                     * @instance
                     */
                    ModuleRegistration.prototype.controllers = $util.emptyArray;

                    /**
                     * Creates a new ModuleRegistration instance using the specified properties.
                     * @function create
                     * @memberof telemetry.module.gpu.v1.ModuleRegistration
                     * @static
                     * @param {telemetry.module.gpu.v1.IModuleRegistration=} [properties] Properties to set
                     * @returns {telemetry.module.gpu.v1.ModuleRegistration} ModuleRegistration instance
                     */
                    ModuleRegistration.create = function create(properties) {
                        return new ModuleRegistration(properties);
                    };

                    /**
                     * Encodes the specified ModuleRegistration message. Does not implicitly {@link telemetry.module.gpu.v1.ModuleRegistration.verify|verify} messages.
                     * @function encode
                     * @memberof telemetry.module.gpu.v1.ModuleRegistration
                     * @static
                     * @param {telemetry.module.gpu.v1.IModuleRegistration} message ModuleRegistration message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ModuleRegistration.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message["static"] != null && message["static"].length)
                            for (let i = 0; i < message["static"].length; ++i)
                                $root.telemetry.module.gpu.v1.StaticInfo.encode(message["static"][i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.collectors != null && message.collectors.length)
                            for (let i = 0; i < message.collectors.length; ++i)
                                $root.telemetry.module.gpu.v1.CollectorSpec.encode(message.collectors[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                        if (message.controllers != null && message.controllers.length)
                            for (let i = 0; i < message.controllers.length; ++i)
                                $root.telemetry.module.gpu.v1.ControllerSpec.encode(message.controllers[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                        return writer;
                    };

                    /**
                     * Encodes the specified ModuleRegistration message, length delimited. Does not implicitly {@link telemetry.module.gpu.v1.ModuleRegistration.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof telemetry.module.gpu.v1.ModuleRegistration
                     * @static
                     * @param {telemetry.module.gpu.v1.IModuleRegistration} message ModuleRegistration message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ModuleRegistration.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a ModuleRegistration message from the specified reader or buffer.
                     * @function decode
                     * @memberof telemetry.module.gpu.v1.ModuleRegistration
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {telemetry.module.gpu.v1.ModuleRegistration} ModuleRegistration
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ModuleRegistration.decode = function decode(reader, length, error) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.telemetry.module.gpu.v1.ModuleRegistration();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            if (tag === error)
                                break;
                            switch (tag >>> 3) {
                            case 1: {
                                    if (!(message["static"] && message["static"].length))
                                        message["static"] = [];
                                    message["static"].push($root.telemetry.module.gpu.v1.StaticInfo.decode(reader, reader.uint32()));
                                    break;
                                }
                            case 2: {
                                    if (!(message.collectors && message.collectors.length))
                                        message.collectors = [];
                                    message.collectors.push($root.telemetry.module.gpu.v1.CollectorSpec.decode(reader, reader.uint32()));
                                    break;
                                }
                            case 3: {
                                    if (!(message.controllers && message.controllers.length))
                                        message.controllers = [];
                                    message.controllers.push($root.telemetry.module.gpu.v1.ControllerSpec.decode(reader, reader.uint32()));
                                    break;
                                }
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a ModuleRegistration message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof telemetry.module.gpu.v1.ModuleRegistration
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {telemetry.module.gpu.v1.ModuleRegistration} ModuleRegistration
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ModuleRegistration.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a ModuleRegistration message.
                     * @function verify
                     * @memberof telemetry.module.gpu.v1.ModuleRegistration
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    ModuleRegistration.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message["static"] != null && message.hasOwnProperty("static")) {
                            if (!Array.isArray(message["static"]))
                                return "static: array expected";
                            for (let i = 0; i < message["static"].length; ++i) {
                                let error = $root.telemetry.module.gpu.v1.StaticInfo.verify(message["static"][i]);
                                if (error)
                                    return "static." + error;
                            }
                        }
                        if (message.collectors != null && message.hasOwnProperty("collectors")) {
                            if (!Array.isArray(message.collectors))
                                return "collectors: array expected";
                            for (let i = 0; i < message.collectors.length; ++i) {
                                let error = $root.telemetry.module.gpu.v1.CollectorSpec.verify(message.collectors[i]);
                                if (error)
                                    return "collectors." + error;
                            }
                        }
                        if (message.controllers != null && message.hasOwnProperty("controllers")) {
                            if (!Array.isArray(message.controllers))
                                return "controllers: array expected";
                            for (let i = 0; i < message.controllers.length; ++i) {
                                let error = $root.telemetry.module.gpu.v1.ControllerSpec.verify(message.controllers[i]);
                                if (error)
                                    return "controllers." + error;
                            }
                        }
                        return null;
                    };

                    /**
                     * Creates a ModuleRegistration message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof telemetry.module.gpu.v1.ModuleRegistration
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {telemetry.module.gpu.v1.ModuleRegistration} ModuleRegistration
                     */
                    ModuleRegistration.fromObject = function fromObject(object) {
                        if (object instanceof $root.telemetry.module.gpu.v1.ModuleRegistration)
                            return object;
                        let message = new $root.telemetry.module.gpu.v1.ModuleRegistration();
                        if (object["static"]) {
                            if (!Array.isArray(object["static"]))
                                throw TypeError(".telemetry.module.gpu.v1.ModuleRegistration.static: array expected");
                            message["static"] = [];
                            for (let i = 0; i < object["static"].length; ++i) {
                                if (typeof object["static"][i] !== "object")
                                    throw TypeError(".telemetry.module.gpu.v1.ModuleRegistration.static: object expected");
                                message["static"][i] = $root.telemetry.module.gpu.v1.StaticInfo.fromObject(object["static"][i]);
                            }
                        }
                        if (object.collectors) {
                            if (!Array.isArray(object.collectors))
                                throw TypeError(".telemetry.module.gpu.v1.ModuleRegistration.collectors: array expected");
                            message.collectors = [];
                            for (let i = 0; i < object.collectors.length; ++i) {
                                if (typeof object.collectors[i] !== "object")
                                    throw TypeError(".telemetry.module.gpu.v1.ModuleRegistration.collectors: object expected");
                                message.collectors[i] = $root.telemetry.module.gpu.v1.CollectorSpec.fromObject(object.collectors[i]);
                            }
                        }
                        if (object.controllers) {
                            if (!Array.isArray(object.controllers))
                                throw TypeError(".telemetry.module.gpu.v1.ModuleRegistration.controllers: array expected");
                            message.controllers = [];
                            for (let i = 0; i < object.controllers.length; ++i) {
                                if (typeof object.controllers[i] !== "object")
                                    throw TypeError(".telemetry.module.gpu.v1.ModuleRegistration.controllers: object expected");
                                message.controllers[i] = $root.telemetry.module.gpu.v1.ControllerSpec.fromObject(object.controllers[i]);
                            }
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a ModuleRegistration message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof telemetry.module.gpu.v1.ModuleRegistration
                     * @static
                     * @param {telemetry.module.gpu.v1.ModuleRegistration} message ModuleRegistration
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    ModuleRegistration.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.arrays || options.defaults) {
                            object["static"] = [];
                            object.collectors = [];
                            object.controllers = [];
                        }
                        if (message["static"] && message["static"].length) {
                            object["static"] = [];
                            for (let j = 0; j < message["static"].length; ++j)
                                object["static"][j] = $root.telemetry.module.gpu.v1.StaticInfo.toObject(message["static"][j], options);
                        }
                        if (message.collectors && message.collectors.length) {
                            object.collectors = [];
                            for (let j = 0; j < message.collectors.length; ++j)
                                object.collectors[j] = $root.telemetry.module.gpu.v1.CollectorSpec.toObject(message.collectors[j], options);
                        }
                        if (message.controllers && message.controllers.length) {
                            object.controllers = [];
                            for (let j = 0; j < message.controllers.length; ++j)
                                object.controllers[j] = $root.telemetry.module.gpu.v1.ControllerSpec.toObject(message.controllers[j], options);
                        }
                        return object;
                    };

                    /**
                     * Converts this ModuleRegistration to JSON.
                     * @function toJSON
                     * @memberof telemetry.module.gpu.v1.ModuleRegistration
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    ModuleRegistration.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Gets the default type url for ModuleRegistration
                     * @function getTypeUrl
                     * @memberof telemetry.module.gpu.v1.ModuleRegistration
                     * @static
                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                     * @returns {string} The default type url
                     */
                    ModuleRegistration.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                        if (typeUrlPrefix === undefined) {
                            typeUrlPrefix = "type.googleapis.com";
                        }
                        return typeUrlPrefix + "/telemetry.module.gpu.v1.ModuleRegistration";
                    };

                    return ModuleRegistration;
                })();

                v1.DeviceFastMetrics = (function() {

                    /**
                     * Properties of a DeviceFastMetrics.
                     * @memberof telemetry.module.gpu.v1
                     * @interface IDeviceFastMetrics
                     * @property {number|null} [index] DeviceFastMetrics index
                     * @property {number|null} [utilizationGpu] DeviceFastMetrics utilizationGpu
                     * @property {number|null} [utilizationMem] DeviceFastMetrics utilizationMem
                     * @property {number|Long|null} [memoryUsedBytes] DeviceFastMetrics memoryUsedBytes
                     * @property {number|null} [temperatureC] DeviceFastMetrics temperatureC
                     * @property {number|null} [powerUsageMilliwatt] DeviceFastMetrics powerUsageMilliwatt
                     * @property {number|null} [graphicsClockMhz] DeviceFastMetrics graphicsClockMhz
                     * @property {number|null} [memoryClockMhz] DeviceFastMetrics memoryClockMhz
                     * @property {number|null} [smClockMinMhz] DeviceFastMetrics smClockMinMhz
                     * @property {number|null} [smClockMaxMhz] DeviceFastMetrics smClockMaxMhz
                     * @property {number|null} [memClockMinMhz] DeviceFastMetrics memClockMinMhz
                     * @property {number|null} [memClockMaxMhz] DeviceFastMetrics memClockMaxMhz
                     * @property {number|null} [powerLimitMilliwatt] DeviceFastMetrics powerLimitMilliwatt
                     * @property {number|Long|null} [sampledAtUnixNano] DeviceFastMetrics sampledAtUnixNano
                     */

                    /**
                     * Constructs a new DeviceFastMetrics.
                     * @memberof telemetry.module.gpu.v1
                     * @classdesc Represents a DeviceFastMetrics.
                     * @implements IDeviceFastMetrics
                     * @constructor
                     * @param {telemetry.module.gpu.v1.IDeviceFastMetrics=} [properties] Properties to set
                     */
                    function DeviceFastMetrics(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * DeviceFastMetrics index.
                     * @member {number} index
                     * @memberof telemetry.module.gpu.v1.DeviceFastMetrics
                     * @instance
                     */
                    DeviceFastMetrics.prototype.index = 0;

                    /**
                     * DeviceFastMetrics utilizationGpu.
                     * @member {number} utilizationGpu
                     * @memberof telemetry.module.gpu.v1.DeviceFastMetrics
                     * @instance
                     */
                    DeviceFastMetrics.prototype.utilizationGpu = 0;

                    /**
                     * DeviceFastMetrics utilizationMem.
                     * @member {number} utilizationMem
                     * @memberof telemetry.module.gpu.v1.DeviceFastMetrics
                     * @instance
                     */
                    DeviceFastMetrics.prototype.utilizationMem = 0;

                    /**
                     * DeviceFastMetrics memoryUsedBytes.
                     * @member {number|Long} memoryUsedBytes
                     * @memberof telemetry.module.gpu.v1.DeviceFastMetrics
                     * @instance
                     */
                    DeviceFastMetrics.prototype.memoryUsedBytes = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                    /**
                     * DeviceFastMetrics temperatureC.
                     * @member {number} temperatureC
                     * @memberof telemetry.module.gpu.v1.DeviceFastMetrics
                     * @instance
                     */
                    DeviceFastMetrics.prototype.temperatureC = 0;

                    /**
                     * DeviceFastMetrics powerUsageMilliwatt.
                     * @member {number} powerUsageMilliwatt
                     * @memberof telemetry.module.gpu.v1.DeviceFastMetrics
                     * @instance
                     */
                    DeviceFastMetrics.prototype.powerUsageMilliwatt = 0;

                    /**
                     * DeviceFastMetrics graphicsClockMhz.
                     * @member {number} graphicsClockMhz
                     * @memberof telemetry.module.gpu.v1.DeviceFastMetrics
                     * @instance
                     */
                    DeviceFastMetrics.prototype.graphicsClockMhz = 0;

                    /**
                     * DeviceFastMetrics memoryClockMhz.
                     * @member {number} memoryClockMhz
                     * @memberof telemetry.module.gpu.v1.DeviceFastMetrics
                     * @instance
                     */
                    DeviceFastMetrics.prototype.memoryClockMhz = 0;

                    /**
                     * DeviceFastMetrics smClockMinMhz.
                     * @member {number} smClockMinMhz
                     * @memberof telemetry.module.gpu.v1.DeviceFastMetrics
                     * @instance
                     */
                    DeviceFastMetrics.prototype.smClockMinMhz = 0;

                    /**
                     * DeviceFastMetrics smClockMaxMhz.
                     * @member {number} smClockMaxMhz
                     * @memberof telemetry.module.gpu.v1.DeviceFastMetrics
                     * @instance
                     */
                    DeviceFastMetrics.prototype.smClockMaxMhz = 0;

                    /**
                     * DeviceFastMetrics memClockMinMhz.
                     * @member {number} memClockMinMhz
                     * @memberof telemetry.module.gpu.v1.DeviceFastMetrics
                     * @instance
                     */
                    DeviceFastMetrics.prototype.memClockMinMhz = 0;

                    /**
                     * DeviceFastMetrics memClockMaxMhz.
                     * @member {number} memClockMaxMhz
                     * @memberof telemetry.module.gpu.v1.DeviceFastMetrics
                     * @instance
                     */
                    DeviceFastMetrics.prototype.memClockMaxMhz = 0;

                    /**
                     * DeviceFastMetrics powerLimitMilliwatt.
                     * @member {number} powerLimitMilliwatt
                     * @memberof telemetry.module.gpu.v1.DeviceFastMetrics
                     * @instance
                     */
                    DeviceFastMetrics.prototype.powerLimitMilliwatt = 0;

                    /**
                     * DeviceFastMetrics sampledAtUnixNano.
                     * @member {number|Long} sampledAtUnixNano
                     * @memberof telemetry.module.gpu.v1.DeviceFastMetrics
                     * @instance
                     */
                    DeviceFastMetrics.prototype.sampledAtUnixNano = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                    /**
                     * Creates a new DeviceFastMetrics instance using the specified properties.
                     * @function create
                     * @memberof telemetry.module.gpu.v1.DeviceFastMetrics
                     * @static
                     * @param {telemetry.module.gpu.v1.IDeviceFastMetrics=} [properties] Properties to set
                     * @returns {telemetry.module.gpu.v1.DeviceFastMetrics} DeviceFastMetrics instance
                     */
                    DeviceFastMetrics.create = function create(properties) {
                        return new DeviceFastMetrics(properties);
                    };

                    /**
                     * Encodes the specified DeviceFastMetrics message. Does not implicitly {@link telemetry.module.gpu.v1.DeviceFastMetrics.verify|verify} messages.
                     * @function encode
                     * @memberof telemetry.module.gpu.v1.DeviceFastMetrics
                     * @static
                     * @param {telemetry.module.gpu.v1.IDeviceFastMetrics} message DeviceFastMetrics message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    DeviceFastMetrics.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.index != null && Object.hasOwnProperty.call(message, "index"))
                            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.index);
                        if (message.utilizationGpu != null && Object.hasOwnProperty.call(message, "utilizationGpu"))
                            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.utilizationGpu);
                        if (message.utilizationMem != null && Object.hasOwnProperty.call(message, "utilizationMem"))
                            writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.utilizationMem);
                        if (message.memoryUsedBytes != null && Object.hasOwnProperty.call(message, "memoryUsedBytes"))
                            writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.memoryUsedBytes);
                        if (message.temperatureC != null && Object.hasOwnProperty.call(message, "temperatureC"))
                            writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.temperatureC);
                        if (message.powerUsageMilliwatt != null && Object.hasOwnProperty.call(message, "powerUsageMilliwatt"))
                            writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.powerUsageMilliwatt);
                        if (message.graphicsClockMhz != null && Object.hasOwnProperty.call(message, "graphicsClockMhz"))
                            writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.graphicsClockMhz);
                        if (message.memoryClockMhz != null && Object.hasOwnProperty.call(message, "memoryClockMhz"))
                            writer.uint32(/* id 8, wireType 0 =*/64).uint32(message.memoryClockMhz);
                        if (message.smClockMinMhz != null && Object.hasOwnProperty.call(message, "smClockMinMhz"))
                            writer.uint32(/* id 9, wireType 0 =*/72).uint32(message.smClockMinMhz);
                        if (message.smClockMaxMhz != null && Object.hasOwnProperty.call(message, "smClockMaxMhz"))
                            writer.uint32(/* id 10, wireType 0 =*/80).uint32(message.smClockMaxMhz);
                        if (message.memClockMinMhz != null && Object.hasOwnProperty.call(message, "memClockMinMhz"))
                            writer.uint32(/* id 11, wireType 0 =*/88).uint32(message.memClockMinMhz);
                        if (message.memClockMaxMhz != null && Object.hasOwnProperty.call(message, "memClockMaxMhz"))
                            writer.uint32(/* id 12, wireType 0 =*/96).uint32(message.memClockMaxMhz);
                        if (message.powerLimitMilliwatt != null && Object.hasOwnProperty.call(message, "powerLimitMilliwatt"))
                            writer.uint32(/* id 13, wireType 0 =*/104).uint32(message.powerLimitMilliwatt);
                        if (message.sampledAtUnixNano != null && Object.hasOwnProperty.call(message, "sampledAtUnixNano"))
                            writer.uint32(/* id 14, wireType 0 =*/112).int64(message.sampledAtUnixNano);
                        return writer;
                    };

                    /**
                     * Encodes the specified DeviceFastMetrics message, length delimited. Does not implicitly {@link telemetry.module.gpu.v1.DeviceFastMetrics.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof telemetry.module.gpu.v1.DeviceFastMetrics
                     * @static
                     * @param {telemetry.module.gpu.v1.IDeviceFastMetrics} message DeviceFastMetrics message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    DeviceFastMetrics.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a DeviceFastMetrics message from the specified reader or buffer.
                     * @function decode
                     * @memberof telemetry.module.gpu.v1.DeviceFastMetrics
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {telemetry.module.gpu.v1.DeviceFastMetrics} DeviceFastMetrics
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    DeviceFastMetrics.decode = function decode(reader, length, error) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.telemetry.module.gpu.v1.DeviceFastMetrics();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            if (tag === error)
                                break;
                            switch (tag >>> 3) {
                            case 1: {
                                    message.index = reader.int32();
                                    break;
                                }
                            case 2: {
                                    message.utilizationGpu = reader.uint32();
                                    break;
                                }
                            case 3: {
                                    message.utilizationMem = reader.uint32();
                                    break;
                                }
                            case 4: {
                                    message.memoryUsedBytes = reader.uint64();
                                    break;
                                }
                            case 5: {
                                    message.temperatureC = reader.uint32();
                                    break;
                                }
                            case 6: {
                                    message.powerUsageMilliwatt = reader.uint32();
                                    break;
                                }
                            case 7: {
                                    message.graphicsClockMhz = reader.uint32();
                                    break;
                                }
                            case 8: {
                                    message.memoryClockMhz = reader.uint32();
                                    break;
                                }
                            case 9: {
                                    message.smClockMinMhz = reader.uint32();
                                    break;
                                }
                            case 10: {
                                    message.smClockMaxMhz = reader.uint32();
                                    break;
                                }
                            case 11: {
                                    message.memClockMinMhz = reader.uint32();
                                    break;
                                }
                            case 12: {
                                    message.memClockMaxMhz = reader.uint32();
                                    break;
                                }
                            case 13: {
                                    message.powerLimitMilliwatt = reader.uint32();
                                    break;
                                }
                            case 14: {
                                    message.sampledAtUnixNano = reader.int64();
                                    break;
                                }
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a DeviceFastMetrics message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof telemetry.module.gpu.v1.DeviceFastMetrics
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {telemetry.module.gpu.v1.DeviceFastMetrics} DeviceFastMetrics
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    DeviceFastMetrics.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a DeviceFastMetrics message.
                     * @function verify
                     * @memberof telemetry.module.gpu.v1.DeviceFastMetrics
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    DeviceFastMetrics.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.index != null && message.hasOwnProperty("index"))
                            if (!$util.isInteger(message.index))
                                return "index: integer expected";
                        if (message.utilizationGpu != null && message.hasOwnProperty("utilizationGpu"))
                            if (!$util.isInteger(message.utilizationGpu))
                                return "utilizationGpu: integer expected";
                        if (message.utilizationMem != null && message.hasOwnProperty("utilizationMem"))
                            if (!$util.isInteger(message.utilizationMem))
                                return "utilizationMem: integer expected";
                        if (message.memoryUsedBytes != null && message.hasOwnProperty("memoryUsedBytes"))
                            if (!$util.isInteger(message.memoryUsedBytes) && !(message.memoryUsedBytes && $util.isInteger(message.memoryUsedBytes.low) && $util.isInteger(message.memoryUsedBytes.high)))
                                return "memoryUsedBytes: integer|Long expected";
                        if (message.temperatureC != null && message.hasOwnProperty("temperatureC"))
                            if (!$util.isInteger(message.temperatureC))
                                return "temperatureC: integer expected";
                        if (message.powerUsageMilliwatt != null && message.hasOwnProperty("powerUsageMilliwatt"))
                            if (!$util.isInteger(message.powerUsageMilliwatt))
                                return "powerUsageMilliwatt: integer expected";
                        if (message.graphicsClockMhz != null && message.hasOwnProperty("graphicsClockMhz"))
                            if (!$util.isInteger(message.graphicsClockMhz))
                                return "graphicsClockMhz: integer expected";
                        if (message.memoryClockMhz != null && message.hasOwnProperty("memoryClockMhz"))
                            if (!$util.isInteger(message.memoryClockMhz))
                                return "memoryClockMhz: integer expected";
                        if (message.smClockMinMhz != null && message.hasOwnProperty("smClockMinMhz"))
                            if (!$util.isInteger(message.smClockMinMhz))
                                return "smClockMinMhz: integer expected";
                        if (message.smClockMaxMhz != null && message.hasOwnProperty("smClockMaxMhz"))
                            if (!$util.isInteger(message.smClockMaxMhz))
                                return "smClockMaxMhz: integer expected";
                        if (message.memClockMinMhz != null && message.hasOwnProperty("memClockMinMhz"))
                            if (!$util.isInteger(message.memClockMinMhz))
                                return "memClockMinMhz: integer expected";
                        if (message.memClockMaxMhz != null && message.hasOwnProperty("memClockMaxMhz"))
                            if (!$util.isInteger(message.memClockMaxMhz))
                                return "memClockMaxMhz: integer expected";
                        if (message.powerLimitMilliwatt != null && message.hasOwnProperty("powerLimitMilliwatt"))
                            if (!$util.isInteger(message.powerLimitMilliwatt))
                                return "powerLimitMilliwatt: integer expected";
                        if (message.sampledAtUnixNano != null && message.hasOwnProperty("sampledAtUnixNano"))
                            if (!$util.isInteger(message.sampledAtUnixNano) && !(message.sampledAtUnixNano && $util.isInteger(message.sampledAtUnixNano.low) && $util.isInteger(message.sampledAtUnixNano.high)))
                                return "sampledAtUnixNano: integer|Long expected";
                        return null;
                    };

                    /**
                     * Creates a DeviceFastMetrics message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof telemetry.module.gpu.v1.DeviceFastMetrics
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {telemetry.module.gpu.v1.DeviceFastMetrics} DeviceFastMetrics
                     */
                    DeviceFastMetrics.fromObject = function fromObject(object) {
                        if (object instanceof $root.telemetry.module.gpu.v1.DeviceFastMetrics)
                            return object;
                        let message = new $root.telemetry.module.gpu.v1.DeviceFastMetrics();
                        if (object.index != null)
                            message.index = object.index | 0;
                        if (object.utilizationGpu != null)
                            message.utilizationGpu = object.utilizationGpu >>> 0;
                        if (object.utilizationMem != null)
                            message.utilizationMem = object.utilizationMem >>> 0;
                        if (object.memoryUsedBytes != null)
                            if ($util.Long)
                                (message.memoryUsedBytes = $util.Long.fromValue(object.memoryUsedBytes)).unsigned = true;
                            else if (typeof object.memoryUsedBytes === "string")
                                message.memoryUsedBytes = parseInt(object.memoryUsedBytes, 10);
                            else if (typeof object.memoryUsedBytes === "number")
                                message.memoryUsedBytes = object.memoryUsedBytes;
                            else if (typeof object.memoryUsedBytes === "object")
                                message.memoryUsedBytes = new $util.LongBits(object.memoryUsedBytes.low >>> 0, object.memoryUsedBytes.high >>> 0).toNumber(true);
                        if (object.temperatureC != null)
                            message.temperatureC = object.temperatureC >>> 0;
                        if (object.powerUsageMilliwatt != null)
                            message.powerUsageMilliwatt = object.powerUsageMilliwatt >>> 0;
                        if (object.graphicsClockMhz != null)
                            message.graphicsClockMhz = object.graphicsClockMhz >>> 0;
                        if (object.memoryClockMhz != null)
                            message.memoryClockMhz = object.memoryClockMhz >>> 0;
                        if (object.smClockMinMhz != null)
                            message.smClockMinMhz = object.smClockMinMhz >>> 0;
                        if (object.smClockMaxMhz != null)
                            message.smClockMaxMhz = object.smClockMaxMhz >>> 0;
                        if (object.memClockMinMhz != null)
                            message.memClockMinMhz = object.memClockMinMhz >>> 0;
                        if (object.memClockMaxMhz != null)
                            message.memClockMaxMhz = object.memClockMaxMhz >>> 0;
                        if (object.powerLimitMilliwatt != null)
                            message.powerLimitMilliwatt = object.powerLimitMilliwatt >>> 0;
                        if (object.sampledAtUnixNano != null)
                            if ($util.Long)
                                (message.sampledAtUnixNano = $util.Long.fromValue(object.sampledAtUnixNano)).unsigned = false;
                            else if (typeof object.sampledAtUnixNano === "string")
                                message.sampledAtUnixNano = parseInt(object.sampledAtUnixNano, 10);
                            else if (typeof object.sampledAtUnixNano === "number")
                                message.sampledAtUnixNano = object.sampledAtUnixNano;
                            else if (typeof object.sampledAtUnixNano === "object")
                                message.sampledAtUnixNano = new $util.LongBits(object.sampledAtUnixNano.low >>> 0, object.sampledAtUnixNano.high >>> 0).toNumber();
                        return message;
                    };

                    /**
                     * Creates a plain object from a DeviceFastMetrics message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof telemetry.module.gpu.v1.DeviceFastMetrics
                     * @static
                     * @param {telemetry.module.gpu.v1.DeviceFastMetrics} message DeviceFastMetrics
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    DeviceFastMetrics.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.index = 0;
                            object.utilizationGpu = 0;
                            object.utilizationMem = 0;
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, true);
                                object.memoryUsedBytes = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.memoryUsedBytes = options.longs === String ? "0" : 0;
                            object.temperatureC = 0;
                            object.powerUsageMilliwatt = 0;
                            object.graphicsClockMhz = 0;
                            object.memoryClockMhz = 0;
                            object.smClockMinMhz = 0;
                            object.smClockMaxMhz = 0;
                            object.memClockMinMhz = 0;
                            object.memClockMaxMhz = 0;
                            object.powerLimitMilliwatt = 0;
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, false);
                                object.sampledAtUnixNano = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.sampledAtUnixNano = options.longs === String ? "0" : 0;
                        }
                        if (message.index != null && message.hasOwnProperty("index"))
                            object.index = message.index;
                        if (message.utilizationGpu != null && message.hasOwnProperty("utilizationGpu"))
                            object.utilizationGpu = message.utilizationGpu;
                        if (message.utilizationMem != null && message.hasOwnProperty("utilizationMem"))
                            object.utilizationMem = message.utilizationMem;
                        if (message.memoryUsedBytes != null && message.hasOwnProperty("memoryUsedBytes"))
                            if (typeof message.memoryUsedBytes === "number")
                                object.memoryUsedBytes = options.longs === String ? String(message.memoryUsedBytes) : message.memoryUsedBytes;
                            else
                                object.memoryUsedBytes = options.longs === String ? $util.Long.prototype.toString.call(message.memoryUsedBytes) : options.longs === Number ? new $util.LongBits(message.memoryUsedBytes.low >>> 0, message.memoryUsedBytes.high >>> 0).toNumber(true) : message.memoryUsedBytes;
                        if (message.temperatureC != null && message.hasOwnProperty("temperatureC"))
                            object.temperatureC = message.temperatureC;
                        if (message.powerUsageMilliwatt != null && message.hasOwnProperty("powerUsageMilliwatt"))
                            object.powerUsageMilliwatt = message.powerUsageMilliwatt;
                        if (message.graphicsClockMhz != null && message.hasOwnProperty("graphicsClockMhz"))
                            object.graphicsClockMhz = message.graphicsClockMhz;
                        if (message.memoryClockMhz != null && message.hasOwnProperty("memoryClockMhz"))
                            object.memoryClockMhz = message.memoryClockMhz;
                        if (message.smClockMinMhz != null && message.hasOwnProperty("smClockMinMhz"))
                            object.smClockMinMhz = message.smClockMinMhz;
                        if (message.smClockMaxMhz != null && message.hasOwnProperty("smClockMaxMhz"))
                            object.smClockMaxMhz = message.smClockMaxMhz;
                        if (message.memClockMinMhz != null && message.hasOwnProperty("memClockMinMhz"))
                            object.memClockMinMhz = message.memClockMinMhz;
                        if (message.memClockMaxMhz != null && message.hasOwnProperty("memClockMaxMhz"))
                            object.memClockMaxMhz = message.memClockMaxMhz;
                        if (message.powerLimitMilliwatt != null && message.hasOwnProperty("powerLimitMilliwatt"))
                            object.powerLimitMilliwatt = message.powerLimitMilliwatt;
                        if (message.sampledAtUnixNano != null && message.hasOwnProperty("sampledAtUnixNano"))
                            if (typeof message.sampledAtUnixNano === "number")
                                object.sampledAtUnixNano = options.longs === String ? String(message.sampledAtUnixNano) : message.sampledAtUnixNano;
                            else
                                object.sampledAtUnixNano = options.longs === String ? $util.Long.prototype.toString.call(message.sampledAtUnixNano) : options.longs === Number ? new $util.LongBits(message.sampledAtUnixNano.low >>> 0, message.sampledAtUnixNano.high >>> 0).toNumber() : message.sampledAtUnixNano;
                        return object;
                    };

                    /**
                     * Converts this DeviceFastMetrics to JSON.
                     * @function toJSON
                     * @memberof telemetry.module.gpu.v1.DeviceFastMetrics
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    DeviceFastMetrics.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Gets the default type url for DeviceFastMetrics
                     * @function getTypeUrl
                     * @memberof telemetry.module.gpu.v1.DeviceFastMetrics
                     * @static
                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                     * @returns {string} The default type url
                     */
                    DeviceFastMetrics.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                        if (typeUrlPrefix === undefined) {
                            typeUrlPrefix = "type.googleapis.com";
                        }
                        return typeUrlPrefix + "/telemetry.module.gpu.v1.DeviceFastMetrics";
                    };

                    return DeviceFastMetrics;
                })();

                v1.FastMetrics = (function() {

                    /**
                     * Properties of a FastMetrics.
                     * @memberof telemetry.module.gpu.v1
                     * @interface IFastMetrics
                     * @property {Array.<telemetry.module.gpu.v1.IDeviceFastMetrics>|null} [devices] FastMetrics devices
                     */

                    /**
                     * Constructs a new FastMetrics.
                     * @memberof telemetry.module.gpu.v1
                     * @classdesc Represents a FastMetrics.
                     * @implements IFastMetrics
                     * @constructor
                     * @param {telemetry.module.gpu.v1.IFastMetrics=} [properties] Properties to set
                     */
                    function FastMetrics(properties) {
                        this.devices = [];
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * FastMetrics devices.
                     * @member {Array.<telemetry.module.gpu.v1.IDeviceFastMetrics>} devices
                     * @memberof telemetry.module.gpu.v1.FastMetrics
                     * @instance
                     */
                    FastMetrics.prototype.devices = $util.emptyArray;

                    /**
                     * Creates a new FastMetrics instance using the specified properties.
                     * @function create
                     * @memberof telemetry.module.gpu.v1.FastMetrics
                     * @static
                     * @param {telemetry.module.gpu.v1.IFastMetrics=} [properties] Properties to set
                     * @returns {telemetry.module.gpu.v1.FastMetrics} FastMetrics instance
                     */
                    FastMetrics.create = function create(properties) {
                        return new FastMetrics(properties);
                    };

                    /**
                     * Encodes the specified FastMetrics message. Does not implicitly {@link telemetry.module.gpu.v1.FastMetrics.verify|verify} messages.
                     * @function encode
                     * @memberof telemetry.module.gpu.v1.FastMetrics
                     * @static
                     * @param {telemetry.module.gpu.v1.IFastMetrics} message FastMetrics message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    FastMetrics.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.devices != null && message.devices.length)
                            for (let i = 0; i < message.devices.length; ++i)
                                $root.telemetry.module.gpu.v1.DeviceFastMetrics.encode(message.devices[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        return writer;
                    };

                    /**
                     * Encodes the specified FastMetrics message, length delimited. Does not implicitly {@link telemetry.module.gpu.v1.FastMetrics.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof telemetry.module.gpu.v1.FastMetrics
                     * @static
                     * @param {telemetry.module.gpu.v1.IFastMetrics} message FastMetrics message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    FastMetrics.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a FastMetrics message from the specified reader or buffer.
                     * @function decode
                     * @memberof telemetry.module.gpu.v1.FastMetrics
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {telemetry.module.gpu.v1.FastMetrics} FastMetrics
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    FastMetrics.decode = function decode(reader, length, error) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.telemetry.module.gpu.v1.FastMetrics();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            if (tag === error)
                                break;
                            switch (tag >>> 3) {
                            case 1: {
                                    if (!(message.devices && message.devices.length))
                                        message.devices = [];
                                    message.devices.push($root.telemetry.module.gpu.v1.DeviceFastMetrics.decode(reader, reader.uint32()));
                                    break;
                                }
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a FastMetrics message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof telemetry.module.gpu.v1.FastMetrics
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {telemetry.module.gpu.v1.FastMetrics} FastMetrics
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    FastMetrics.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a FastMetrics message.
                     * @function verify
                     * @memberof telemetry.module.gpu.v1.FastMetrics
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    FastMetrics.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.devices != null && message.hasOwnProperty("devices")) {
                            if (!Array.isArray(message.devices))
                                return "devices: array expected";
                            for (let i = 0; i < message.devices.length; ++i) {
                                let error = $root.telemetry.module.gpu.v1.DeviceFastMetrics.verify(message.devices[i]);
                                if (error)
                                    return "devices." + error;
                            }
                        }
                        return null;
                    };

                    /**
                     * Creates a FastMetrics message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof telemetry.module.gpu.v1.FastMetrics
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {telemetry.module.gpu.v1.FastMetrics} FastMetrics
                     */
                    FastMetrics.fromObject = function fromObject(object) {
                        if (object instanceof $root.telemetry.module.gpu.v1.FastMetrics)
                            return object;
                        let message = new $root.telemetry.module.gpu.v1.FastMetrics();
                        if (object.devices) {
                            if (!Array.isArray(object.devices))
                                throw TypeError(".telemetry.module.gpu.v1.FastMetrics.devices: array expected");
                            message.devices = [];
                            for (let i = 0; i < object.devices.length; ++i) {
                                if (typeof object.devices[i] !== "object")
                                    throw TypeError(".telemetry.module.gpu.v1.FastMetrics.devices: object expected");
                                message.devices[i] = $root.telemetry.module.gpu.v1.DeviceFastMetrics.fromObject(object.devices[i]);
                            }
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a FastMetrics message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof telemetry.module.gpu.v1.FastMetrics
                     * @static
                     * @param {telemetry.module.gpu.v1.FastMetrics} message FastMetrics
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    FastMetrics.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.arrays || options.defaults)
                            object.devices = [];
                        if (message.devices && message.devices.length) {
                            object.devices = [];
                            for (let j = 0; j < message.devices.length; ++j)
                                object.devices[j] = $root.telemetry.module.gpu.v1.DeviceFastMetrics.toObject(message.devices[j], options);
                        }
                        return object;
                    };

                    /**
                     * Converts this FastMetrics to JSON.
                     * @function toJSON
                     * @memberof telemetry.module.gpu.v1.FastMetrics
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    FastMetrics.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Gets the default type url for FastMetrics
                     * @function getTypeUrl
                     * @memberof telemetry.module.gpu.v1.FastMetrics
                     * @static
                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                     * @returns {string} The default type url
                     */
                    FastMetrics.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                        if (typeUrlPrefix === undefined) {
                            typeUrlPrefix = "type.googleapis.com";
                        }
                        return typeUrlPrefix + "/telemetry.module.gpu.v1.FastMetrics";
                    };

                    return FastMetrics;
                })();

                v1.ClockRangeCommand = (function() {

                    /**
                     * Properties of a ClockRangeCommand.
                     * @memberof telemetry.module.gpu.v1
                     * @interface IClockRangeCommand
                     * @property {number|null} [gpuIndex] ClockRangeCommand gpuIndex
                     * @property {number|null} [smMinMhz] ClockRangeCommand smMinMhz
                     * @property {number|null} [smMaxMhz] ClockRangeCommand smMaxMhz
                     * @property {number|null} [memMinMhz] ClockRangeCommand memMinMhz
                     * @property {number|null} [memMaxMhz] ClockRangeCommand memMaxMhz
                     */

                    /**
                     * Constructs a new ClockRangeCommand.
                     * @memberof telemetry.module.gpu.v1
                     * @classdesc Represents a ClockRangeCommand.
                     * @implements IClockRangeCommand
                     * @constructor
                     * @param {telemetry.module.gpu.v1.IClockRangeCommand=} [properties] Properties to set
                     */
                    function ClockRangeCommand(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * ClockRangeCommand gpuIndex.
                     * @member {number} gpuIndex
                     * @memberof telemetry.module.gpu.v1.ClockRangeCommand
                     * @instance
                     */
                    ClockRangeCommand.prototype.gpuIndex = 0;

                    /**
                     * ClockRangeCommand smMinMhz.
                     * @member {number} smMinMhz
                     * @memberof telemetry.module.gpu.v1.ClockRangeCommand
                     * @instance
                     */
                    ClockRangeCommand.prototype.smMinMhz = 0;

                    /**
                     * ClockRangeCommand smMaxMhz.
                     * @member {number} smMaxMhz
                     * @memberof telemetry.module.gpu.v1.ClockRangeCommand
                     * @instance
                     */
                    ClockRangeCommand.prototype.smMaxMhz = 0;

                    /**
                     * ClockRangeCommand memMinMhz.
                     * @member {number} memMinMhz
                     * @memberof telemetry.module.gpu.v1.ClockRangeCommand
                     * @instance
                     */
                    ClockRangeCommand.prototype.memMinMhz = 0;

                    /**
                     * ClockRangeCommand memMaxMhz.
                     * @member {number} memMaxMhz
                     * @memberof telemetry.module.gpu.v1.ClockRangeCommand
                     * @instance
                     */
                    ClockRangeCommand.prototype.memMaxMhz = 0;

                    /**
                     * Creates a new ClockRangeCommand instance using the specified properties.
                     * @function create
                     * @memberof telemetry.module.gpu.v1.ClockRangeCommand
                     * @static
                     * @param {telemetry.module.gpu.v1.IClockRangeCommand=} [properties] Properties to set
                     * @returns {telemetry.module.gpu.v1.ClockRangeCommand} ClockRangeCommand instance
                     */
                    ClockRangeCommand.create = function create(properties) {
                        return new ClockRangeCommand(properties);
                    };

                    /**
                     * Encodes the specified ClockRangeCommand message. Does not implicitly {@link telemetry.module.gpu.v1.ClockRangeCommand.verify|verify} messages.
                     * @function encode
                     * @memberof telemetry.module.gpu.v1.ClockRangeCommand
                     * @static
                     * @param {telemetry.module.gpu.v1.IClockRangeCommand} message ClockRangeCommand message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ClockRangeCommand.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.gpuIndex != null && Object.hasOwnProperty.call(message, "gpuIndex"))
                            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.gpuIndex);
                        if (message.smMinMhz != null && Object.hasOwnProperty.call(message, "smMinMhz"))
                            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.smMinMhz);
                        if (message.smMaxMhz != null && Object.hasOwnProperty.call(message, "smMaxMhz"))
                            writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.smMaxMhz);
                        if (message.memMinMhz != null && Object.hasOwnProperty.call(message, "memMinMhz"))
                            writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.memMinMhz);
                        if (message.memMaxMhz != null && Object.hasOwnProperty.call(message, "memMaxMhz"))
                            writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.memMaxMhz);
                        return writer;
                    };

                    /**
                     * Encodes the specified ClockRangeCommand message, length delimited. Does not implicitly {@link telemetry.module.gpu.v1.ClockRangeCommand.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof telemetry.module.gpu.v1.ClockRangeCommand
                     * @static
                     * @param {telemetry.module.gpu.v1.IClockRangeCommand} message ClockRangeCommand message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ClockRangeCommand.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a ClockRangeCommand message from the specified reader or buffer.
                     * @function decode
                     * @memberof telemetry.module.gpu.v1.ClockRangeCommand
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {telemetry.module.gpu.v1.ClockRangeCommand} ClockRangeCommand
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ClockRangeCommand.decode = function decode(reader, length, error) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.telemetry.module.gpu.v1.ClockRangeCommand();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            if (tag === error)
                                break;
                            switch (tag >>> 3) {
                            case 1: {
                                    message.gpuIndex = reader.int32();
                                    break;
                                }
                            case 2: {
                                    message.smMinMhz = reader.uint32();
                                    break;
                                }
                            case 3: {
                                    message.smMaxMhz = reader.uint32();
                                    break;
                                }
                            case 4: {
                                    message.memMinMhz = reader.uint32();
                                    break;
                                }
                            case 5: {
                                    message.memMaxMhz = reader.uint32();
                                    break;
                                }
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a ClockRangeCommand message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof telemetry.module.gpu.v1.ClockRangeCommand
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {telemetry.module.gpu.v1.ClockRangeCommand} ClockRangeCommand
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ClockRangeCommand.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a ClockRangeCommand message.
                     * @function verify
                     * @memberof telemetry.module.gpu.v1.ClockRangeCommand
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    ClockRangeCommand.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.gpuIndex != null && message.hasOwnProperty("gpuIndex"))
                            if (!$util.isInteger(message.gpuIndex))
                                return "gpuIndex: integer expected";
                        if (message.smMinMhz != null && message.hasOwnProperty("smMinMhz"))
                            if (!$util.isInteger(message.smMinMhz))
                                return "smMinMhz: integer expected";
                        if (message.smMaxMhz != null && message.hasOwnProperty("smMaxMhz"))
                            if (!$util.isInteger(message.smMaxMhz))
                                return "smMaxMhz: integer expected";
                        if (message.memMinMhz != null && message.hasOwnProperty("memMinMhz"))
                            if (!$util.isInteger(message.memMinMhz))
                                return "memMinMhz: integer expected";
                        if (message.memMaxMhz != null && message.hasOwnProperty("memMaxMhz"))
                            if (!$util.isInteger(message.memMaxMhz))
                                return "memMaxMhz: integer expected";
                        return null;
                    };

                    /**
                     * Creates a ClockRangeCommand message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof telemetry.module.gpu.v1.ClockRangeCommand
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {telemetry.module.gpu.v1.ClockRangeCommand} ClockRangeCommand
                     */
                    ClockRangeCommand.fromObject = function fromObject(object) {
                        if (object instanceof $root.telemetry.module.gpu.v1.ClockRangeCommand)
                            return object;
                        let message = new $root.telemetry.module.gpu.v1.ClockRangeCommand();
                        if (object.gpuIndex != null)
                            message.gpuIndex = object.gpuIndex | 0;
                        if (object.smMinMhz != null)
                            message.smMinMhz = object.smMinMhz >>> 0;
                        if (object.smMaxMhz != null)
                            message.smMaxMhz = object.smMaxMhz >>> 0;
                        if (object.memMinMhz != null)
                            message.memMinMhz = object.memMinMhz >>> 0;
                        if (object.memMaxMhz != null)
                            message.memMaxMhz = object.memMaxMhz >>> 0;
                        return message;
                    };

                    /**
                     * Creates a plain object from a ClockRangeCommand message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof telemetry.module.gpu.v1.ClockRangeCommand
                     * @static
                     * @param {telemetry.module.gpu.v1.ClockRangeCommand} message ClockRangeCommand
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    ClockRangeCommand.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.gpuIndex = 0;
                            object.smMinMhz = 0;
                            object.smMaxMhz = 0;
                            object.memMinMhz = 0;
                            object.memMaxMhz = 0;
                        }
                        if (message.gpuIndex != null && message.hasOwnProperty("gpuIndex"))
                            object.gpuIndex = message.gpuIndex;
                        if (message.smMinMhz != null && message.hasOwnProperty("smMinMhz"))
                            object.smMinMhz = message.smMinMhz;
                        if (message.smMaxMhz != null && message.hasOwnProperty("smMaxMhz"))
                            object.smMaxMhz = message.smMaxMhz;
                        if (message.memMinMhz != null && message.hasOwnProperty("memMinMhz"))
                            object.memMinMhz = message.memMinMhz;
                        if (message.memMaxMhz != null && message.hasOwnProperty("memMaxMhz"))
                            object.memMaxMhz = message.memMaxMhz;
                        return object;
                    };

                    /**
                     * Converts this ClockRangeCommand to JSON.
                     * @function toJSON
                     * @memberof telemetry.module.gpu.v1.ClockRangeCommand
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    ClockRangeCommand.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Gets the default type url for ClockRangeCommand
                     * @function getTypeUrl
                     * @memberof telemetry.module.gpu.v1.ClockRangeCommand
                     * @static
                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                     * @returns {string} The default type url
                     */
                    ClockRangeCommand.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                        if (typeUrlPrefix === undefined) {
                            typeUrlPrefix = "type.googleapis.com";
                        }
                        return typeUrlPrefix + "/telemetry.module.gpu.v1.ClockRangeCommand";
                    };

                    return ClockRangeCommand;
                })();

                v1.PowerCapCommand = (function() {

                    /**
                     * Properties of a PowerCapCommand.
                     * @memberof telemetry.module.gpu.v1
                     * @interface IPowerCapCommand
                     * @property {number|null} [gpuIndex] PowerCapCommand gpuIndex
                     * @property {number|null} [milliwatt] PowerCapCommand milliwatt
                     */

                    /**
                     * Constructs a new PowerCapCommand.
                     * @memberof telemetry.module.gpu.v1
                     * @classdesc Represents a PowerCapCommand.
                     * @implements IPowerCapCommand
                     * @constructor
                     * @param {telemetry.module.gpu.v1.IPowerCapCommand=} [properties] Properties to set
                     */
                    function PowerCapCommand(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * PowerCapCommand gpuIndex.
                     * @member {number} gpuIndex
                     * @memberof telemetry.module.gpu.v1.PowerCapCommand
                     * @instance
                     */
                    PowerCapCommand.prototype.gpuIndex = 0;

                    /**
                     * PowerCapCommand milliwatt.
                     * @member {number} milliwatt
                     * @memberof telemetry.module.gpu.v1.PowerCapCommand
                     * @instance
                     */
                    PowerCapCommand.prototype.milliwatt = 0;

                    /**
                     * Creates a new PowerCapCommand instance using the specified properties.
                     * @function create
                     * @memberof telemetry.module.gpu.v1.PowerCapCommand
                     * @static
                     * @param {telemetry.module.gpu.v1.IPowerCapCommand=} [properties] Properties to set
                     * @returns {telemetry.module.gpu.v1.PowerCapCommand} PowerCapCommand instance
                     */
                    PowerCapCommand.create = function create(properties) {
                        return new PowerCapCommand(properties);
                    };

                    /**
                     * Encodes the specified PowerCapCommand message. Does not implicitly {@link telemetry.module.gpu.v1.PowerCapCommand.verify|verify} messages.
                     * @function encode
                     * @memberof telemetry.module.gpu.v1.PowerCapCommand
                     * @static
                     * @param {telemetry.module.gpu.v1.IPowerCapCommand} message PowerCapCommand message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    PowerCapCommand.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.gpuIndex != null && Object.hasOwnProperty.call(message, "gpuIndex"))
                            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.gpuIndex);
                        if (message.milliwatt != null && Object.hasOwnProperty.call(message, "milliwatt"))
                            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.milliwatt);
                        return writer;
                    };

                    /**
                     * Encodes the specified PowerCapCommand message, length delimited. Does not implicitly {@link telemetry.module.gpu.v1.PowerCapCommand.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof telemetry.module.gpu.v1.PowerCapCommand
                     * @static
                     * @param {telemetry.module.gpu.v1.IPowerCapCommand} message PowerCapCommand message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    PowerCapCommand.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a PowerCapCommand message from the specified reader or buffer.
                     * @function decode
                     * @memberof telemetry.module.gpu.v1.PowerCapCommand
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {telemetry.module.gpu.v1.PowerCapCommand} PowerCapCommand
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    PowerCapCommand.decode = function decode(reader, length, error) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.telemetry.module.gpu.v1.PowerCapCommand();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            if (tag === error)
                                break;
                            switch (tag >>> 3) {
                            case 1: {
                                    message.gpuIndex = reader.int32();
                                    break;
                                }
                            case 2: {
                                    message.milliwatt = reader.uint32();
                                    break;
                                }
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a PowerCapCommand message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof telemetry.module.gpu.v1.PowerCapCommand
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {telemetry.module.gpu.v1.PowerCapCommand} PowerCapCommand
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    PowerCapCommand.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a PowerCapCommand message.
                     * @function verify
                     * @memberof telemetry.module.gpu.v1.PowerCapCommand
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    PowerCapCommand.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.gpuIndex != null && message.hasOwnProperty("gpuIndex"))
                            if (!$util.isInteger(message.gpuIndex))
                                return "gpuIndex: integer expected";
                        if (message.milliwatt != null && message.hasOwnProperty("milliwatt"))
                            if (!$util.isInteger(message.milliwatt))
                                return "milliwatt: integer expected";
                        return null;
                    };

                    /**
                     * Creates a PowerCapCommand message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof telemetry.module.gpu.v1.PowerCapCommand
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {telemetry.module.gpu.v1.PowerCapCommand} PowerCapCommand
                     */
                    PowerCapCommand.fromObject = function fromObject(object) {
                        if (object instanceof $root.telemetry.module.gpu.v1.PowerCapCommand)
                            return object;
                        let message = new $root.telemetry.module.gpu.v1.PowerCapCommand();
                        if (object.gpuIndex != null)
                            message.gpuIndex = object.gpuIndex | 0;
                        if (object.milliwatt != null)
                            message.milliwatt = object.milliwatt >>> 0;
                        return message;
                    };

                    /**
                     * Creates a plain object from a PowerCapCommand message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof telemetry.module.gpu.v1.PowerCapCommand
                     * @static
                     * @param {telemetry.module.gpu.v1.PowerCapCommand} message PowerCapCommand
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    PowerCapCommand.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.gpuIndex = 0;
                            object.milliwatt = 0;
                        }
                        if (message.gpuIndex != null && message.hasOwnProperty("gpuIndex"))
                            object.gpuIndex = message.gpuIndex;
                        if (message.milliwatt != null && message.hasOwnProperty("milliwatt"))
                            object.milliwatt = message.milliwatt;
                        return object;
                    };

                    /**
                     * Converts this PowerCapCommand to JSON.
                     * @function toJSON
                     * @memberof telemetry.module.gpu.v1.PowerCapCommand
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    PowerCapCommand.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Gets the default type url for PowerCapCommand
                     * @function getTypeUrl
                     * @memberof telemetry.module.gpu.v1.PowerCapCommand
                     * @static
                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                     * @returns {string} The default type url
                     */
                    PowerCapCommand.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                        if (typeUrlPrefix === undefined) {
                            typeUrlPrefix = "type.googleapis.com";
                        }
                        return typeUrlPrefix + "/telemetry.module.gpu.v1.PowerCapCommand";
                    };

                    return PowerCapCommand;
                })();

                return v1;
            })();

            return gpu;
        })();

        module.memory = (function() {

            /**
             * Namespace memory.
             * @memberof telemetry.module
             * @namespace
             */
            const memory = {};

            memory.v1 = (function() {

                /**
                 * Namespace v1.
                 * @memberof telemetry.module.memory
                 * @namespace
                 */
                const v1 = {};

                v1.CollectorSpec = (function() {

                    /**
                     * Properties of a CollectorSpec.
                     * @memberof telemetry.module.memory.v1
                     * @interface ICollectorSpec
                     * @property {string|null} [category] CollectorSpec category
                     * @property {string|null} [interval] CollectorSpec interval
                     */

                    /**
                     * Constructs a new CollectorSpec.
                     * @memberof telemetry.module.memory.v1
                     * @classdesc Represents a CollectorSpec.
                     * @implements ICollectorSpec
                     * @constructor
                     * @param {telemetry.module.memory.v1.ICollectorSpec=} [properties] Properties to set
                     */
                    function CollectorSpec(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * CollectorSpec category.
                     * @member {string} category
                     * @memberof telemetry.module.memory.v1.CollectorSpec
                     * @instance
                     */
                    CollectorSpec.prototype.category = "";

                    /**
                     * CollectorSpec interval.
                     * @member {string} interval
                     * @memberof telemetry.module.memory.v1.CollectorSpec
                     * @instance
                     */
                    CollectorSpec.prototype.interval = "";

                    /**
                     * Creates a new CollectorSpec instance using the specified properties.
                     * @function create
                     * @memberof telemetry.module.memory.v1.CollectorSpec
                     * @static
                     * @param {telemetry.module.memory.v1.ICollectorSpec=} [properties] Properties to set
                     * @returns {telemetry.module.memory.v1.CollectorSpec} CollectorSpec instance
                     */
                    CollectorSpec.create = function create(properties) {
                        return new CollectorSpec(properties);
                    };

                    /**
                     * Encodes the specified CollectorSpec message. Does not implicitly {@link telemetry.module.memory.v1.CollectorSpec.verify|verify} messages.
                     * @function encode
                     * @memberof telemetry.module.memory.v1.CollectorSpec
                     * @static
                     * @param {telemetry.module.memory.v1.ICollectorSpec} message CollectorSpec message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    CollectorSpec.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.category != null && Object.hasOwnProperty.call(message, "category"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.category);
                        if (message.interval != null && Object.hasOwnProperty.call(message, "interval"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.interval);
                        return writer;
                    };

                    /**
                     * Encodes the specified CollectorSpec message, length delimited. Does not implicitly {@link telemetry.module.memory.v1.CollectorSpec.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof telemetry.module.memory.v1.CollectorSpec
                     * @static
                     * @param {telemetry.module.memory.v1.ICollectorSpec} message CollectorSpec message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    CollectorSpec.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a CollectorSpec message from the specified reader or buffer.
                     * @function decode
                     * @memberof telemetry.module.memory.v1.CollectorSpec
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {telemetry.module.memory.v1.CollectorSpec} CollectorSpec
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    CollectorSpec.decode = function decode(reader, length, error) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.telemetry.module.memory.v1.CollectorSpec();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            if (tag === error)
                                break;
                            switch (tag >>> 3) {
                            case 1: {
                                    message.category = reader.string();
                                    break;
                                }
                            case 2: {
                                    message.interval = reader.string();
                                    break;
                                }
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a CollectorSpec message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof telemetry.module.memory.v1.CollectorSpec
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {telemetry.module.memory.v1.CollectorSpec} CollectorSpec
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    CollectorSpec.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a CollectorSpec message.
                     * @function verify
                     * @memberof telemetry.module.memory.v1.CollectorSpec
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    CollectorSpec.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.category != null && message.hasOwnProperty("category"))
                            if (!$util.isString(message.category))
                                return "category: string expected";
                        if (message.interval != null && message.hasOwnProperty("interval"))
                            if (!$util.isString(message.interval))
                                return "interval: string expected";
                        return null;
                    };

                    /**
                     * Creates a CollectorSpec message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof telemetry.module.memory.v1.CollectorSpec
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {telemetry.module.memory.v1.CollectorSpec} CollectorSpec
                     */
                    CollectorSpec.fromObject = function fromObject(object) {
                        if (object instanceof $root.telemetry.module.memory.v1.CollectorSpec)
                            return object;
                        let message = new $root.telemetry.module.memory.v1.CollectorSpec();
                        if (object.category != null)
                            message.category = String(object.category);
                        if (object.interval != null)
                            message.interval = String(object.interval);
                        return message;
                    };

                    /**
                     * Creates a plain object from a CollectorSpec message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof telemetry.module.memory.v1.CollectorSpec
                     * @static
                     * @param {telemetry.module.memory.v1.CollectorSpec} message CollectorSpec
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    CollectorSpec.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.category = "";
                            object.interval = "";
                        }
                        if (message.category != null && message.hasOwnProperty("category"))
                            object.category = message.category;
                        if (message.interval != null && message.hasOwnProperty("interval"))
                            object.interval = message.interval;
                        return object;
                    };

                    /**
                     * Converts this CollectorSpec to JSON.
                     * @function toJSON
                     * @memberof telemetry.module.memory.v1.CollectorSpec
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    CollectorSpec.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Gets the default type url for CollectorSpec
                     * @function getTypeUrl
                     * @memberof telemetry.module.memory.v1.CollectorSpec
                     * @static
                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                     * @returns {string} The default type url
                     */
                    CollectorSpec.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                        if (typeUrlPrefix === undefined) {
                            typeUrlPrefix = "type.googleapis.com";
                        }
                        return typeUrlPrefix + "/telemetry.module.memory.v1.CollectorSpec";
                    };

                    return CollectorSpec;
                })();

                v1.StaticInfo = (function() {

                    /**
                     * Properties of a StaticInfo.
                     * @memberof telemetry.module.memory.v1
                     * @interface IStaticInfo
                     * @property {number|Long|null} [totalBytes] StaticInfo totalBytes
                     */

                    /**
                     * Constructs a new StaticInfo.
                     * @memberof telemetry.module.memory.v1
                     * @classdesc Represents a StaticInfo.
                     * @implements IStaticInfo
                     * @constructor
                     * @param {telemetry.module.memory.v1.IStaticInfo=} [properties] Properties to set
                     */
                    function StaticInfo(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * StaticInfo totalBytes.
                     * @member {number|Long} totalBytes
                     * @memberof telemetry.module.memory.v1.StaticInfo
                     * @instance
                     */
                    StaticInfo.prototype.totalBytes = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                    /**
                     * Creates a new StaticInfo instance using the specified properties.
                     * @function create
                     * @memberof telemetry.module.memory.v1.StaticInfo
                     * @static
                     * @param {telemetry.module.memory.v1.IStaticInfo=} [properties] Properties to set
                     * @returns {telemetry.module.memory.v1.StaticInfo} StaticInfo instance
                     */
                    StaticInfo.create = function create(properties) {
                        return new StaticInfo(properties);
                    };

                    /**
                     * Encodes the specified StaticInfo message. Does not implicitly {@link telemetry.module.memory.v1.StaticInfo.verify|verify} messages.
                     * @function encode
                     * @memberof telemetry.module.memory.v1.StaticInfo
                     * @static
                     * @param {telemetry.module.memory.v1.IStaticInfo} message StaticInfo message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    StaticInfo.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.totalBytes != null && Object.hasOwnProperty.call(message, "totalBytes"))
                            writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.totalBytes);
                        return writer;
                    };

                    /**
                     * Encodes the specified StaticInfo message, length delimited. Does not implicitly {@link telemetry.module.memory.v1.StaticInfo.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof telemetry.module.memory.v1.StaticInfo
                     * @static
                     * @param {telemetry.module.memory.v1.IStaticInfo} message StaticInfo message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    StaticInfo.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a StaticInfo message from the specified reader or buffer.
                     * @function decode
                     * @memberof telemetry.module.memory.v1.StaticInfo
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {telemetry.module.memory.v1.StaticInfo} StaticInfo
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    StaticInfo.decode = function decode(reader, length, error) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.telemetry.module.memory.v1.StaticInfo();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            if (tag === error)
                                break;
                            switch (tag >>> 3) {
                            case 1: {
                                    message.totalBytes = reader.uint64();
                                    break;
                                }
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a StaticInfo message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof telemetry.module.memory.v1.StaticInfo
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {telemetry.module.memory.v1.StaticInfo} StaticInfo
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    StaticInfo.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a StaticInfo message.
                     * @function verify
                     * @memberof telemetry.module.memory.v1.StaticInfo
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    StaticInfo.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.totalBytes != null && message.hasOwnProperty("totalBytes"))
                            if (!$util.isInteger(message.totalBytes) && !(message.totalBytes && $util.isInteger(message.totalBytes.low) && $util.isInteger(message.totalBytes.high)))
                                return "totalBytes: integer|Long expected";
                        return null;
                    };

                    /**
                     * Creates a StaticInfo message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof telemetry.module.memory.v1.StaticInfo
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {telemetry.module.memory.v1.StaticInfo} StaticInfo
                     */
                    StaticInfo.fromObject = function fromObject(object) {
                        if (object instanceof $root.telemetry.module.memory.v1.StaticInfo)
                            return object;
                        let message = new $root.telemetry.module.memory.v1.StaticInfo();
                        if (object.totalBytes != null)
                            if ($util.Long)
                                (message.totalBytes = $util.Long.fromValue(object.totalBytes)).unsigned = true;
                            else if (typeof object.totalBytes === "string")
                                message.totalBytes = parseInt(object.totalBytes, 10);
                            else if (typeof object.totalBytes === "number")
                                message.totalBytes = object.totalBytes;
                            else if (typeof object.totalBytes === "object")
                                message.totalBytes = new $util.LongBits(object.totalBytes.low >>> 0, object.totalBytes.high >>> 0).toNumber(true);
                        return message;
                    };

                    /**
                     * Creates a plain object from a StaticInfo message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof telemetry.module.memory.v1.StaticInfo
                     * @static
                     * @param {telemetry.module.memory.v1.StaticInfo} message StaticInfo
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    StaticInfo.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults)
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, true);
                                object.totalBytes = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.totalBytes = options.longs === String ? "0" : 0;
                        if (message.totalBytes != null && message.hasOwnProperty("totalBytes"))
                            if (typeof message.totalBytes === "number")
                                object.totalBytes = options.longs === String ? String(message.totalBytes) : message.totalBytes;
                            else
                                object.totalBytes = options.longs === String ? $util.Long.prototype.toString.call(message.totalBytes) : options.longs === Number ? new $util.LongBits(message.totalBytes.low >>> 0, message.totalBytes.high >>> 0).toNumber(true) : message.totalBytes;
                        return object;
                    };

                    /**
                     * Converts this StaticInfo to JSON.
                     * @function toJSON
                     * @memberof telemetry.module.memory.v1.StaticInfo
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    StaticInfo.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Gets the default type url for StaticInfo
                     * @function getTypeUrl
                     * @memberof telemetry.module.memory.v1.StaticInfo
                     * @static
                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                     * @returns {string} The default type url
                     */
                    StaticInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                        if (typeUrlPrefix === undefined) {
                            typeUrlPrefix = "type.googleapis.com";
                        }
                        return typeUrlPrefix + "/telemetry.module.memory.v1.StaticInfo";
                    };

                    return StaticInfo;
                })();

                v1.ModuleRegistration = (function() {

                    /**
                     * Properties of a ModuleRegistration.
                     * @memberof telemetry.module.memory.v1
                     * @interface IModuleRegistration
                     * @property {telemetry.module.memory.v1.IStaticInfo|null} ["static"] ModuleRegistration static
                     * @property {Array.<telemetry.module.memory.v1.ICollectorSpec>|null} [collectors] ModuleRegistration collectors
                     */

                    /**
                     * Constructs a new ModuleRegistration.
                     * @memberof telemetry.module.memory.v1
                     * @classdesc Represents a ModuleRegistration.
                     * @implements IModuleRegistration
                     * @constructor
                     * @param {telemetry.module.memory.v1.IModuleRegistration=} [properties] Properties to set
                     */
                    function ModuleRegistration(properties) {
                        this.collectors = [];
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * ModuleRegistration static.
                     * @member {telemetry.module.memory.v1.IStaticInfo|null|undefined} static
                     * @memberof telemetry.module.memory.v1.ModuleRegistration
                     * @instance
                     */
                    ModuleRegistration.prototype["static"] = null;

                    /**
                     * ModuleRegistration collectors.
                     * @member {Array.<telemetry.module.memory.v1.ICollectorSpec>} collectors
                     * @memberof telemetry.module.memory.v1.ModuleRegistration
                     * @instance
                     */
                    ModuleRegistration.prototype.collectors = $util.emptyArray;

                    /**
                     * Creates a new ModuleRegistration instance using the specified properties.
                     * @function create
                     * @memberof telemetry.module.memory.v1.ModuleRegistration
                     * @static
                     * @param {telemetry.module.memory.v1.IModuleRegistration=} [properties] Properties to set
                     * @returns {telemetry.module.memory.v1.ModuleRegistration} ModuleRegistration instance
                     */
                    ModuleRegistration.create = function create(properties) {
                        return new ModuleRegistration(properties);
                    };

                    /**
                     * Encodes the specified ModuleRegistration message. Does not implicitly {@link telemetry.module.memory.v1.ModuleRegistration.verify|verify} messages.
                     * @function encode
                     * @memberof telemetry.module.memory.v1.ModuleRegistration
                     * @static
                     * @param {telemetry.module.memory.v1.IModuleRegistration} message ModuleRegistration message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ModuleRegistration.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message["static"] != null && Object.hasOwnProperty.call(message, "static"))
                            $root.telemetry.module.memory.v1.StaticInfo.encode(message["static"], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.collectors != null && message.collectors.length)
                            for (let i = 0; i < message.collectors.length; ++i)
                                $root.telemetry.module.memory.v1.CollectorSpec.encode(message.collectors[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                        return writer;
                    };

                    /**
                     * Encodes the specified ModuleRegistration message, length delimited. Does not implicitly {@link telemetry.module.memory.v1.ModuleRegistration.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof telemetry.module.memory.v1.ModuleRegistration
                     * @static
                     * @param {telemetry.module.memory.v1.IModuleRegistration} message ModuleRegistration message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ModuleRegistration.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a ModuleRegistration message from the specified reader or buffer.
                     * @function decode
                     * @memberof telemetry.module.memory.v1.ModuleRegistration
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {telemetry.module.memory.v1.ModuleRegistration} ModuleRegistration
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ModuleRegistration.decode = function decode(reader, length, error) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.telemetry.module.memory.v1.ModuleRegistration();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            if (tag === error)
                                break;
                            switch (tag >>> 3) {
                            case 1: {
                                    message["static"] = $root.telemetry.module.memory.v1.StaticInfo.decode(reader, reader.uint32());
                                    break;
                                }
                            case 2: {
                                    if (!(message.collectors && message.collectors.length))
                                        message.collectors = [];
                                    message.collectors.push($root.telemetry.module.memory.v1.CollectorSpec.decode(reader, reader.uint32()));
                                    break;
                                }
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a ModuleRegistration message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof telemetry.module.memory.v1.ModuleRegistration
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {telemetry.module.memory.v1.ModuleRegistration} ModuleRegistration
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ModuleRegistration.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a ModuleRegistration message.
                     * @function verify
                     * @memberof telemetry.module.memory.v1.ModuleRegistration
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    ModuleRegistration.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message["static"] != null && message.hasOwnProperty("static")) {
                            let error = $root.telemetry.module.memory.v1.StaticInfo.verify(message["static"]);
                            if (error)
                                return "static." + error;
                        }
                        if (message.collectors != null && message.hasOwnProperty("collectors")) {
                            if (!Array.isArray(message.collectors))
                                return "collectors: array expected";
                            for (let i = 0; i < message.collectors.length; ++i) {
                                let error = $root.telemetry.module.memory.v1.CollectorSpec.verify(message.collectors[i]);
                                if (error)
                                    return "collectors." + error;
                            }
                        }
                        return null;
                    };

                    /**
                     * Creates a ModuleRegistration message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof telemetry.module.memory.v1.ModuleRegistration
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {telemetry.module.memory.v1.ModuleRegistration} ModuleRegistration
                     */
                    ModuleRegistration.fromObject = function fromObject(object) {
                        if (object instanceof $root.telemetry.module.memory.v1.ModuleRegistration)
                            return object;
                        let message = new $root.telemetry.module.memory.v1.ModuleRegistration();
                        if (object["static"] != null) {
                            if (typeof object["static"] !== "object")
                                throw TypeError(".telemetry.module.memory.v1.ModuleRegistration.static: object expected");
                            message["static"] = $root.telemetry.module.memory.v1.StaticInfo.fromObject(object["static"]);
                        }
                        if (object.collectors) {
                            if (!Array.isArray(object.collectors))
                                throw TypeError(".telemetry.module.memory.v1.ModuleRegistration.collectors: array expected");
                            message.collectors = [];
                            for (let i = 0; i < object.collectors.length; ++i) {
                                if (typeof object.collectors[i] !== "object")
                                    throw TypeError(".telemetry.module.memory.v1.ModuleRegistration.collectors: object expected");
                                message.collectors[i] = $root.telemetry.module.memory.v1.CollectorSpec.fromObject(object.collectors[i]);
                            }
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a ModuleRegistration message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof telemetry.module.memory.v1.ModuleRegistration
                     * @static
                     * @param {telemetry.module.memory.v1.ModuleRegistration} message ModuleRegistration
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    ModuleRegistration.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.arrays || options.defaults)
                            object.collectors = [];
                        if (options.defaults)
                            object["static"] = null;
                        if (message["static"] != null && message.hasOwnProperty("static"))
                            object["static"] = $root.telemetry.module.memory.v1.StaticInfo.toObject(message["static"], options);
                        if (message.collectors && message.collectors.length) {
                            object.collectors = [];
                            for (let j = 0; j < message.collectors.length; ++j)
                                object.collectors[j] = $root.telemetry.module.memory.v1.CollectorSpec.toObject(message.collectors[j], options);
                        }
                        return object;
                    };

                    /**
                     * Converts this ModuleRegistration to JSON.
                     * @function toJSON
                     * @memberof telemetry.module.memory.v1.ModuleRegistration
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    ModuleRegistration.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Gets the default type url for ModuleRegistration
                     * @function getTypeUrl
                     * @memberof telemetry.module.memory.v1.ModuleRegistration
                     * @static
                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                     * @returns {string} The default type url
                     */
                    ModuleRegistration.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                        if (typeUrlPrefix === undefined) {
                            typeUrlPrefix = "type.googleapis.com";
                        }
                        return typeUrlPrefix + "/telemetry.module.memory.v1.ModuleRegistration";
                    };

                    return ModuleRegistration;
                })();

                v1.Metrics = (function() {

                    /**
                     * Properties of a Metrics.
                     * @memberof telemetry.module.memory.v1
                     * @interface IMetrics
                     * @property {number|Long|null} [usedBytes] Metrics usedBytes
                     * @property {number|Long|null} [freeBytes] Metrics freeBytes
                     * @property {number|Long|null} [availableBytes] Metrics availableBytes
                     * @property {number|Long|null} [cachedBytes] Metrics cachedBytes
                     * @property {number|Long|null} [buffersBytes] Metrics buffersBytes
                     * @property {number|Long|null} [sampledAtUnixNano] Metrics sampledAtUnixNano
                     */

                    /**
                     * Constructs a new Metrics.
                     * @memberof telemetry.module.memory.v1
                     * @classdesc Represents a Metrics.
                     * @implements IMetrics
                     * @constructor
                     * @param {telemetry.module.memory.v1.IMetrics=} [properties] Properties to set
                     */
                    function Metrics(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Metrics usedBytes.
                     * @member {number|Long} usedBytes
                     * @memberof telemetry.module.memory.v1.Metrics
                     * @instance
                     */
                    Metrics.prototype.usedBytes = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                    /**
                     * Metrics freeBytes.
                     * @member {number|Long} freeBytes
                     * @memberof telemetry.module.memory.v1.Metrics
                     * @instance
                     */
                    Metrics.prototype.freeBytes = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                    /**
                     * Metrics availableBytes.
                     * @member {number|Long} availableBytes
                     * @memberof telemetry.module.memory.v1.Metrics
                     * @instance
                     */
                    Metrics.prototype.availableBytes = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                    /**
                     * Metrics cachedBytes.
                     * @member {number|Long} cachedBytes
                     * @memberof telemetry.module.memory.v1.Metrics
                     * @instance
                     */
                    Metrics.prototype.cachedBytes = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                    /**
                     * Metrics buffersBytes.
                     * @member {number|Long} buffersBytes
                     * @memberof telemetry.module.memory.v1.Metrics
                     * @instance
                     */
                    Metrics.prototype.buffersBytes = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                    /**
                     * Metrics sampledAtUnixNano.
                     * @member {number|Long} sampledAtUnixNano
                     * @memberof telemetry.module.memory.v1.Metrics
                     * @instance
                     */
                    Metrics.prototype.sampledAtUnixNano = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                    /**
                     * Creates a new Metrics instance using the specified properties.
                     * @function create
                     * @memberof telemetry.module.memory.v1.Metrics
                     * @static
                     * @param {telemetry.module.memory.v1.IMetrics=} [properties] Properties to set
                     * @returns {telemetry.module.memory.v1.Metrics} Metrics instance
                     */
                    Metrics.create = function create(properties) {
                        return new Metrics(properties);
                    };

                    /**
                     * Encodes the specified Metrics message. Does not implicitly {@link telemetry.module.memory.v1.Metrics.verify|verify} messages.
                     * @function encode
                     * @memberof telemetry.module.memory.v1.Metrics
                     * @static
                     * @param {telemetry.module.memory.v1.IMetrics} message Metrics message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Metrics.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.usedBytes != null && Object.hasOwnProperty.call(message, "usedBytes"))
                            writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.usedBytes);
                        if (message.freeBytes != null && Object.hasOwnProperty.call(message, "freeBytes"))
                            writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.freeBytes);
                        if (message.availableBytes != null && Object.hasOwnProperty.call(message, "availableBytes"))
                            writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.availableBytes);
                        if (message.cachedBytes != null && Object.hasOwnProperty.call(message, "cachedBytes"))
                            writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.cachedBytes);
                        if (message.buffersBytes != null && Object.hasOwnProperty.call(message, "buffersBytes"))
                            writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.buffersBytes);
                        if (message.sampledAtUnixNano != null && Object.hasOwnProperty.call(message, "sampledAtUnixNano"))
                            writer.uint32(/* id 6, wireType 0 =*/48).int64(message.sampledAtUnixNano);
                        return writer;
                    };

                    /**
                     * Encodes the specified Metrics message, length delimited. Does not implicitly {@link telemetry.module.memory.v1.Metrics.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof telemetry.module.memory.v1.Metrics
                     * @static
                     * @param {telemetry.module.memory.v1.IMetrics} message Metrics message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Metrics.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Metrics message from the specified reader or buffer.
                     * @function decode
                     * @memberof telemetry.module.memory.v1.Metrics
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {telemetry.module.memory.v1.Metrics} Metrics
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Metrics.decode = function decode(reader, length, error) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.telemetry.module.memory.v1.Metrics();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            if (tag === error)
                                break;
                            switch (tag >>> 3) {
                            case 1: {
                                    message.usedBytes = reader.uint64();
                                    break;
                                }
                            case 2: {
                                    message.freeBytes = reader.uint64();
                                    break;
                                }
                            case 3: {
                                    message.availableBytes = reader.uint64();
                                    break;
                                }
                            case 4: {
                                    message.cachedBytes = reader.uint64();
                                    break;
                                }
                            case 5: {
                                    message.buffersBytes = reader.uint64();
                                    break;
                                }
                            case 6: {
                                    message.sampledAtUnixNano = reader.int64();
                                    break;
                                }
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Metrics message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof telemetry.module.memory.v1.Metrics
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {telemetry.module.memory.v1.Metrics} Metrics
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Metrics.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Metrics message.
                     * @function verify
                     * @memberof telemetry.module.memory.v1.Metrics
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Metrics.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.usedBytes != null && message.hasOwnProperty("usedBytes"))
                            if (!$util.isInteger(message.usedBytes) && !(message.usedBytes && $util.isInteger(message.usedBytes.low) && $util.isInteger(message.usedBytes.high)))
                                return "usedBytes: integer|Long expected";
                        if (message.freeBytes != null && message.hasOwnProperty("freeBytes"))
                            if (!$util.isInteger(message.freeBytes) && !(message.freeBytes && $util.isInteger(message.freeBytes.low) && $util.isInteger(message.freeBytes.high)))
                                return "freeBytes: integer|Long expected";
                        if (message.availableBytes != null && message.hasOwnProperty("availableBytes"))
                            if (!$util.isInteger(message.availableBytes) && !(message.availableBytes && $util.isInteger(message.availableBytes.low) && $util.isInteger(message.availableBytes.high)))
                                return "availableBytes: integer|Long expected";
                        if (message.cachedBytes != null && message.hasOwnProperty("cachedBytes"))
                            if (!$util.isInteger(message.cachedBytes) && !(message.cachedBytes && $util.isInteger(message.cachedBytes.low) && $util.isInteger(message.cachedBytes.high)))
                                return "cachedBytes: integer|Long expected";
                        if (message.buffersBytes != null && message.hasOwnProperty("buffersBytes"))
                            if (!$util.isInteger(message.buffersBytes) && !(message.buffersBytes && $util.isInteger(message.buffersBytes.low) && $util.isInteger(message.buffersBytes.high)))
                                return "buffersBytes: integer|Long expected";
                        if (message.sampledAtUnixNano != null && message.hasOwnProperty("sampledAtUnixNano"))
                            if (!$util.isInteger(message.sampledAtUnixNano) && !(message.sampledAtUnixNano && $util.isInteger(message.sampledAtUnixNano.low) && $util.isInteger(message.sampledAtUnixNano.high)))
                                return "sampledAtUnixNano: integer|Long expected";
                        return null;
                    };

                    /**
                     * Creates a Metrics message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof telemetry.module.memory.v1.Metrics
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {telemetry.module.memory.v1.Metrics} Metrics
                     */
                    Metrics.fromObject = function fromObject(object) {
                        if (object instanceof $root.telemetry.module.memory.v1.Metrics)
                            return object;
                        let message = new $root.telemetry.module.memory.v1.Metrics();
                        if (object.usedBytes != null)
                            if ($util.Long)
                                (message.usedBytes = $util.Long.fromValue(object.usedBytes)).unsigned = true;
                            else if (typeof object.usedBytes === "string")
                                message.usedBytes = parseInt(object.usedBytes, 10);
                            else if (typeof object.usedBytes === "number")
                                message.usedBytes = object.usedBytes;
                            else if (typeof object.usedBytes === "object")
                                message.usedBytes = new $util.LongBits(object.usedBytes.low >>> 0, object.usedBytes.high >>> 0).toNumber(true);
                        if (object.freeBytes != null)
                            if ($util.Long)
                                (message.freeBytes = $util.Long.fromValue(object.freeBytes)).unsigned = true;
                            else if (typeof object.freeBytes === "string")
                                message.freeBytes = parseInt(object.freeBytes, 10);
                            else if (typeof object.freeBytes === "number")
                                message.freeBytes = object.freeBytes;
                            else if (typeof object.freeBytes === "object")
                                message.freeBytes = new $util.LongBits(object.freeBytes.low >>> 0, object.freeBytes.high >>> 0).toNumber(true);
                        if (object.availableBytes != null)
                            if ($util.Long)
                                (message.availableBytes = $util.Long.fromValue(object.availableBytes)).unsigned = true;
                            else if (typeof object.availableBytes === "string")
                                message.availableBytes = parseInt(object.availableBytes, 10);
                            else if (typeof object.availableBytes === "number")
                                message.availableBytes = object.availableBytes;
                            else if (typeof object.availableBytes === "object")
                                message.availableBytes = new $util.LongBits(object.availableBytes.low >>> 0, object.availableBytes.high >>> 0).toNumber(true);
                        if (object.cachedBytes != null)
                            if ($util.Long)
                                (message.cachedBytes = $util.Long.fromValue(object.cachedBytes)).unsigned = true;
                            else if (typeof object.cachedBytes === "string")
                                message.cachedBytes = parseInt(object.cachedBytes, 10);
                            else if (typeof object.cachedBytes === "number")
                                message.cachedBytes = object.cachedBytes;
                            else if (typeof object.cachedBytes === "object")
                                message.cachedBytes = new $util.LongBits(object.cachedBytes.low >>> 0, object.cachedBytes.high >>> 0).toNumber(true);
                        if (object.buffersBytes != null)
                            if ($util.Long)
                                (message.buffersBytes = $util.Long.fromValue(object.buffersBytes)).unsigned = true;
                            else if (typeof object.buffersBytes === "string")
                                message.buffersBytes = parseInt(object.buffersBytes, 10);
                            else if (typeof object.buffersBytes === "number")
                                message.buffersBytes = object.buffersBytes;
                            else if (typeof object.buffersBytes === "object")
                                message.buffersBytes = new $util.LongBits(object.buffersBytes.low >>> 0, object.buffersBytes.high >>> 0).toNumber(true);
                        if (object.sampledAtUnixNano != null)
                            if ($util.Long)
                                (message.sampledAtUnixNano = $util.Long.fromValue(object.sampledAtUnixNano)).unsigned = false;
                            else if (typeof object.sampledAtUnixNano === "string")
                                message.sampledAtUnixNano = parseInt(object.sampledAtUnixNano, 10);
                            else if (typeof object.sampledAtUnixNano === "number")
                                message.sampledAtUnixNano = object.sampledAtUnixNano;
                            else if (typeof object.sampledAtUnixNano === "object")
                                message.sampledAtUnixNano = new $util.LongBits(object.sampledAtUnixNano.low >>> 0, object.sampledAtUnixNano.high >>> 0).toNumber();
                        return message;
                    };

                    /**
                     * Creates a plain object from a Metrics message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof telemetry.module.memory.v1.Metrics
                     * @static
                     * @param {telemetry.module.memory.v1.Metrics} message Metrics
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Metrics.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, true);
                                object.usedBytes = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.usedBytes = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, true);
                                object.freeBytes = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.freeBytes = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, true);
                                object.availableBytes = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.availableBytes = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, true);
                                object.cachedBytes = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.cachedBytes = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, true);
                                object.buffersBytes = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.buffersBytes = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, false);
                                object.sampledAtUnixNano = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.sampledAtUnixNano = options.longs === String ? "0" : 0;
                        }
                        if (message.usedBytes != null && message.hasOwnProperty("usedBytes"))
                            if (typeof message.usedBytes === "number")
                                object.usedBytes = options.longs === String ? String(message.usedBytes) : message.usedBytes;
                            else
                                object.usedBytes = options.longs === String ? $util.Long.prototype.toString.call(message.usedBytes) : options.longs === Number ? new $util.LongBits(message.usedBytes.low >>> 0, message.usedBytes.high >>> 0).toNumber(true) : message.usedBytes;
                        if (message.freeBytes != null && message.hasOwnProperty("freeBytes"))
                            if (typeof message.freeBytes === "number")
                                object.freeBytes = options.longs === String ? String(message.freeBytes) : message.freeBytes;
                            else
                                object.freeBytes = options.longs === String ? $util.Long.prototype.toString.call(message.freeBytes) : options.longs === Number ? new $util.LongBits(message.freeBytes.low >>> 0, message.freeBytes.high >>> 0).toNumber(true) : message.freeBytes;
                        if (message.availableBytes != null && message.hasOwnProperty("availableBytes"))
                            if (typeof message.availableBytes === "number")
                                object.availableBytes = options.longs === String ? String(message.availableBytes) : message.availableBytes;
                            else
                                object.availableBytes = options.longs === String ? $util.Long.prototype.toString.call(message.availableBytes) : options.longs === Number ? new $util.LongBits(message.availableBytes.low >>> 0, message.availableBytes.high >>> 0).toNumber(true) : message.availableBytes;
                        if (message.cachedBytes != null && message.hasOwnProperty("cachedBytes"))
                            if (typeof message.cachedBytes === "number")
                                object.cachedBytes = options.longs === String ? String(message.cachedBytes) : message.cachedBytes;
                            else
                                object.cachedBytes = options.longs === String ? $util.Long.prototype.toString.call(message.cachedBytes) : options.longs === Number ? new $util.LongBits(message.cachedBytes.low >>> 0, message.cachedBytes.high >>> 0).toNumber(true) : message.cachedBytes;
                        if (message.buffersBytes != null && message.hasOwnProperty("buffersBytes"))
                            if (typeof message.buffersBytes === "number")
                                object.buffersBytes = options.longs === String ? String(message.buffersBytes) : message.buffersBytes;
                            else
                                object.buffersBytes = options.longs === String ? $util.Long.prototype.toString.call(message.buffersBytes) : options.longs === Number ? new $util.LongBits(message.buffersBytes.low >>> 0, message.buffersBytes.high >>> 0).toNumber(true) : message.buffersBytes;
                        if (message.sampledAtUnixNano != null && message.hasOwnProperty("sampledAtUnixNano"))
                            if (typeof message.sampledAtUnixNano === "number")
                                object.sampledAtUnixNano = options.longs === String ? String(message.sampledAtUnixNano) : message.sampledAtUnixNano;
                            else
                                object.sampledAtUnixNano = options.longs === String ? $util.Long.prototype.toString.call(message.sampledAtUnixNano) : options.longs === Number ? new $util.LongBits(message.sampledAtUnixNano.low >>> 0, message.sampledAtUnixNano.high >>> 0).toNumber() : message.sampledAtUnixNano;
                        return object;
                    };

                    /**
                     * Converts this Metrics to JSON.
                     * @function toJSON
                     * @memberof telemetry.module.memory.v1.Metrics
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Metrics.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Gets the default type url for Metrics
                     * @function getTypeUrl
                     * @memberof telemetry.module.memory.v1.Metrics
                     * @static
                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                     * @returns {string} The default type url
                     */
                    Metrics.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                        if (typeUrlPrefix === undefined) {
                            typeUrlPrefix = "type.googleapis.com";
                        }
                        return typeUrlPrefix + "/telemetry.module.memory.v1.Metrics";
                    };

                    return Metrics;
                })();

                return v1;
            })();

            return memory;
        })();

        module.storage = (function() {

            /**
             * Namespace storage.
             * @memberof telemetry.module
             * @namespace
             */
            const storage = {};

            storage.v1 = (function() {

                /**
                 * Namespace v1.
                 * @memberof telemetry.module.storage
                 * @namespace
                 */
                const v1 = {};

                v1.CollectorSpec = (function() {

                    /**
                     * Properties of a CollectorSpec.
                     * @memberof telemetry.module.storage.v1
                     * @interface ICollectorSpec
                     * @property {string|null} [category] CollectorSpec category
                     * @property {string|null} [interval] CollectorSpec interval
                     */

                    /**
                     * Constructs a new CollectorSpec.
                     * @memberof telemetry.module.storage.v1
                     * @classdesc Represents a CollectorSpec.
                     * @implements ICollectorSpec
                     * @constructor
                     * @param {telemetry.module.storage.v1.ICollectorSpec=} [properties] Properties to set
                     */
                    function CollectorSpec(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * CollectorSpec category.
                     * @member {string} category
                     * @memberof telemetry.module.storage.v1.CollectorSpec
                     * @instance
                     */
                    CollectorSpec.prototype.category = "";

                    /**
                     * CollectorSpec interval.
                     * @member {string} interval
                     * @memberof telemetry.module.storage.v1.CollectorSpec
                     * @instance
                     */
                    CollectorSpec.prototype.interval = "";

                    /**
                     * Creates a new CollectorSpec instance using the specified properties.
                     * @function create
                     * @memberof telemetry.module.storage.v1.CollectorSpec
                     * @static
                     * @param {telemetry.module.storage.v1.ICollectorSpec=} [properties] Properties to set
                     * @returns {telemetry.module.storage.v1.CollectorSpec} CollectorSpec instance
                     */
                    CollectorSpec.create = function create(properties) {
                        return new CollectorSpec(properties);
                    };

                    /**
                     * Encodes the specified CollectorSpec message. Does not implicitly {@link telemetry.module.storage.v1.CollectorSpec.verify|verify} messages.
                     * @function encode
                     * @memberof telemetry.module.storage.v1.CollectorSpec
                     * @static
                     * @param {telemetry.module.storage.v1.ICollectorSpec} message CollectorSpec message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    CollectorSpec.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.category != null && Object.hasOwnProperty.call(message, "category"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.category);
                        if (message.interval != null && Object.hasOwnProperty.call(message, "interval"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.interval);
                        return writer;
                    };

                    /**
                     * Encodes the specified CollectorSpec message, length delimited. Does not implicitly {@link telemetry.module.storage.v1.CollectorSpec.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof telemetry.module.storage.v1.CollectorSpec
                     * @static
                     * @param {telemetry.module.storage.v1.ICollectorSpec} message CollectorSpec message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    CollectorSpec.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a CollectorSpec message from the specified reader or buffer.
                     * @function decode
                     * @memberof telemetry.module.storage.v1.CollectorSpec
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {telemetry.module.storage.v1.CollectorSpec} CollectorSpec
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    CollectorSpec.decode = function decode(reader, length, error) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.telemetry.module.storage.v1.CollectorSpec();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            if (tag === error)
                                break;
                            switch (tag >>> 3) {
                            case 1: {
                                    message.category = reader.string();
                                    break;
                                }
                            case 2: {
                                    message.interval = reader.string();
                                    break;
                                }
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a CollectorSpec message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof telemetry.module.storage.v1.CollectorSpec
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {telemetry.module.storage.v1.CollectorSpec} CollectorSpec
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    CollectorSpec.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a CollectorSpec message.
                     * @function verify
                     * @memberof telemetry.module.storage.v1.CollectorSpec
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    CollectorSpec.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.category != null && message.hasOwnProperty("category"))
                            if (!$util.isString(message.category))
                                return "category: string expected";
                        if (message.interval != null && message.hasOwnProperty("interval"))
                            if (!$util.isString(message.interval))
                                return "interval: string expected";
                        return null;
                    };

                    /**
                     * Creates a CollectorSpec message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof telemetry.module.storage.v1.CollectorSpec
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {telemetry.module.storage.v1.CollectorSpec} CollectorSpec
                     */
                    CollectorSpec.fromObject = function fromObject(object) {
                        if (object instanceof $root.telemetry.module.storage.v1.CollectorSpec)
                            return object;
                        let message = new $root.telemetry.module.storage.v1.CollectorSpec();
                        if (object.category != null)
                            message.category = String(object.category);
                        if (object.interval != null)
                            message.interval = String(object.interval);
                        return message;
                    };

                    /**
                     * Creates a plain object from a CollectorSpec message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof telemetry.module.storage.v1.CollectorSpec
                     * @static
                     * @param {telemetry.module.storage.v1.CollectorSpec} message CollectorSpec
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    CollectorSpec.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.category = "";
                            object.interval = "";
                        }
                        if (message.category != null && message.hasOwnProperty("category"))
                            object.category = message.category;
                        if (message.interval != null && message.hasOwnProperty("interval"))
                            object.interval = message.interval;
                        return object;
                    };

                    /**
                     * Converts this CollectorSpec to JSON.
                     * @function toJSON
                     * @memberof telemetry.module.storage.v1.CollectorSpec
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    CollectorSpec.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Gets the default type url for CollectorSpec
                     * @function getTypeUrl
                     * @memberof telemetry.module.storage.v1.CollectorSpec
                     * @static
                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                     * @returns {string} The default type url
                     */
                    CollectorSpec.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                        if (typeUrlPrefix === undefined) {
                            typeUrlPrefix = "type.googleapis.com";
                        }
                        return typeUrlPrefix + "/telemetry.module.storage.v1.CollectorSpec";
                    };

                    return CollectorSpec;
                })();

                v1.StaticDiskInfo = (function() {

                    /**
                     * Properties of a StaticDiskInfo.
                     * @memberof telemetry.module.storage.v1
                     * @interface IStaticDiskInfo
                     * @property {string|null} [name] StaticDiskInfo name
                     * @property {string|null} [mountpoint] StaticDiskInfo mountpoint
                     * @property {string|null} [filesystem] StaticDiskInfo filesystem
                     * @property {number|Long|null} [totalBytes] StaticDiskInfo totalBytes
                     */

                    /**
                     * Constructs a new StaticDiskInfo.
                     * @memberof telemetry.module.storage.v1
                     * @classdesc Represents a StaticDiskInfo.
                     * @implements IStaticDiskInfo
                     * @constructor
                     * @param {telemetry.module.storage.v1.IStaticDiskInfo=} [properties] Properties to set
                     */
                    function StaticDiskInfo(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * StaticDiskInfo name.
                     * @member {string} name
                     * @memberof telemetry.module.storage.v1.StaticDiskInfo
                     * @instance
                     */
                    StaticDiskInfo.prototype.name = "";

                    /**
                     * StaticDiskInfo mountpoint.
                     * @member {string} mountpoint
                     * @memberof telemetry.module.storage.v1.StaticDiskInfo
                     * @instance
                     */
                    StaticDiskInfo.prototype.mountpoint = "";

                    /**
                     * StaticDiskInfo filesystem.
                     * @member {string} filesystem
                     * @memberof telemetry.module.storage.v1.StaticDiskInfo
                     * @instance
                     */
                    StaticDiskInfo.prototype.filesystem = "";

                    /**
                     * StaticDiskInfo totalBytes.
                     * @member {number|Long} totalBytes
                     * @memberof telemetry.module.storage.v1.StaticDiskInfo
                     * @instance
                     */
                    StaticDiskInfo.prototype.totalBytes = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                    /**
                     * Creates a new StaticDiskInfo instance using the specified properties.
                     * @function create
                     * @memberof telemetry.module.storage.v1.StaticDiskInfo
                     * @static
                     * @param {telemetry.module.storage.v1.IStaticDiskInfo=} [properties] Properties to set
                     * @returns {telemetry.module.storage.v1.StaticDiskInfo} StaticDiskInfo instance
                     */
                    StaticDiskInfo.create = function create(properties) {
                        return new StaticDiskInfo(properties);
                    };

                    /**
                     * Encodes the specified StaticDiskInfo message. Does not implicitly {@link telemetry.module.storage.v1.StaticDiskInfo.verify|verify} messages.
                     * @function encode
                     * @memberof telemetry.module.storage.v1.StaticDiskInfo
                     * @static
                     * @param {telemetry.module.storage.v1.IStaticDiskInfo} message StaticDiskInfo message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    StaticDiskInfo.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                        if (message.mountpoint != null && Object.hasOwnProperty.call(message, "mountpoint"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.mountpoint);
                        if (message.filesystem != null && Object.hasOwnProperty.call(message, "filesystem"))
                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.filesystem);
                        if (message.totalBytes != null && Object.hasOwnProperty.call(message, "totalBytes"))
                            writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.totalBytes);
                        return writer;
                    };

                    /**
                     * Encodes the specified StaticDiskInfo message, length delimited. Does not implicitly {@link telemetry.module.storage.v1.StaticDiskInfo.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof telemetry.module.storage.v1.StaticDiskInfo
                     * @static
                     * @param {telemetry.module.storage.v1.IStaticDiskInfo} message StaticDiskInfo message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    StaticDiskInfo.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a StaticDiskInfo message from the specified reader or buffer.
                     * @function decode
                     * @memberof telemetry.module.storage.v1.StaticDiskInfo
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {telemetry.module.storage.v1.StaticDiskInfo} StaticDiskInfo
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    StaticDiskInfo.decode = function decode(reader, length, error) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.telemetry.module.storage.v1.StaticDiskInfo();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            if (tag === error)
                                break;
                            switch (tag >>> 3) {
                            case 1: {
                                    message.name = reader.string();
                                    break;
                                }
                            case 2: {
                                    message.mountpoint = reader.string();
                                    break;
                                }
                            case 3: {
                                    message.filesystem = reader.string();
                                    break;
                                }
                            case 4: {
                                    message.totalBytes = reader.uint64();
                                    break;
                                }
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a StaticDiskInfo message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof telemetry.module.storage.v1.StaticDiskInfo
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {telemetry.module.storage.v1.StaticDiskInfo} StaticDiskInfo
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    StaticDiskInfo.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a StaticDiskInfo message.
                     * @function verify
                     * @memberof telemetry.module.storage.v1.StaticDiskInfo
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    StaticDiskInfo.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.name != null && message.hasOwnProperty("name"))
                            if (!$util.isString(message.name))
                                return "name: string expected";
                        if (message.mountpoint != null && message.hasOwnProperty("mountpoint"))
                            if (!$util.isString(message.mountpoint))
                                return "mountpoint: string expected";
                        if (message.filesystem != null && message.hasOwnProperty("filesystem"))
                            if (!$util.isString(message.filesystem))
                                return "filesystem: string expected";
                        if (message.totalBytes != null && message.hasOwnProperty("totalBytes"))
                            if (!$util.isInteger(message.totalBytes) && !(message.totalBytes && $util.isInteger(message.totalBytes.low) && $util.isInteger(message.totalBytes.high)))
                                return "totalBytes: integer|Long expected";
                        return null;
                    };

                    /**
                     * Creates a StaticDiskInfo message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof telemetry.module.storage.v1.StaticDiskInfo
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {telemetry.module.storage.v1.StaticDiskInfo} StaticDiskInfo
                     */
                    StaticDiskInfo.fromObject = function fromObject(object) {
                        if (object instanceof $root.telemetry.module.storage.v1.StaticDiskInfo)
                            return object;
                        let message = new $root.telemetry.module.storage.v1.StaticDiskInfo();
                        if (object.name != null)
                            message.name = String(object.name);
                        if (object.mountpoint != null)
                            message.mountpoint = String(object.mountpoint);
                        if (object.filesystem != null)
                            message.filesystem = String(object.filesystem);
                        if (object.totalBytes != null)
                            if ($util.Long)
                                (message.totalBytes = $util.Long.fromValue(object.totalBytes)).unsigned = true;
                            else if (typeof object.totalBytes === "string")
                                message.totalBytes = parseInt(object.totalBytes, 10);
                            else if (typeof object.totalBytes === "number")
                                message.totalBytes = object.totalBytes;
                            else if (typeof object.totalBytes === "object")
                                message.totalBytes = new $util.LongBits(object.totalBytes.low >>> 0, object.totalBytes.high >>> 0).toNumber(true);
                        return message;
                    };

                    /**
                     * Creates a plain object from a StaticDiskInfo message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof telemetry.module.storage.v1.StaticDiskInfo
                     * @static
                     * @param {telemetry.module.storage.v1.StaticDiskInfo} message StaticDiskInfo
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    StaticDiskInfo.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.name = "";
                            object.mountpoint = "";
                            object.filesystem = "";
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, true);
                                object.totalBytes = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.totalBytes = options.longs === String ? "0" : 0;
                        }
                        if (message.name != null && message.hasOwnProperty("name"))
                            object.name = message.name;
                        if (message.mountpoint != null && message.hasOwnProperty("mountpoint"))
                            object.mountpoint = message.mountpoint;
                        if (message.filesystem != null && message.hasOwnProperty("filesystem"))
                            object.filesystem = message.filesystem;
                        if (message.totalBytes != null && message.hasOwnProperty("totalBytes"))
                            if (typeof message.totalBytes === "number")
                                object.totalBytes = options.longs === String ? String(message.totalBytes) : message.totalBytes;
                            else
                                object.totalBytes = options.longs === String ? $util.Long.prototype.toString.call(message.totalBytes) : options.longs === Number ? new $util.LongBits(message.totalBytes.low >>> 0, message.totalBytes.high >>> 0).toNumber(true) : message.totalBytes;
                        return object;
                    };

                    /**
                     * Converts this StaticDiskInfo to JSON.
                     * @function toJSON
                     * @memberof telemetry.module.storage.v1.StaticDiskInfo
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    StaticDiskInfo.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Gets the default type url for StaticDiskInfo
                     * @function getTypeUrl
                     * @memberof telemetry.module.storage.v1.StaticDiskInfo
                     * @static
                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                     * @returns {string} The default type url
                     */
                    StaticDiskInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                        if (typeUrlPrefix === undefined) {
                            typeUrlPrefix = "type.googleapis.com";
                        }
                        return typeUrlPrefix + "/telemetry.module.storage.v1.StaticDiskInfo";
                    };

                    return StaticDiskInfo;
                })();

                v1.ModuleRegistration = (function() {

                    /**
                     * Properties of a ModuleRegistration.
                     * @memberof telemetry.module.storage.v1
                     * @interface IModuleRegistration
                     * @property {Array.<telemetry.module.storage.v1.ICollectorSpec>|null} [collectors] ModuleRegistration collectors
                     * @property {Array.<telemetry.module.storage.v1.IStaticDiskInfo>|null} [staticDisks] ModuleRegistration staticDisks
                     */

                    /**
                     * Constructs a new ModuleRegistration.
                     * @memberof telemetry.module.storage.v1
                     * @classdesc Represents a ModuleRegistration.
                     * @implements IModuleRegistration
                     * @constructor
                     * @param {telemetry.module.storage.v1.IModuleRegistration=} [properties] Properties to set
                     */
                    function ModuleRegistration(properties) {
                        this.collectors = [];
                        this.staticDisks = [];
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * ModuleRegistration collectors.
                     * @member {Array.<telemetry.module.storage.v1.ICollectorSpec>} collectors
                     * @memberof telemetry.module.storage.v1.ModuleRegistration
                     * @instance
                     */
                    ModuleRegistration.prototype.collectors = $util.emptyArray;

                    /**
                     * ModuleRegistration staticDisks.
                     * @member {Array.<telemetry.module.storage.v1.IStaticDiskInfo>} staticDisks
                     * @memberof telemetry.module.storage.v1.ModuleRegistration
                     * @instance
                     */
                    ModuleRegistration.prototype.staticDisks = $util.emptyArray;

                    /**
                     * Creates a new ModuleRegistration instance using the specified properties.
                     * @function create
                     * @memberof telemetry.module.storage.v1.ModuleRegistration
                     * @static
                     * @param {telemetry.module.storage.v1.IModuleRegistration=} [properties] Properties to set
                     * @returns {telemetry.module.storage.v1.ModuleRegistration} ModuleRegistration instance
                     */
                    ModuleRegistration.create = function create(properties) {
                        return new ModuleRegistration(properties);
                    };

                    /**
                     * Encodes the specified ModuleRegistration message. Does not implicitly {@link telemetry.module.storage.v1.ModuleRegistration.verify|verify} messages.
                     * @function encode
                     * @memberof telemetry.module.storage.v1.ModuleRegistration
                     * @static
                     * @param {telemetry.module.storage.v1.IModuleRegistration} message ModuleRegistration message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ModuleRegistration.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.collectors != null && message.collectors.length)
                            for (let i = 0; i < message.collectors.length; ++i)
                                $root.telemetry.module.storage.v1.CollectorSpec.encode(message.collectors[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.staticDisks != null && message.staticDisks.length)
                            for (let i = 0; i < message.staticDisks.length; ++i)
                                $root.telemetry.module.storage.v1.StaticDiskInfo.encode(message.staticDisks[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                        return writer;
                    };

                    /**
                     * Encodes the specified ModuleRegistration message, length delimited. Does not implicitly {@link telemetry.module.storage.v1.ModuleRegistration.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof telemetry.module.storage.v1.ModuleRegistration
                     * @static
                     * @param {telemetry.module.storage.v1.IModuleRegistration} message ModuleRegistration message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ModuleRegistration.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a ModuleRegistration message from the specified reader or buffer.
                     * @function decode
                     * @memberof telemetry.module.storage.v1.ModuleRegistration
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {telemetry.module.storage.v1.ModuleRegistration} ModuleRegistration
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ModuleRegistration.decode = function decode(reader, length, error) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.telemetry.module.storage.v1.ModuleRegistration();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            if (tag === error)
                                break;
                            switch (tag >>> 3) {
                            case 1: {
                                    if (!(message.collectors && message.collectors.length))
                                        message.collectors = [];
                                    message.collectors.push($root.telemetry.module.storage.v1.CollectorSpec.decode(reader, reader.uint32()));
                                    break;
                                }
                            case 2: {
                                    if (!(message.staticDisks && message.staticDisks.length))
                                        message.staticDisks = [];
                                    message.staticDisks.push($root.telemetry.module.storage.v1.StaticDiskInfo.decode(reader, reader.uint32()));
                                    break;
                                }
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a ModuleRegistration message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof telemetry.module.storage.v1.ModuleRegistration
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {telemetry.module.storage.v1.ModuleRegistration} ModuleRegistration
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ModuleRegistration.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a ModuleRegistration message.
                     * @function verify
                     * @memberof telemetry.module.storage.v1.ModuleRegistration
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    ModuleRegistration.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.collectors != null && message.hasOwnProperty("collectors")) {
                            if (!Array.isArray(message.collectors))
                                return "collectors: array expected";
                            for (let i = 0; i < message.collectors.length; ++i) {
                                let error = $root.telemetry.module.storage.v1.CollectorSpec.verify(message.collectors[i]);
                                if (error)
                                    return "collectors." + error;
                            }
                        }
                        if (message.staticDisks != null && message.hasOwnProperty("staticDisks")) {
                            if (!Array.isArray(message.staticDisks))
                                return "staticDisks: array expected";
                            for (let i = 0; i < message.staticDisks.length; ++i) {
                                let error = $root.telemetry.module.storage.v1.StaticDiskInfo.verify(message.staticDisks[i]);
                                if (error)
                                    return "staticDisks." + error;
                            }
                        }
                        return null;
                    };

                    /**
                     * Creates a ModuleRegistration message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof telemetry.module.storage.v1.ModuleRegistration
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {telemetry.module.storage.v1.ModuleRegistration} ModuleRegistration
                     */
                    ModuleRegistration.fromObject = function fromObject(object) {
                        if (object instanceof $root.telemetry.module.storage.v1.ModuleRegistration)
                            return object;
                        let message = new $root.telemetry.module.storage.v1.ModuleRegistration();
                        if (object.collectors) {
                            if (!Array.isArray(object.collectors))
                                throw TypeError(".telemetry.module.storage.v1.ModuleRegistration.collectors: array expected");
                            message.collectors = [];
                            for (let i = 0; i < object.collectors.length; ++i) {
                                if (typeof object.collectors[i] !== "object")
                                    throw TypeError(".telemetry.module.storage.v1.ModuleRegistration.collectors: object expected");
                                message.collectors[i] = $root.telemetry.module.storage.v1.CollectorSpec.fromObject(object.collectors[i]);
                            }
                        }
                        if (object.staticDisks) {
                            if (!Array.isArray(object.staticDisks))
                                throw TypeError(".telemetry.module.storage.v1.ModuleRegistration.staticDisks: array expected");
                            message.staticDisks = [];
                            for (let i = 0; i < object.staticDisks.length; ++i) {
                                if (typeof object.staticDisks[i] !== "object")
                                    throw TypeError(".telemetry.module.storage.v1.ModuleRegistration.staticDisks: object expected");
                                message.staticDisks[i] = $root.telemetry.module.storage.v1.StaticDiskInfo.fromObject(object.staticDisks[i]);
                            }
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a ModuleRegistration message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof telemetry.module.storage.v1.ModuleRegistration
                     * @static
                     * @param {telemetry.module.storage.v1.ModuleRegistration} message ModuleRegistration
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    ModuleRegistration.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.arrays || options.defaults) {
                            object.collectors = [];
                            object.staticDisks = [];
                        }
                        if (message.collectors && message.collectors.length) {
                            object.collectors = [];
                            for (let j = 0; j < message.collectors.length; ++j)
                                object.collectors[j] = $root.telemetry.module.storage.v1.CollectorSpec.toObject(message.collectors[j], options);
                        }
                        if (message.staticDisks && message.staticDisks.length) {
                            object.staticDisks = [];
                            for (let j = 0; j < message.staticDisks.length; ++j)
                                object.staticDisks[j] = $root.telemetry.module.storage.v1.StaticDiskInfo.toObject(message.staticDisks[j], options);
                        }
                        return object;
                    };

                    /**
                     * Converts this ModuleRegistration to JSON.
                     * @function toJSON
                     * @memberof telemetry.module.storage.v1.ModuleRegistration
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    ModuleRegistration.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Gets the default type url for ModuleRegistration
                     * @function getTypeUrl
                     * @memberof telemetry.module.storage.v1.ModuleRegistration
                     * @static
                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                     * @returns {string} The default type url
                     */
                    ModuleRegistration.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                        if (typeUrlPrefix === undefined) {
                            typeUrlPrefix = "type.googleapis.com";
                        }
                        return typeUrlPrefix + "/telemetry.module.storage.v1.ModuleRegistration";
                    };

                    return ModuleRegistration;
                })();

                v1.DiskMetrics = (function() {

                    /**
                     * Properties of a DiskMetrics.
                     * @memberof telemetry.module.storage.v1
                     * @interface IDiskMetrics
                     * @property {string|null} [name] DiskMetrics name
                     * @property {number|Long|null} [usedBytes] DiskMetrics usedBytes
                     * @property {number|Long|null} [freeBytes] DiskMetrics freeBytes
                     * @property {number|Long|null} [readSectors] DiskMetrics readSectors
                     * @property {number|Long|null} [writeSectors] DiskMetrics writeSectors
                     * @property {number|Long|null} [readIos] DiskMetrics readIos
                     * @property {number|Long|null} [writeIos] DiskMetrics writeIos
                     * @property {number|Long|null} [sampledAtUnixNano] DiskMetrics sampledAtUnixNano
                     */

                    /**
                     * Constructs a new DiskMetrics.
                     * @memberof telemetry.module.storage.v1
                     * @classdesc Represents a DiskMetrics.
                     * @implements IDiskMetrics
                     * @constructor
                     * @param {telemetry.module.storage.v1.IDiskMetrics=} [properties] Properties to set
                     */
                    function DiskMetrics(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * DiskMetrics name.
                     * @member {string} name
                     * @memberof telemetry.module.storage.v1.DiskMetrics
                     * @instance
                     */
                    DiskMetrics.prototype.name = "";

                    /**
                     * DiskMetrics usedBytes.
                     * @member {number|Long} usedBytes
                     * @memberof telemetry.module.storage.v1.DiskMetrics
                     * @instance
                     */
                    DiskMetrics.prototype.usedBytes = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                    /**
                     * DiskMetrics freeBytes.
                     * @member {number|Long} freeBytes
                     * @memberof telemetry.module.storage.v1.DiskMetrics
                     * @instance
                     */
                    DiskMetrics.prototype.freeBytes = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                    /**
                     * DiskMetrics readSectors.
                     * @member {number|Long} readSectors
                     * @memberof telemetry.module.storage.v1.DiskMetrics
                     * @instance
                     */
                    DiskMetrics.prototype.readSectors = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                    /**
                     * DiskMetrics writeSectors.
                     * @member {number|Long} writeSectors
                     * @memberof telemetry.module.storage.v1.DiskMetrics
                     * @instance
                     */
                    DiskMetrics.prototype.writeSectors = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                    /**
                     * DiskMetrics readIos.
                     * @member {number|Long} readIos
                     * @memberof telemetry.module.storage.v1.DiskMetrics
                     * @instance
                     */
                    DiskMetrics.prototype.readIos = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                    /**
                     * DiskMetrics writeIos.
                     * @member {number|Long} writeIos
                     * @memberof telemetry.module.storage.v1.DiskMetrics
                     * @instance
                     */
                    DiskMetrics.prototype.writeIos = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                    /**
                     * DiskMetrics sampledAtUnixNano.
                     * @member {number|Long} sampledAtUnixNano
                     * @memberof telemetry.module.storage.v1.DiskMetrics
                     * @instance
                     */
                    DiskMetrics.prototype.sampledAtUnixNano = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                    /**
                     * Creates a new DiskMetrics instance using the specified properties.
                     * @function create
                     * @memberof telemetry.module.storage.v1.DiskMetrics
                     * @static
                     * @param {telemetry.module.storage.v1.IDiskMetrics=} [properties] Properties to set
                     * @returns {telemetry.module.storage.v1.DiskMetrics} DiskMetrics instance
                     */
                    DiskMetrics.create = function create(properties) {
                        return new DiskMetrics(properties);
                    };

                    /**
                     * Encodes the specified DiskMetrics message. Does not implicitly {@link telemetry.module.storage.v1.DiskMetrics.verify|verify} messages.
                     * @function encode
                     * @memberof telemetry.module.storage.v1.DiskMetrics
                     * @static
                     * @param {telemetry.module.storage.v1.IDiskMetrics} message DiskMetrics message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    DiskMetrics.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                        if (message.usedBytes != null && Object.hasOwnProperty.call(message, "usedBytes"))
                            writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.usedBytes);
                        if (message.freeBytes != null && Object.hasOwnProperty.call(message, "freeBytes"))
                            writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.freeBytes);
                        if (message.readSectors != null && Object.hasOwnProperty.call(message, "readSectors"))
                            writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.readSectors);
                        if (message.writeSectors != null && Object.hasOwnProperty.call(message, "writeSectors"))
                            writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.writeSectors);
                        if (message.readIos != null && Object.hasOwnProperty.call(message, "readIos"))
                            writer.uint32(/* id 6, wireType 0 =*/48).uint64(message.readIos);
                        if (message.writeIos != null && Object.hasOwnProperty.call(message, "writeIos"))
                            writer.uint32(/* id 7, wireType 0 =*/56).uint64(message.writeIos);
                        if (message.sampledAtUnixNano != null && Object.hasOwnProperty.call(message, "sampledAtUnixNano"))
                            writer.uint32(/* id 8, wireType 0 =*/64).int64(message.sampledAtUnixNano);
                        return writer;
                    };

                    /**
                     * Encodes the specified DiskMetrics message, length delimited. Does not implicitly {@link telemetry.module.storage.v1.DiskMetrics.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof telemetry.module.storage.v1.DiskMetrics
                     * @static
                     * @param {telemetry.module.storage.v1.IDiskMetrics} message DiskMetrics message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    DiskMetrics.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a DiskMetrics message from the specified reader or buffer.
                     * @function decode
                     * @memberof telemetry.module.storage.v1.DiskMetrics
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {telemetry.module.storage.v1.DiskMetrics} DiskMetrics
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    DiskMetrics.decode = function decode(reader, length, error) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.telemetry.module.storage.v1.DiskMetrics();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            if (tag === error)
                                break;
                            switch (tag >>> 3) {
                            case 1: {
                                    message.name = reader.string();
                                    break;
                                }
                            case 2: {
                                    message.usedBytes = reader.uint64();
                                    break;
                                }
                            case 3: {
                                    message.freeBytes = reader.uint64();
                                    break;
                                }
                            case 4: {
                                    message.readSectors = reader.uint64();
                                    break;
                                }
                            case 5: {
                                    message.writeSectors = reader.uint64();
                                    break;
                                }
                            case 6: {
                                    message.readIos = reader.uint64();
                                    break;
                                }
                            case 7: {
                                    message.writeIos = reader.uint64();
                                    break;
                                }
                            case 8: {
                                    message.sampledAtUnixNano = reader.int64();
                                    break;
                                }
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a DiskMetrics message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof telemetry.module.storage.v1.DiskMetrics
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {telemetry.module.storage.v1.DiskMetrics} DiskMetrics
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    DiskMetrics.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a DiskMetrics message.
                     * @function verify
                     * @memberof telemetry.module.storage.v1.DiskMetrics
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    DiskMetrics.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.name != null && message.hasOwnProperty("name"))
                            if (!$util.isString(message.name))
                                return "name: string expected";
                        if (message.usedBytes != null && message.hasOwnProperty("usedBytes"))
                            if (!$util.isInteger(message.usedBytes) && !(message.usedBytes && $util.isInteger(message.usedBytes.low) && $util.isInteger(message.usedBytes.high)))
                                return "usedBytes: integer|Long expected";
                        if (message.freeBytes != null && message.hasOwnProperty("freeBytes"))
                            if (!$util.isInteger(message.freeBytes) && !(message.freeBytes && $util.isInteger(message.freeBytes.low) && $util.isInteger(message.freeBytes.high)))
                                return "freeBytes: integer|Long expected";
                        if (message.readSectors != null && message.hasOwnProperty("readSectors"))
                            if (!$util.isInteger(message.readSectors) && !(message.readSectors && $util.isInteger(message.readSectors.low) && $util.isInteger(message.readSectors.high)))
                                return "readSectors: integer|Long expected";
                        if (message.writeSectors != null && message.hasOwnProperty("writeSectors"))
                            if (!$util.isInteger(message.writeSectors) && !(message.writeSectors && $util.isInteger(message.writeSectors.low) && $util.isInteger(message.writeSectors.high)))
                                return "writeSectors: integer|Long expected";
                        if (message.readIos != null && message.hasOwnProperty("readIos"))
                            if (!$util.isInteger(message.readIos) && !(message.readIos && $util.isInteger(message.readIos.low) && $util.isInteger(message.readIos.high)))
                                return "readIos: integer|Long expected";
                        if (message.writeIos != null && message.hasOwnProperty("writeIos"))
                            if (!$util.isInteger(message.writeIos) && !(message.writeIos && $util.isInteger(message.writeIos.low) && $util.isInteger(message.writeIos.high)))
                                return "writeIos: integer|Long expected";
                        if (message.sampledAtUnixNano != null && message.hasOwnProperty("sampledAtUnixNano"))
                            if (!$util.isInteger(message.sampledAtUnixNano) && !(message.sampledAtUnixNano && $util.isInteger(message.sampledAtUnixNano.low) && $util.isInteger(message.sampledAtUnixNano.high)))
                                return "sampledAtUnixNano: integer|Long expected";
                        return null;
                    };

                    /**
                     * Creates a DiskMetrics message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof telemetry.module.storage.v1.DiskMetrics
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {telemetry.module.storage.v1.DiskMetrics} DiskMetrics
                     */
                    DiskMetrics.fromObject = function fromObject(object) {
                        if (object instanceof $root.telemetry.module.storage.v1.DiskMetrics)
                            return object;
                        let message = new $root.telemetry.module.storage.v1.DiskMetrics();
                        if (object.name != null)
                            message.name = String(object.name);
                        if (object.usedBytes != null)
                            if ($util.Long)
                                (message.usedBytes = $util.Long.fromValue(object.usedBytes)).unsigned = true;
                            else if (typeof object.usedBytes === "string")
                                message.usedBytes = parseInt(object.usedBytes, 10);
                            else if (typeof object.usedBytes === "number")
                                message.usedBytes = object.usedBytes;
                            else if (typeof object.usedBytes === "object")
                                message.usedBytes = new $util.LongBits(object.usedBytes.low >>> 0, object.usedBytes.high >>> 0).toNumber(true);
                        if (object.freeBytes != null)
                            if ($util.Long)
                                (message.freeBytes = $util.Long.fromValue(object.freeBytes)).unsigned = true;
                            else if (typeof object.freeBytes === "string")
                                message.freeBytes = parseInt(object.freeBytes, 10);
                            else if (typeof object.freeBytes === "number")
                                message.freeBytes = object.freeBytes;
                            else if (typeof object.freeBytes === "object")
                                message.freeBytes = new $util.LongBits(object.freeBytes.low >>> 0, object.freeBytes.high >>> 0).toNumber(true);
                        if (object.readSectors != null)
                            if ($util.Long)
                                (message.readSectors = $util.Long.fromValue(object.readSectors)).unsigned = true;
                            else if (typeof object.readSectors === "string")
                                message.readSectors = parseInt(object.readSectors, 10);
                            else if (typeof object.readSectors === "number")
                                message.readSectors = object.readSectors;
                            else if (typeof object.readSectors === "object")
                                message.readSectors = new $util.LongBits(object.readSectors.low >>> 0, object.readSectors.high >>> 0).toNumber(true);
                        if (object.writeSectors != null)
                            if ($util.Long)
                                (message.writeSectors = $util.Long.fromValue(object.writeSectors)).unsigned = true;
                            else if (typeof object.writeSectors === "string")
                                message.writeSectors = parseInt(object.writeSectors, 10);
                            else if (typeof object.writeSectors === "number")
                                message.writeSectors = object.writeSectors;
                            else if (typeof object.writeSectors === "object")
                                message.writeSectors = new $util.LongBits(object.writeSectors.low >>> 0, object.writeSectors.high >>> 0).toNumber(true);
                        if (object.readIos != null)
                            if ($util.Long)
                                (message.readIos = $util.Long.fromValue(object.readIos)).unsigned = true;
                            else if (typeof object.readIos === "string")
                                message.readIos = parseInt(object.readIos, 10);
                            else if (typeof object.readIos === "number")
                                message.readIos = object.readIos;
                            else if (typeof object.readIos === "object")
                                message.readIos = new $util.LongBits(object.readIos.low >>> 0, object.readIos.high >>> 0).toNumber(true);
                        if (object.writeIos != null)
                            if ($util.Long)
                                (message.writeIos = $util.Long.fromValue(object.writeIos)).unsigned = true;
                            else if (typeof object.writeIos === "string")
                                message.writeIos = parseInt(object.writeIos, 10);
                            else if (typeof object.writeIos === "number")
                                message.writeIos = object.writeIos;
                            else if (typeof object.writeIos === "object")
                                message.writeIos = new $util.LongBits(object.writeIos.low >>> 0, object.writeIos.high >>> 0).toNumber(true);
                        if (object.sampledAtUnixNano != null)
                            if ($util.Long)
                                (message.sampledAtUnixNano = $util.Long.fromValue(object.sampledAtUnixNano)).unsigned = false;
                            else if (typeof object.sampledAtUnixNano === "string")
                                message.sampledAtUnixNano = parseInt(object.sampledAtUnixNano, 10);
                            else if (typeof object.sampledAtUnixNano === "number")
                                message.sampledAtUnixNano = object.sampledAtUnixNano;
                            else if (typeof object.sampledAtUnixNano === "object")
                                message.sampledAtUnixNano = new $util.LongBits(object.sampledAtUnixNano.low >>> 0, object.sampledAtUnixNano.high >>> 0).toNumber();
                        return message;
                    };

                    /**
                     * Creates a plain object from a DiskMetrics message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof telemetry.module.storage.v1.DiskMetrics
                     * @static
                     * @param {telemetry.module.storage.v1.DiskMetrics} message DiskMetrics
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    DiskMetrics.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.name = "";
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, true);
                                object.usedBytes = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.usedBytes = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, true);
                                object.freeBytes = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.freeBytes = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, true);
                                object.readSectors = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.readSectors = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, true);
                                object.writeSectors = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.writeSectors = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, true);
                                object.readIos = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.readIos = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, true);
                                object.writeIos = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.writeIos = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, false);
                                object.sampledAtUnixNano = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.sampledAtUnixNano = options.longs === String ? "0" : 0;
                        }
                        if (message.name != null && message.hasOwnProperty("name"))
                            object.name = message.name;
                        if (message.usedBytes != null && message.hasOwnProperty("usedBytes"))
                            if (typeof message.usedBytes === "number")
                                object.usedBytes = options.longs === String ? String(message.usedBytes) : message.usedBytes;
                            else
                                object.usedBytes = options.longs === String ? $util.Long.prototype.toString.call(message.usedBytes) : options.longs === Number ? new $util.LongBits(message.usedBytes.low >>> 0, message.usedBytes.high >>> 0).toNumber(true) : message.usedBytes;
                        if (message.freeBytes != null && message.hasOwnProperty("freeBytes"))
                            if (typeof message.freeBytes === "number")
                                object.freeBytes = options.longs === String ? String(message.freeBytes) : message.freeBytes;
                            else
                                object.freeBytes = options.longs === String ? $util.Long.prototype.toString.call(message.freeBytes) : options.longs === Number ? new $util.LongBits(message.freeBytes.low >>> 0, message.freeBytes.high >>> 0).toNumber(true) : message.freeBytes;
                        if (message.readSectors != null && message.hasOwnProperty("readSectors"))
                            if (typeof message.readSectors === "number")
                                object.readSectors = options.longs === String ? String(message.readSectors) : message.readSectors;
                            else
                                object.readSectors = options.longs === String ? $util.Long.prototype.toString.call(message.readSectors) : options.longs === Number ? new $util.LongBits(message.readSectors.low >>> 0, message.readSectors.high >>> 0).toNumber(true) : message.readSectors;
                        if (message.writeSectors != null && message.hasOwnProperty("writeSectors"))
                            if (typeof message.writeSectors === "number")
                                object.writeSectors = options.longs === String ? String(message.writeSectors) : message.writeSectors;
                            else
                                object.writeSectors = options.longs === String ? $util.Long.prototype.toString.call(message.writeSectors) : options.longs === Number ? new $util.LongBits(message.writeSectors.low >>> 0, message.writeSectors.high >>> 0).toNumber(true) : message.writeSectors;
                        if (message.readIos != null && message.hasOwnProperty("readIos"))
                            if (typeof message.readIos === "number")
                                object.readIos = options.longs === String ? String(message.readIos) : message.readIos;
                            else
                                object.readIos = options.longs === String ? $util.Long.prototype.toString.call(message.readIos) : options.longs === Number ? new $util.LongBits(message.readIos.low >>> 0, message.readIos.high >>> 0).toNumber(true) : message.readIos;
                        if (message.writeIos != null && message.hasOwnProperty("writeIos"))
                            if (typeof message.writeIos === "number")
                                object.writeIos = options.longs === String ? String(message.writeIos) : message.writeIos;
                            else
                                object.writeIos = options.longs === String ? $util.Long.prototype.toString.call(message.writeIos) : options.longs === Number ? new $util.LongBits(message.writeIos.low >>> 0, message.writeIos.high >>> 0).toNumber(true) : message.writeIos;
                        if (message.sampledAtUnixNano != null && message.hasOwnProperty("sampledAtUnixNano"))
                            if (typeof message.sampledAtUnixNano === "number")
                                object.sampledAtUnixNano = options.longs === String ? String(message.sampledAtUnixNano) : message.sampledAtUnixNano;
                            else
                                object.sampledAtUnixNano = options.longs === String ? $util.Long.prototype.toString.call(message.sampledAtUnixNano) : options.longs === Number ? new $util.LongBits(message.sampledAtUnixNano.low >>> 0, message.sampledAtUnixNano.high >>> 0).toNumber() : message.sampledAtUnixNano;
                        return object;
                    };

                    /**
                     * Converts this DiskMetrics to JSON.
                     * @function toJSON
                     * @memberof telemetry.module.storage.v1.DiskMetrics
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    DiskMetrics.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Gets the default type url for DiskMetrics
                     * @function getTypeUrl
                     * @memberof telemetry.module.storage.v1.DiskMetrics
                     * @static
                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                     * @returns {string} The default type url
                     */
                    DiskMetrics.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                        if (typeUrlPrefix === undefined) {
                            typeUrlPrefix = "type.googleapis.com";
                        }
                        return typeUrlPrefix + "/telemetry.module.storage.v1.DiskMetrics";
                    };

                    return DiskMetrics;
                })();

                v1.Metrics = (function() {

                    /**
                     * Properties of a Metrics.
                     * @memberof telemetry.module.storage.v1
                     * @interface IMetrics
                     * @property {Array.<telemetry.module.storage.v1.IDiskMetrics>|null} [disks] Metrics disks
                     */

                    /**
                     * Constructs a new Metrics.
                     * @memberof telemetry.module.storage.v1
                     * @classdesc Represents a Metrics.
                     * @implements IMetrics
                     * @constructor
                     * @param {telemetry.module.storage.v1.IMetrics=} [properties] Properties to set
                     */
                    function Metrics(properties) {
                        this.disks = [];
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Metrics disks.
                     * @member {Array.<telemetry.module.storage.v1.IDiskMetrics>} disks
                     * @memberof telemetry.module.storage.v1.Metrics
                     * @instance
                     */
                    Metrics.prototype.disks = $util.emptyArray;

                    /**
                     * Creates a new Metrics instance using the specified properties.
                     * @function create
                     * @memberof telemetry.module.storage.v1.Metrics
                     * @static
                     * @param {telemetry.module.storage.v1.IMetrics=} [properties] Properties to set
                     * @returns {telemetry.module.storage.v1.Metrics} Metrics instance
                     */
                    Metrics.create = function create(properties) {
                        return new Metrics(properties);
                    };

                    /**
                     * Encodes the specified Metrics message. Does not implicitly {@link telemetry.module.storage.v1.Metrics.verify|verify} messages.
                     * @function encode
                     * @memberof telemetry.module.storage.v1.Metrics
                     * @static
                     * @param {telemetry.module.storage.v1.IMetrics} message Metrics message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Metrics.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.disks != null && message.disks.length)
                            for (let i = 0; i < message.disks.length; ++i)
                                $root.telemetry.module.storage.v1.DiskMetrics.encode(message.disks[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        return writer;
                    };

                    /**
                     * Encodes the specified Metrics message, length delimited. Does not implicitly {@link telemetry.module.storage.v1.Metrics.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof telemetry.module.storage.v1.Metrics
                     * @static
                     * @param {telemetry.module.storage.v1.IMetrics} message Metrics message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Metrics.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Metrics message from the specified reader or buffer.
                     * @function decode
                     * @memberof telemetry.module.storage.v1.Metrics
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {telemetry.module.storage.v1.Metrics} Metrics
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Metrics.decode = function decode(reader, length, error) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.telemetry.module.storage.v1.Metrics();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            if (tag === error)
                                break;
                            switch (tag >>> 3) {
                            case 1: {
                                    if (!(message.disks && message.disks.length))
                                        message.disks = [];
                                    message.disks.push($root.telemetry.module.storage.v1.DiskMetrics.decode(reader, reader.uint32()));
                                    break;
                                }
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Metrics message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof telemetry.module.storage.v1.Metrics
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {telemetry.module.storage.v1.Metrics} Metrics
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Metrics.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Metrics message.
                     * @function verify
                     * @memberof telemetry.module.storage.v1.Metrics
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Metrics.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.disks != null && message.hasOwnProperty("disks")) {
                            if (!Array.isArray(message.disks))
                                return "disks: array expected";
                            for (let i = 0; i < message.disks.length; ++i) {
                                let error = $root.telemetry.module.storage.v1.DiskMetrics.verify(message.disks[i]);
                                if (error)
                                    return "disks." + error;
                            }
                        }
                        return null;
                    };

                    /**
                     * Creates a Metrics message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof telemetry.module.storage.v1.Metrics
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {telemetry.module.storage.v1.Metrics} Metrics
                     */
                    Metrics.fromObject = function fromObject(object) {
                        if (object instanceof $root.telemetry.module.storage.v1.Metrics)
                            return object;
                        let message = new $root.telemetry.module.storage.v1.Metrics();
                        if (object.disks) {
                            if (!Array.isArray(object.disks))
                                throw TypeError(".telemetry.module.storage.v1.Metrics.disks: array expected");
                            message.disks = [];
                            for (let i = 0; i < object.disks.length; ++i) {
                                if (typeof object.disks[i] !== "object")
                                    throw TypeError(".telemetry.module.storage.v1.Metrics.disks: object expected");
                                message.disks[i] = $root.telemetry.module.storage.v1.DiskMetrics.fromObject(object.disks[i]);
                            }
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a Metrics message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof telemetry.module.storage.v1.Metrics
                     * @static
                     * @param {telemetry.module.storage.v1.Metrics} message Metrics
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Metrics.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.arrays || options.defaults)
                            object.disks = [];
                        if (message.disks && message.disks.length) {
                            object.disks = [];
                            for (let j = 0; j < message.disks.length; ++j)
                                object.disks[j] = $root.telemetry.module.storage.v1.DiskMetrics.toObject(message.disks[j], options);
                        }
                        return object;
                    };

                    /**
                     * Converts this Metrics to JSON.
                     * @function toJSON
                     * @memberof telemetry.module.storage.v1.Metrics
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Metrics.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Gets the default type url for Metrics
                     * @function getTypeUrl
                     * @memberof telemetry.module.storage.v1.Metrics
                     * @static
                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                     * @returns {string} The default type url
                     */
                    Metrics.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                        if (typeUrlPrefix === undefined) {
                            typeUrlPrefix = "type.googleapis.com";
                        }
                        return typeUrlPrefix + "/telemetry.module.storage.v1.Metrics";
                    };

                    return Metrics;
                })();

                return v1;
            })();

            return storage;
        })();

        module.network = (function() {

            /**
             * Namespace network.
             * @memberof telemetry.module
             * @namespace
             */
            const network = {};

            network.v1 = (function() {

                /**
                 * Namespace v1.
                 * @memberof telemetry.module.network
                 * @namespace
                 */
                const v1 = {};

                v1.CollectorSpec = (function() {

                    /**
                     * Properties of a CollectorSpec.
                     * @memberof telemetry.module.network.v1
                     * @interface ICollectorSpec
                     * @property {string|null} [category] CollectorSpec category
                     * @property {string|null} [interval] CollectorSpec interval
                     */

                    /**
                     * Constructs a new CollectorSpec.
                     * @memberof telemetry.module.network.v1
                     * @classdesc Represents a CollectorSpec.
                     * @implements ICollectorSpec
                     * @constructor
                     * @param {telemetry.module.network.v1.ICollectorSpec=} [properties] Properties to set
                     */
                    function CollectorSpec(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * CollectorSpec category.
                     * @member {string} category
                     * @memberof telemetry.module.network.v1.CollectorSpec
                     * @instance
                     */
                    CollectorSpec.prototype.category = "";

                    /**
                     * CollectorSpec interval.
                     * @member {string} interval
                     * @memberof telemetry.module.network.v1.CollectorSpec
                     * @instance
                     */
                    CollectorSpec.prototype.interval = "";

                    /**
                     * Creates a new CollectorSpec instance using the specified properties.
                     * @function create
                     * @memberof telemetry.module.network.v1.CollectorSpec
                     * @static
                     * @param {telemetry.module.network.v1.ICollectorSpec=} [properties] Properties to set
                     * @returns {telemetry.module.network.v1.CollectorSpec} CollectorSpec instance
                     */
                    CollectorSpec.create = function create(properties) {
                        return new CollectorSpec(properties);
                    };

                    /**
                     * Encodes the specified CollectorSpec message. Does not implicitly {@link telemetry.module.network.v1.CollectorSpec.verify|verify} messages.
                     * @function encode
                     * @memberof telemetry.module.network.v1.CollectorSpec
                     * @static
                     * @param {telemetry.module.network.v1.ICollectorSpec} message CollectorSpec message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    CollectorSpec.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.category != null && Object.hasOwnProperty.call(message, "category"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.category);
                        if (message.interval != null && Object.hasOwnProperty.call(message, "interval"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.interval);
                        return writer;
                    };

                    /**
                     * Encodes the specified CollectorSpec message, length delimited. Does not implicitly {@link telemetry.module.network.v1.CollectorSpec.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof telemetry.module.network.v1.CollectorSpec
                     * @static
                     * @param {telemetry.module.network.v1.ICollectorSpec} message CollectorSpec message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    CollectorSpec.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a CollectorSpec message from the specified reader or buffer.
                     * @function decode
                     * @memberof telemetry.module.network.v1.CollectorSpec
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {telemetry.module.network.v1.CollectorSpec} CollectorSpec
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    CollectorSpec.decode = function decode(reader, length, error) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.telemetry.module.network.v1.CollectorSpec();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            if (tag === error)
                                break;
                            switch (tag >>> 3) {
                            case 1: {
                                    message.category = reader.string();
                                    break;
                                }
                            case 2: {
                                    message.interval = reader.string();
                                    break;
                                }
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a CollectorSpec message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof telemetry.module.network.v1.CollectorSpec
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {telemetry.module.network.v1.CollectorSpec} CollectorSpec
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    CollectorSpec.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a CollectorSpec message.
                     * @function verify
                     * @memberof telemetry.module.network.v1.CollectorSpec
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    CollectorSpec.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.category != null && message.hasOwnProperty("category"))
                            if (!$util.isString(message.category))
                                return "category: string expected";
                        if (message.interval != null && message.hasOwnProperty("interval"))
                            if (!$util.isString(message.interval))
                                return "interval: string expected";
                        return null;
                    };

                    /**
                     * Creates a CollectorSpec message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof telemetry.module.network.v1.CollectorSpec
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {telemetry.module.network.v1.CollectorSpec} CollectorSpec
                     */
                    CollectorSpec.fromObject = function fromObject(object) {
                        if (object instanceof $root.telemetry.module.network.v1.CollectorSpec)
                            return object;
                        let message = new $root.telemetry.module.network.v1.CollectorSpec();
                        if (object.category != null)
                            message.category = String(object.category);
                        if (object.interval != null)
                            message.interval = String(object.interval);
                        return message;
                    };

                    /**
                     * Creates a plain object from a CollectorSpec message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof telemetry.module.network.v1.CollectorSpec
                     * @static
                     * @param {telemetry.module.network.v1.CollectorSpec} message CollectorSpec
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    CollectorSpec.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.category = "";
                            object.interval = "";
                        }
                        if (message.category != null && message.hasOwnProperty("category"))
                            object.category = message.category;
                        if (message.interval != null && message.hasOwnProperty("interval"))
                            object.interval = message.interval;
                        return object;
                    };

                    /**
                     * Converts this CollectorSpec to JSON.
                     * @function toJSON
                     * @memberof telemetry.module.network.v1.CollectorSpec
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    CollectorSpec.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Gets the default type url for CollectorSpec
                     * @function getTypeUrl
                     * @memberof telemetry.module.network.v1.CollectorSpec
                     * @static
                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                     * @returns {string} The default type url
                     */
                    CollectorSpec.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                        if (typeUrlPrefix === undefined) {
                            typeUrlPrefix = "type.googleapis.com";
                        }
                        return typeUrlPrefix + "/telemetry.module.network.v1.CollectorSpec";
                    };

                    return CollectorSpec;
                })();

                v1.ModuleRegistration = (function() {

                    /**
                     * Properties of a ModuleRegistration.
                     * @memberof telemetry.module.network.v1
                     * @interface IModuleRegistration
                     * @property {Array.<telemetry.module.network.v1.ICollectorSpec>|null} [collectors] ModuleRegistration collectors
                     */

                    /**
                     * Constructs a new ModuleRegistration.
                     * @memberof telemetry.module.network.v1
                     * @classdesc Represents a ModuleRegistration.
                     * @implements IModuleRegistration
                     * @constructor
                     * @param {telemetry.module.network.v1.IModuleRegistration=} [properties] Properties to set
                     */
                    function ModuleRegistration(properties) {
                        this.collectors = [];
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * ModuleRegistration collectors.
                     * @member {Array.<telemetry.module.network.v1.ICollectorSpec>} collectors
                     * @memberof telemetry.module.network.v1.ModuleRegistration
                     * @instance
                     */
                    ModuleRegistration.prototype.collectors = $util.emptyArray;

                    /**
                     * Creates a new ModuleRegistration instance using the specified properties.
                     * @function create
                     * @memberof telemetry.module.network.v1.ModuleRegistration
                     * @static
                     * @param {telemetry.module.network.v1.IModuleRegistration=} [properties] Properties to set
                     * @returns {telemetry.module.network.v1.ModuleRegistration} ModuleRegistration instance
                     */
                    ModuleRegistration.create = function create(properties) {
                        return new ModuleRegistration(properties);
                    };

                    /**
                     * Encodes the specified ModuleRegistration message. Does not implicitly {@link telemetry.module.network.v1.ModuleRegistration.verify|verify} messages.
                     * @function encode
                     * @memberof telemetry.module.network.v1.ModuleRegistration
                     * @static
                     * @param {telemetry.module.network.v1.IModuleRegistration} message ModuleRegistration message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ModuleRegistration.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.collectors != null && message.collectors.length)
                            for (let i = 0; i < message.collectors.length; ++i)
                                $root.telemetry.module.network.v1.CollectorSpec.encode(message.collectors[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        return writer;
                    };

                    /**
                     * Encodes the specified ModuleRegistration message, length delimited. Does not implicitly {@link telemetry.module.network.v1.ModuleRegistration.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof telemetry.module.network.v1.ModuleRegistration
                     * @static
                     * @param {telemetry.module.network.v1.IModuleRegistration} message ModuleRegistration message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ModuleRegistration.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a ModuleRegistration message from the specified reader or buffer.
                     * @function decode
                     * @memberof telemetry.module.network.v1.ModuleRegistration
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {telemetry.module.network.v1.ModuleRegistration} ModuleRegistration
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ModuleRegistration.decode = function decode(reader, length, error) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.telemetry.module.network.v1.ModuleRegistration();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            if (tag === error)
                                break;
                            switch (tag >>> 3) {
                            case 1: {
                                    if (!(message.collectors && message.collectors.length))
                                        message.collectors = [];
                                    message.collectors.push($root.telemetry.module.network.v1.CollectorSpec.decode(reader, reader.uint32()));
                                    break;
                                }
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a ModuleRegistration message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof telemetry.module.network.v1.ModuleRegistration
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {telemetry.module.network.v1.ModuleRegistration} ModuleRegistration
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ModuleRegistration.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a ModuleRegistration message.
                     * @function verify
                     * @memberof telemetry.module.network.v1.ModuleRegistration
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    ModuleRegistration.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.collectors != null && message.hasOwnProperty("collectors")) {
                            if (!Array.isArray(message.collectors))
                                return "collectors: array expected";
                            for (let i = 0; i < message.collectors.length; ++i) {
                                let error = $root.telemetry.module.network.v1.CollectorSpec.verify(message.collectors[i]);
                                if (error)
                                    return "collectors." + error;
                            }
                        }
                        return null;
                    };

                    /**
                     * Creates a ModuleRegistration message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof telemetry.module.network.v1.ModuleRegistration
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {telemetry.module.network.v1.ModuleRegistration} ModuleRegistration
                     */
                    ModuleRegistration.fromObject = function fromObject(object) {
                        if (object instanceof $root.telemetry.module.network.v1.ModuleRegistration)
                            return object;
                        let message = new $root.telemetry.module.network.v1.ModuleRegistration();
                        if (object.collectors) {
                            if (!Array.isArray(object.collectors))
                                throw TypeError(".telemetry.module.network.v1.ModuleRegistration.collectors: array expected");
                            message.collectors = [];
                            for (let i = 0; i < object.collectors.length; ++i) {
                                if (typeof object.collectors[i] !== "object")
                                    throw TypeError(".telemetry.module.network.v1.ModuleRegistration.collectors: object expected");
                                message.collectors[i] = $root.telemetry.module.network.v1.CollectorSpec.fromObject(object.collectors[i]);
                            }
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a ModuleRegistration message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof telemetry.module.network.v1.ModuleRegistration
                     * @static
                     * @param {telemetry.module.network.v1.ModuleRegistration} message ModuleRegistration
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    ModuleRegistration.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.arrays || options.defaults)
                            object.collectors = [];
                        if (message.collectors && message.collectors.length) {
                            object.collectors = [];
                            for (let j = 0; j < message.collectors.length; ++j)
                                object.collectors[j] = $root.telemetry.module.network.v1.CollectorSpec.toObject(message.collectors[j], options);
                        }
                        return object;
                    };

                    /**
                     * Converts this ModuleRegistration to JSON.
                     * @function toJSON
                     * @memberof telemetry.module.network.v1.ModuleRegistration
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    ModuleRegistration.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Gets the default type url for ModuleRegistration
                     * @function getTypeUrl
                     * @memberof telemetry.module.network.v1.ModuleRegistration
                     * @static
                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                     * @returns {string} The default type url
                     */
                    ModuleRegistration.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                        if (typeUrlPrefix === undefined) {
                            typeUrlPrefix = "type.googleapis.com";
                        }
                        return typeUrlPrefix + "/telemetry.module.network.v1.ModuleRegistration";
                    };

                    return ModuleRegistration;
                })();

                v1.InterfaceMetrics = (function() {

                    /**
                     * Properties of an InterfaceMetrics.
                     * @memberof telemetry.module.network.v1
                     * @interface IInterfaceMetrics
                     * @property {string|null} [name] InterfaceMetrics name
                     * @property {Array.<string>|null} [ips] InterfaceMetrics ips
                     * @property {number|Long|null} [rxBytes] InterfaceMetrics rxBytes
                     * @property {number|Long|null} [rxPackets] InterfaceMetrics rxPackets
                     * @property {number|Long|null} [txBytes] InterfaceMetrics txBytes
                     * @property {number|Long|null} [txPackets] InterfaceMetrics txPackets
                     * @property {number|Long|null} [sampledAtUnixNano] InterfaceMetrics sampledAtUnixNano
                     */

                    /**
                     * Constructs a new InterfaceMetrics.
                     * @memberof telemetry.module.network.v1
                     * @classdesc Represents an InterfaceMetrics.
                     * @implements IInterfaceMetrics
                     * @constructor
                     * @param {telemetry.module.network.v1.IInterfaceMetrics=} [properties] Properties to set
                     */
                    function InterfaceMetrics(properties) {
                        this.ips = [];
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * InterfaceMetrics name.
                     * @member {string} name
                     * @memberof telemetry.module.network.v1.InterfaceMetrics
                     * @instance
                     */
                    InterfaceMetrics.prototype.name = "";

                    /**
                     * InterfaceMetrics ips.
                     * @member {Array.<string>} ips
                     * @memberof telemetry.module.network.v1.InterfaceMetrics
                     * @instance
                     */
                    InterfaceMetrics.prototype.ips = $util.emptyArray;

                    /**
                     * InterfaceMetrics rxBytes.
                     * @member {number|Long} rxBytes
                     * @memberof telemetry.module.network.v1.InterfaceMetrics
                     * @instance
                     */
                    InterfaceMetrics.prototype.rxBytes = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                    /**
                     * InterfaceMetrics rxPackets.
                     * @member {number|Long} rxPackets
                     * @memberof telemetry.module.network.v1.InterfaceMetrics
                     * @instance
                     */
                    InterfaceMetrics.prototype.rxPackets = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                    /**
                     * InterfaceMetrics txBytes.
                     * @member {number|Long} txBytes
                     * @memberof telemetry.module.network.v1.InterfaceMetrics
                     * @instance
                     */
                    InterfaceMetrics.prototype.txBytes = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                    /**
                     * InterfaceMetrics txPackets.
                     * @member {number|Long} txPackets
                     * @memberof telemetry.module.network.v1.InterfaceMetrics
                     * @instance
                     */
                    InterfaceMetrics.prototype.txPackets = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                    /**
                     * InterfaceMetrics sampledAtUnixNano.
                     * @member {number|Long} sampledAtUnixNano
                     * @memberof telemetry.module.network.v1.InterfaceMetrics
                     * @instance
                     */
                    InterfaceMetrics.prototype.sampledAtUnixNano = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                    /**
                     * Creates a new InterfaceMetrics instance using the specified properties.
                     * @function create
                     * @memberof telemetry.module.network.v1.InterfaceMetrics
                     * @static
                     * @param {telemetry.module.network.v1.IInterfaceMetrics=} [properties] Properties to set
                     * @returns {telemetry.module.network.v1.InterfaceMetrics} InterfaceMetrics instance
                     */
                    InterfaceMetrics.create = function create(properties) {
                        return new InterfaceMetrics(properties);
                    };

                    /**
                     * Encodes the specified InterfaceMetrics message. Does not implicitly {@link telemetry.module.network.v1.InterfaceMetrics.verify|verify} messages.
                     * @function encode
                     * @memberof telemetry.module.network.v1.InterfaceMetrics
                     * @static
                     * @param {telemetry.module.network.v1.IInterfaceMetrics} message InterfaceMetrics message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    InterfaceMetrics.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                        if (message.ips != null && message.ips.length)
                            for (let i = 0; i < message.ips.length; ++i)
                                writer.uint32(/* id 2, wireType 2 =*/18).string(message.ips[i]);
                        if (message.rxBytes != null && Object.hasOwnProperty.call(message, "rxBytes"))
                            writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.rxBytes);
                        if (message.rxPackets != null && Object.hasOwnProperty.call(message, "rxPackets"))
                            writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.rxPackets);
                        if (message.txBytes != null && Object.hasOwnProperty.call(message, "txBytes"))
                            writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.txBytes);
                        if (message.txPackets != null && Object.hasOwnProperty.call(message, "txPackets"))
                            writer.uint32(/* id 6, wireType 0 =*/48).uint64(message.txPackets);
                        if (message.sampledAtUnixNano != null && Object.hasOwnProperty.call(message, "sampledAtUnixNano"))
                            writer.uint32(/* id 7, wireType 0 =*/56).int64(message.sampledAtUnixNano);
                        return writer;
                    };

                    /**
                     * Encodes the specified InterfaceMetrics message, length delimited. Does not implicitly {@link telemetry.module.network.v1.InterfaceMetrics.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof telemetry.module.network.v1.InterfaceMetrics
                     * @static
                     * @param {telemetry.module.network.v1.IInterfaceMetrics} message InterfaceMetrics message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    InterfaceMetrics.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes an InterfaceMetrics message from the specified reader or buffer.
                     * @function decode
                     * @memberof telemetry.module.network.v1.InterfaceMetrics
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {telemetry.module.network.v1.InterfaceMetrics} InterfaceMetrics
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    InterfaceMetrics.decode = function decode(reader, length, error) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.telemetry.module.network.v1.InterfaceMetrics();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            if (tag === error)
                                break;
                            switch (tag >>> 3) {
                            case 1: {
                                    message.name = reader.string();
                                    break;
                                }
                            case 2: {
                                    if (!(message.ips && message.ips.length))
                                        message.ips = [];
                                    message.ips.push(reader.string());
                                    break;
                                }
                            case 3: {
                                    message.rxBytes = reader.uint64();
                                    break;
                                }
                            case 4: {
                                    message.rxPackets = reader.uint64();
                                    break;
                                }
                            case 5: {
                                    message.txBytes = reader.uint64();
                                    break;
                                }
                            case 6: {
                                    message.txPackets = reader.uint64();
                                    break;
                                }
                            case 7: {
                                    message.sampledAtUnixNano = reader.int64();
                                    break;
                                }
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes an InterfaceMetrics message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof telemetry.module.network.v1.InterfaceMetrics
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {telemetry.module.network.v1.InterfaceMetrics} InterfaceMetrics
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    InterfaceMetrics.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies an InterfaceMetrics message.
                     * @function verify
                     * @memberof telemetry.module.network.v1.InterfaceMetrics
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    InterfaceMetrics.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.name != null && message.hasOwnProperty("name"))
                            if (!$util.isString(message.name))
                                return "name: string expected";
                        if (message.ips != null && message.hasOwnProperty("ips")) {
                            if (!Array.isArray(message.ips))
                                return "ips: array expected";
                            for (let i = 0; i < message.ips.length; ++i)
                                if (!$util.isString(message.ips[i]))
                                    return "ips: string[] expected";
                        }
                        if (message.rxBytes != null && message.hasOwnProperty("rxBytes"))
                            if (!$util.isInteger(message.rxBytes) && !(message.rxBytes && $util.isInteger(message.rxBytes.low) && $util.isInteger(message.rxBytes.high)))
                                return "rxBytes: integer|Long expected";
                        if (message.rxPackets != null && message.hasOwnProperty("rxPackets"))
                            if (!$util.isInteger(message.rxPackets) && !(message.rxPackets && $util.isInteger(message.rxPackets.low) && $util.isInteger(message.rxPackets.high)))
                                return "rxPackets: integer|Long expected";
                        if (message.txBytes != null && message.hasOwnProperty("txBytes"))
                            if (!$util.isInteger(message.txBytes) && !(message.txBytes && $util.isInteger(message.txBytes.low) && $util.isInteger(message.txBytes.high)))
                                return "txBytes: integer|Long expected";
                        if (message.txPackets != null && message.hasOwnProperty("txPackets"))
                            if (!$util.isInteger(message.txPackets) && !(message.txPackets && $util.isInteger(message.txPackets.low) && $util.isInteger(message.txPackets.high)))
                                return "txPackets: integer|Long expected";
                        if (message.sampledAtUnixNano != null && message.hasOwnProperty("sampledAtUnixNano"))
                            if (!$util.isInteger(message.sampledAtUnixNano) && !(message.sampledAtUnixNano && $util.isInteger(message.sampledAtUnixNano.low) && $util.isInteger(message.sampledAtUnixNano.high)))
                                return "sampledAtUnixNano: integer|Long expected";
                        return null;
                    };

                    /**
                     * Creates an InterfaceMetrics message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof telemetry.module.network.v1.InterfaceMetrics
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {telemetry.module.network.v1.InterfaceMetrics} InterfaceMetrics
                     */
                    InterfaceMetrics.fromObject = function fromObject(object) {
                        if (object instanceof $root.telemetry.module.network.v1.InterfaceMetrics)
                            return object;
                        let message = new $root.telemetry.module.network.v1.InterfaceMetrics();
                        if (object.name != null)
                            message.name = String(object.name);
                        if (object.ips) {
                            if (!Array.isArray(object.ips))
                                throw TypeError(".telemetry.module.network.v1.InterfaceMetrics.ips: array expected");
                            message.ips = [];
                            for (let i = 0; i < object.ips.length; ++i)
                                message.ips[i] = String(object.ips[i]);
                        }
                        if (object.rxBytes != null)
                            if ($util.Long)
                                (message.rxBytes = $util.Long.fromValue(object.rxBytes)).unsigned = true;
                            else if (typeof object.rxBytes === "string")
                                message.rxBytes = parseInt(object.rxBytes, 10);
                            else if (typeof object.rxBytes === "number")
                                message.rxBytes = object.rxBytes;
                            else if (typeof object.rxBytes === "object")
                                message.rxBytes = new $util.LongBits(object.rxBytes.low >>> 0, object.rxBytes.high >>> 0).toNumber(true);
                        if (object.rxPackets != null)
                            if ($util.Long)
                                (message.rxPackets = $util.Long.fromValue(object.rxPackets)).unsigned = true;
                            else if (typeof object.rxPackets === "string")
                                message.rxPackets = parseInt(object.rxPackets, 10);
                            else if (typeof object.rxPackets === "number")
                                message.rxPackets = object.rxPackets;
                            else if (typeof object.rxPackets === "object")
                                message.rxPackets = new $util.LongBits(object.rxPackets.low >>> 0, object.rxPackets.high >>> 0).toNumber(true);
                        if (object.txBytes != null)
                            if ($util.Long)
                                (message.txBytes = $util.Long.fromValue(object.txBytes)).unsigned = true;
                            else if (typeof object.txBytes === "string")
                                message.txBytes = parseInt(object.txBytes, 10);
                            else if (typeof object.txBytes === "number")
                                message.txBytes = object.txBytes;
                            else if (typeof object.txBytes === "object")
                                message.txBytes = new $util.LongBits(object.txBytes.low >>> 0, object.txBytes.high >>> 0).toNumber(true);
                        if (object.txPackets != null)
                            if ($util.Long)
                                (message.txPackets = $util.Long.fromValue(object.txPackets)).unsigned = true;
                            else if (typeof object.txPackets === "string")
                                message.txPackets = parseInt(object.txPackets, 10);
                            else if (typeof object.txPackets === "number")
                                message.txPackets = object.txPackets;
                            else if (typeof object.txPackets === "object")
                                message.txPackets = new $util.LongBits(object.txPackets.low >>> 0, object.txPackets.high >>> 0).toNumber(true);
                        if (object.sampledAtUnixNano != null)
                            if ($util.Long)
                                (message.sampledAtUnixNano = $util.Long.fromValue(object.sampledAtUnixNano)).unsigned = false;
                            else if (typeof object.sampledAtUnixNano === "string")
                                message.sampledAtUnixNano = parseInt(object.sampledAtUnixNano, 10);
                            else if (typeof object.sampledAtUnixNano === "number")
                                message.sampledAtUnixNano = object.sampledAtUnixNano;
                            else if (typeof object.sampledAtUnixNano === "object")
                                message.sampledAtUnixNano = new $util.LongBits(object.sampledAtUnixNano.low >>> 0, object.sampledAtUnixNano.high >>> 0).toNumber();
                        return message;
                    };

                    /**
                     * Creates a plain object from an InterfaceMetrics message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof telemetry.module.network.v1.InterfaceMetrics
                     * @static
                     * @param {telemetry.module.network.v1.InterfaceMetrics} message InterfaceMetrics
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    InterfaceMetrics.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.arrays || options.defaults)
                            object.ips = [];
                        if (options.defaults) {
                            object.name = "";
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, true);
                                object.rxBytes = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.rxBytes = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, true);
                                object.rxPackets = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.rxPackets = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, true);
                                object.txBytes = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.txBytes = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, true);
                                object.txPackets = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.txPackets = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, false);
                                object.sampledAtUnixNano = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.sampledAtUnixNano = options.longs === String ? "0" : 0;
                        }
                        if (message.name != null && message.hasOwnProperty("name"))
                            object.name = message.name;
                        if (message.ips && message.ips.length) {
                            object.ips = [];
                            for (let j = 0; j < message.ips.length; ++j)
                                object.ips[j] = message.ips[j];
                        }
                        if (message.rxBytes != null && message.hasOwnProperty("rxBytes"))
                            if (typeof message.rxBytes === "number")
                                object.rxBytes = options.longs === String ? String(message.rxBytes) : message.rxBytes;
                            else
                                object.rxBytes = options.longs === String ? $util.Long.prototype.toString.call(message.rxBytes) : options.longs === Number ? new $util.LongBits(message.rxBytes.low >>> 0, message.rxBytes.high >>> 0).toNumber(true) : message.rxBytes;
                        if (message.rxPackets != null && message.hasOwnProperty("rxPackets"))
                            if (typeof message.rxPackets === "number")
                                object.rxPackets = options.longs === String ? String(message.rxPackets) : message.rxPackets;
                            else
                                object.rxPackets = options.longs === String ? $util.Long.prototype.toString.call(message.rxPackets) : options.longs === Number ? new $util.LongBits(message.rxPackets.low >>> 0, message.rxPackets.high >>> 0).toNumber(true) : message.rxPackets;
                        if (message.txBytes != null && message.hasOwnProperty("txBytes"))
                            if (typeof message.txBytes === "number")
                                object.txBytes = options.longs === String ? String(message.txBytes) : message.txBytes;
                            else
                                object.txBytes = options.longs === String ? $util.Long.prototype.toString.call(message.txBytes) : options.longs === Number ? new $util.LongBits(message.txBytes.low >>> 0, message.txBytes.high >>> 0).toNumber(true) : message.txBytes;
                        if (message.txPackets != null && message.hasOwnProperty("txPackets"))
                            if (typeof message.txPackets === "number")
                                object.txPackets = options.longs === String ? String(message.txPackets) : message.txPackets;
                            else
                                object.txPackets = options.longs === String ? $util.Long.prototype.toString.call(message.txPackets) : options.longs === Number ? new $util.LongBits(message.txPackets.low >>> 0, message.txPackets.high >>> 0).toNumber(true) : message.txPackets;
                        if (message.sampledAtUnixNano != null && message.hasOwnProperty("sampledAtUnixNano"))
                            if (typeof message.sampledAtUnixNano === "number")
                                object.sampledAtUnixNano = options.longs === String ? String(message.sampledAtUnixNano) : message.sampledAtUnixNano;
                            else
                                object.sampledAtUnixNano = options.longs === String ? $util.Long.prototype.toString.call(message.sampledAtUnixNano) : options.longs === Number ? new $util.LongBits(message.sampledAtUnixNano.low >>> 0, message.sampledAtUnixNano.high >>> 0).toNumber() : message.sampledAtUnixNano;
                        return object;
                    };

                    /**
                     * Converts this InterfaceMetrics to JSON.
                     * @function toJSON
                     * @memberof telemetry.module.network.v1.InterfaceMetrics
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    InterfaceMetrics.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Gets the default type url for InterfaceMetrics
                     * @function getTypeUrl
                     * @memberof telemetry.module.network.v1.InterfaceMetrics
                     * @static
                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                     * @returns {string} The default type url
                     */
                    InterfaceMetrics.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                        if (typeUrlPrefix === undefined) {
                            typeUrlPrefix = "type.googleapis.com";
                        }
                        return typeUrlPrefix + "/telemetry.module.network.v1.InterfaceMetrics";
                    };

                    return InterfaceMetrics;
                })();

                v1.Metrics = (function() {

                    /**
                     * Properties of a Metrics.
                     * @memberof telemetry.module.network.v1
                     * @interface IMetrics
                     * @property {Array.<telemetry.module.network.v1.IInterfaceMetrics>|null} [interfaces] Metrics interfaces
                     */

                    /**
                     * Constructs a new Metrics.
                     * @memberof telemetry.module.network.v1
                     * @classdesc Represents a Metrics.
                     * @implements IMetrics
                     * @constructor
                     * @param {telemetry.module.network.v1.IMetrics=} [properties] Properties to set
                     */
                    function Metrics(properties) {
                        this.interfaces = [];
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Metrics interfaces.
                     * @member {Array.<telemetry.module.network.v1.IInterfaceMetrics>} interfaces
                     * @memberof telemetry.module.network.v1.Metrics
                     * @instance
                     */
                    Metrics.prototype.interfaces = $util.emptyArray;

                    /**
                     * Creates a new Metrics instance using the specified properties.
                     * @function create
                     * @memberof telemetry.module.network.v1.Metrics
                     * @static
                     * @param {telemetry.module.network.v1.IMetrics=} [properties] Properties to set
                     * @returns {telemetry.module.network.v1.Metrics} Metrics instance
                     */
                    Metrics.create = function create(properties) {
                        return new Metrics(properties);
                    };

                    /**
                     * Encodes the specified Metrics message. Does not implicitly {@link telemetry.module.network.v1.Metrics.verify|verify} messages.
                     * @function encode
                     * @memberof telemetry.module.network.v1.Metrics
                     * @static
                     * @param {telemetry.module.network.v1.IMetrics} message Metrics message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Metrics.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.interfaces != null && message.interfaces.length)
                            for (let i = 0; i < message.interfaces.length; ++i)
                                $root.telemetry.module.network.v1.InterfaceMetrics.encode(message.interfaces[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        return writer;
                    };

                    /**
                     * Encodes the specified Metrics message, length delimited. Does not implicitly {@link telemetry.module.network.v1.Metrics.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof telemetry.module.network.v1.Metrics
                     * @static
                     * @param {telemetry.module.network.v1.IMetrics} message Metrics message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Metrics.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Metrics message from the specified reader or buffer.
                     * @function decode
                     * @memberof telemetry.module.network.v1.Metrics
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {telemetry.module.network.v1.Metrics} Metrics
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Metrics.decode = function decode(reader, length, error) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.telemetry.module.network.v1.Metrics();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            if (tag === error)
                                break;
                            switch (tag >>> 3) {
                            case 1: {
                                    if (!(message.interfaces && message.interfaces.length))
                                        message.interfaces = [];
                                    message.interfaces.push($root.telemetry.module.network.v1.InterfaceMetrics.decode(reader, reader.uint32()));
                                    break;
                                }
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Metrics message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof telemetry.module.network.v1.Metrics
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {telemetry.module.network.v1.Metrics} Metrics
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Metrics.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Metrics message.
                     * @function verify
                     * @memberof telemetry.module.network.v1.Metrics
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Metrics.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.interfaces != null && message.hasOwnProperty("interfaces")) {
                            if (!Array.isArray(message.interfaces))
                                return "interfaces: array expected";
                            for (let i = 0; i < message.interfaces.length; ++i) {
                                let error = $root.telemetry.module.network.v1.InterfaceMetrics.verify(message.interfaces[i]);
                                if (error)
                                    return "interfaces." + error;
                            }
                        }
                        return null;
                    };

                    /**
                     * Creates a Metrics message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof telemetry.module.network.v1.Metrics
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {telemetry.module.network.v1.Metrics} Metrics
                     */
                    Metrics.fromObject = function fromObject(object) {
                        if (object instanceof $root.telemetry.module.network.v1.Metrics)
                            return object;
                        let message = new $root.telemetry.module.network.v1.Metrics();
                        if (object.interfaces) {
                            if (!Array.isArray(object.interfaces))
                                throw TypeError(".telemetry.module.network.v1.Metrics.interfaces: array expected");
                            message.interfaces = [];
                            for (let i = 0; i < object.interfaces.length; ++i) {
                                if (typeof object.interfaces[i] !== "object")
                                    throw TypeError(".telemetry.module.network.v1.Metrics.interfaces: object expected");
                                message.interfaces[i] = $root.telemetry.module.network.v1.InterfaceMetrics.fromObject(object.interfaces[i]);
                            }
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a Metrics message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof telemetry.module.network.v1.Metrics
                     * @static
                     * @param {telemetry.module.network.v1.Metrics} message Metrics
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Metrics.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.arrays || options.defaults)
                            object.interfaces = [];
                        if (message.interfaces && message.interfaces.length) {
                            object.interfaces = [];
                            for (let j = 0; j < message.interfaces.length; ++j)
                                object.interfaces[j] = $root.telemetry.module.network.v1.InterfaceMetrics.toObject(message.interfaces[j], options);
                        }
                        return object;
                    };

                    /**
                     * Converts this Metrics to JSON.
                     * @function toJSON
                     * @memberof telemetry.module.network.v1.Metrics
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Metrics.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Gets the default type url for Metrics
                     * @function getTypeUrl
                     * @memberof telemetry.module.network.v1.Metrics
                     * @static
                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                     * @returns {string} The default type url
                     */
                    Metrics.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                        if (typeUrlPrefix === undefined) {
                            typeUrlPrefix = "type.googleapis.com";
                        }
                        return typeUrlPrefix + "/telemetry.module.network.v1.Metrics";
                    };

                    return Metrics;
                })();

                return v1;
            })();

            return network;
        })();

        module.process = (function() {

            /**
             * Namespace process.
             * @memberof telemetry.module
             * @namespace
             */
            const process = {};

            process.v1 = (function() {

                /**
                 * Namespace v1.
                 * @memberof telemetry.module.process
                 * @namespace
                 */
                const v1 = {};

                v1.CollectorSpec = (function() {

                    /**
                     * Properties of a CollectorSpec.
                     * @memberof telemetry.module.process.v1
                     * @interface ICollectorSpec
                     * @property {string|null} [category] CollectorSpec category
                     * @property {string|null} [interval] CollectorSpec interval
                     */

                    /**
                     * Constructs a new CollectorSpec.
                     * @memberof telemetry.module.process.v1
                     * @classdesc Represents a CollectorSpec.
                     * @implements ICollectorSpec
                     * @constructor
                     * @param {telemetry.module.process.v1.ICollectorSpec=} [properties] Properties to set
                     */
                    function CollectorSpec(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * CollectorSpec category.
                     * @member {string} category
                     * @memberof telemetry.module.process.v1.CollectorSpec
                     * @instance
                     */
                    CollectorSpec.prototype.category = "";

                    /**
                     * CollectorSpec interval.
                     * @member {string} interval
                     * @memberof telemetry.module.process.v1.CollectorSpec
                     * @instance
                     */
                    CollectorSpec.prototype.interval = "";

                    /**
                     * Creates a new CollectorSpec instance using the specified properties.
                     * @function create
                     * @memberof telemetry.module.process.v1.CollectorSpec
                     * @static
                     * @param {telemetry.module.process.v1.ICollectorSpec=} [properties] Properties to set
                     * @returns {telemetry.module.process.v1.CollectorSpec} CollectorSpec instance
                     */
                    CollectorSpec.create = function create(properties) {
                        return new CollectorSpec(properties);
                    };

                    /**
                     * Encodes the specified CollectorSpec message. Does not implicitly {@link telemetry.module.process.v1.CollectorSpec.verify|verify} messages.
                     * @function encode
                     * @memberof telemetry.module.process.v1.CollectorSpec
                     * @static
                     * @param {telemetry.module.process.v1.ICollectorSpec} message CollectorSpec message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    CollectorSpec.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.category != null && Object.hasOwnProperty.call(message, "category"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.category);
                        if (message.interval != null && Object.hasOwnProperty.call(message, "interval"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.interval);
                        return writer;
                    };

                    /**
                     * Encodes the specified CollectorSpec message, length delimited. Does not implicitly {@link telemetry.module.process.v1.CollectorSpec.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof telemetry.module.process.v1.CollectorSpec
                     * @static
                     * @param {telemetry.module.process.v1.ICollectorSpec} message CollectorSpec message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    CollectorSpec.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a CollectorSpec message from the specified reader or buffer.
                     * @function decode
                     * @memberof telemetry.module.process.v1.CollectorSpec
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {telemetry.module.process.v1.CollectorSpec} CollectorSpec
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    CollectorSpec.decode = function decode(reader, length, error) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.telemetry.module.process.v1.CollectorSpec();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            if (tag === error)
                                break;
                            switch (tag >>> 3) {
                            case 1: {
                                    message.category = reader.string();
                                    break;
                                }
                            case 2: {
                                    message.interval = reader.string();
                                    break;
                                }
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a CollectorSpec message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof telemetry.module.process.v1.CollectorSpec
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {telemetry.module.process.v1.CollectorSpec} CollectorSpec
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    CollectorSpec.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a CollectorSpec message.
                     * @function verify
                     * @memberof telemetry.module.process.v1.CollectorSpec
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    CollectorSpec.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.category != null && message.hasOwnProperty("category"))
                            if (!$util.isString(message.category))
                                return "category: string expected";
                        if (message.interval != null && message.hasOwnProperty("interval"))
                            if (!$util.isString(message.interval))
                                return "interval: string expected";
                        return null;
                    };

                    /**
                     * Creates a CollectorSpec message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof telemetry.module.process.v1.CollectorSpec
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {telemetry.module.process.v1.CollectorSpec} CollectorSpec
                     */
                    CollectorSpec.fromObject = function fromObject(object) {
                        if (object instanceof $root.telemetry.module.process.v1.CollectorSpec)
                            return object;
                        let message = new $root.telemetry.module.process.v1.CollectorSpec();
                        if (object.category != null)
                            message.category = String(object.category);
                        if (object.interval != null)
                            message.interval = String(object.interval);
                        return message;
                    };

                    /**
                     * Creates a plain object from a CollectorSpec message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof telemetry.module.process.v1.CollectorSpec
                     * @static
                     * @param {telemetry.module.process.v1.CollectorSpec} message CollectorSpec
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    CollectorSpec.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.category = "";
                            object.interval = "";
                        }
                        if (message.category != null && message.hasOwnProperty("category"))
                            object.category = message.category;
                        if (message.interval != null && message.hasOwnProperty("interval"))
                            object.interval = message.interval;
                        return object;
                    };

                    /**
                     * Converts this CollectorSpec to JSON.
                     * @function toJSON
                     * @memberof telemetry.module.process.v1.CollectorSpec
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    CollectorSpec.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Gets the default type url for CollectorSpec
                     * @function getTypeUrl
                     * @memberof telemetry.module.process.v1.CollectorSpec
                     * @static
                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                     * @returns {string} The default type url
                     */
                    CollectorSpec.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                        if (typeUrlPrefix === undefined) {
                            typeUrlPrefix = "type.googleapis.com";
                        }
                        return typeUrlPrefix + "/telemetry.module.process.v1.CollectorSpec";
                    };

                    return CollectorSpec;
                })();

                v1.ControllerSpec = (function() {

                    /**
                     * Properties of a ControllerSpec.
                     * @memberof telemetry.module.process.v1
                     * @interface IControllerSpec
                     * @property {string|null} [type] ControllerSpec type
                     */

                    /**
                     * Constructs a new ControllerSpec.
                     * @memberof telemetry.module.process.v1
                     * @classdesc Represents a ControllerSpec.
                     * @implements IControllerSpec
                     * @constructor
                     * @param {telemetry.module.process.v1.IControllerSpec=} [properties] Properties to set
                     */
                    function ControllerSpec(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * ControllerSpec type.
                     * @member {string} type
                     * @memberof telemetry.module.process.v1.ControllerSpec
                     * @instance
                     */
                    ControllerSpec.prototype.type = "";

                    /**
                     * Creates a new ControllerSpec instance using the specified properties.
                     * @function create
                     * @memberof telemetry.module.process.v1.ControllerSpec
                     * @static
                     * @param {telemetry.module.process.v1.IControllerSpec=} [properties] Properties to set
                     * @returns {telemetry.module.process.v1.ControllerSpec} ControllerSpec instance
                     */
                    ControllerSpec.create = function create(properties) {
                        return new ControllerSpec(properties);
                    };

                    /**
                     * Encodes the specified ControllerSpec message. Does not implicitly {@link telemetry.module.process.v1.ControllerSpec.verify|verify} messages.
                     * @function encode
                     * @memberof telemetry.module.process.v1.ControllerSpec
                     * @static
                     * @param {telemetry.module.process.v1.IControllerSpec} message ControllerSpec message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ControllerSpec.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.type);
                        return writer;
                    };

                    /**
                     * Encodes the specified ControllerSpec message, length delimited. Does not implicitly {@link telemetry.module.process.v1.ControllerSpec.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof telemetry.module.process.v1.ControllerSpec
                     * @static
                     * @param {telemetry.module.process.v1.IControllerSpec} message ControllerSpec message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ControllerSpec.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a ControllerSpec message from the specified reader or buffer.
                     * @function decode
                     * @memberof telemetry.module.process.v1.ControllerSpec
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {telemetry.module.process.v1.ControllerSpec} ControllerSpec
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ControllerSpec.decode = function decode(reader, length, error) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.telemetry.module.process.v1.ControllerSpec();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            if (tag === error)
                                break;
                            switch (tag >>> 3) {
                            case 1: {
                                    message.type = reader.string();
                                    break;
                                }
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a ControllerSpec message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof telemetry.module.process.v1.ControllerSpec
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {telemetry.module.process.v1.ControllerSpec} ControllerSpec
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ControllerSpec.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a ControllerSpec message.
                     * @function verify
                     * @memberof telemetry.module.process.v1.ControllerSpec
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    ControllerSpec.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.type != null && message.hasOwnProperty("type"))
                            if (!$util.isString(message.type))
                                return "type: string expected";
                        return null;
                    };

                    /**
                     * Creates a ControllerSpec message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof telemetry.module.process.v1.ControllerSpec
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {telemetry.module.process.v1.ControllerSpec} ControllerSpec
                     */
                    ControllerSpec.fromObject = function fromObject(object) {
                        if (object instanceof $root.telemetry.module.process.v1.ControllerSpec)
                            return object;
                        let message = new $root.telemetry.module.process.v1.ControllerSpec();
                        if (object.type != null)
                            message.type = String(object.type);
                        return message;
                    };

                    /**
                     * Creates a plain object from a ControllerSpec message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof telemetry.module.process.v1.ControllerSpec
                     * @static
                     * @param {telemetry.module.process.v1.ControllerSpec} message ControllerSpec
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    ControllerSpec.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults)
                            object.type = "";
                        if (message.type != null && message.hasOwnProperty("type"))
                            object.type = message.type;
                        return object;
                    };

                    /**
                     * Converts this ControllerSpec to JSON.
                     * @function toJSON
                     * @memberof telemetry.module.process.v1.ControllerSpec
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    ControllerSpec.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Gets the default type url for ControllerSpec
                     * @function getTypeUrl
                     * @memberof telemetry.module.process.v1.ControllerSpec
                     * @static
                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                     * @returns {string} The default type url
                     */
                    ControllerSpec.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                        if (typeUrlPrefix === undefined) {
                            typeUrlPrefix = "type.googleapis.com";
                        }
                        return typeUrlPrefix + "/telemetry.module.process.v1.ControllerSpec";
                    };

                    return ControllerSpec;
                })();

                v1.ModuleRegistration = (function() {

                    /**
                     * Properties of a ModuleRegistration.
                     * @memberof telemetry.module.process.v1
                     * @interface IModuleRegistration
                     * @property {Array.<telemetry.module.process.v1.ICollectorSpec>|null} [collectors] ModuleRegistration collectors
                     * @property {Array.<telemetry.module.process.v1.IControllerSpec>|null} [controllers] ModuleRegistration controllers
                     */

                    /**
                     * Constructs a new ModuleRegistration.
                     * @memberof telemetry.module.process.v1
                     * @classdesc Represents a ModuleRegistration.
                     * @implements IModuleRegistration
                     * @constructor
                     * @param {telemetry.module.process.v1.IModuleRegistration=} [properties] Properties to set
                     */
                    function ModuleRegistration(properties) {
                        this.collectors = [];
                        this.controllers = [];
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * ModuleRegistration collectors.
                     * @member {Array.<telemetry.module.process.v1.ICollectorSpec>} collectors
                     * @memberof telemetry.module.process.v1.ModuleRegistration
                     * @instance
                     */
                    ModuleRegistration.prototype.collectors = $util.emptyArray;

                    /**
                     * ModuleRegistration controllers.
                     * @member {Array.<telemetry.module.process.v1.IControllerSpec>} controllers
                     * @memberof telemetry.module.process.v1.ModuleRegistration
                     * @instance
                     */
                    ModuleRegistration.prototype.controllers = $util.emptyArray;

                    /**
                     * Creates a new ModuleRegistration instance using the specified properties.
                     * @function create
                     * @memberof telemetry.module.process.v1.ModuleRegistration
                     * @static
                     * @param {telemetry.module.process.v1.IModuleRegistration=} [properties] Properties to set
                     * @returns {telemetry.module.process.v1.ModuleRegistration} ModuleRegistration instance
                     */
                    ModuleRegistration.create = function create(properties) {
                        return new ModuleRegistration(properties);
                    };

                    /**
                     * Encodes the specified ModuleRegistration message. Does not implicitly {@link telemetry.module.process.v1.ModuleRegistration.verify|verify} messages.
                     * @function encode
                     * @memberof telemetry.module.process.v1.ModuleRegistration
                     * @static
                     * @param {telemetry.module.process.v1.IModuleRegistration} message ModuleRegistration message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ModuleRegistration.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.collectors != null && message.collectors.length)
                            for (let i = 0; i < message.collectors.length; ++i)
                                $root.telemetry.module.process.v1.CollectorSpec.encode(message.collectors[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.controllers != null && message.controllers.length)
                            for (let i = 0; i < message.controllers.length; ++i)
                                $root.telemetry.module.process.v1.ControllerSpec.encode(message.controllers[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                        return writer;
                    };

                    /**
                     * Encodes the specified ModuleRegistration message, length delimited. Does not implicitly {@link telemetry.module.process.v1.ModuleRegistration.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof telemetry.module.process.v1.ModuleRegistration
                     * @static
                     * @param {telemetry.module.process.v1.IModuleRegistration} message ModuleRegistration message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ModuleRegistration.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a ModuleRegistration message from the specified reader or buffer.
                     * @function decode
                     * @memberof telemetry.module.process.v1.ModuleRegistration
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {telemetry.module.process.v1.ModuleRegistration} ModuleRegistration
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ModuleRegistration.decode = function decode(reader, length, error) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.telemetry.module.process.v1.ModuleRegistration();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            if (tag === error)
                                break;
                            switch (tag >>> 3) {
                            case 1: {
                                    if (!(message.collectors && message.collectors.length))
                                        message.collectors = [];
                                    message.collectors.push($root.telemetry.module.process.v1.CollectorSpec.decode(reader, reader.uint32()));
                                    break;
                                }
                            case 2: {
                                    if (!(message.controllers && message.controllers.length))
                                        message.controllers = [];
                                    message.controllers.push($root.telemetry.module.process.v1.ControllerSpec.decode(reader, reader.uint32()));
                                    break;
                                }
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a ModuleRegistration message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof telemetry.module.process.v1.ModuleRegistration
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {telemetry.module.process.v1.ModuleRegistration} ModuleRegistration
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ModuleRegistration.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a ModuleRegistration message.
                     * @function verify
                     * @memberof telemetry.module.process.v1.ModuleRegistration
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    ModuleRegistration.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.collectors != null && message.hasOwnProperty("collectors")) {
                            if (!Array.isArray(message.collectors))
                                return "collectors: array expected";
                            for (let i = 0; i < message.collectors.length; ++i) {
                                let error = $root.telemetry.module.process.v1.CollectorSpec.verify(message.collectors[i]);
                                if (error)
                                    return "collectors." + error;
                            }
                        }
                        if (message.controllers != null && message.hasOwnProperty("controllers")) {
                            if (!Array.isArray(message.controllers))
                                return "controllers: array expected";
                            for (let i = 0; i < message.controllers.length; ++i) {
                                let error = $root.telemetry.module.process.v1.ControllerSpec.verify(message.controllers[i]);
                                if (error)
                                    return "controllers." + error;
                            }
                        }
                        return null;
                    };

                    /**
                     * Creates a ModuleRegistration message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof telemetry.module.process.v1.ModuleRegistration
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {telemetry.module.process.v1.ModuleRegistration} ModuleRegistration
                     */
                    ModuleRegistration.fromObject = function fromObject(object) {
                        if (object instanceof $root.telemetry.module.process.v1.ModuleRegistration)
                            return object;
                        let message = new $root.telemetry.module.process.v1.ModuleRegistration();
                        if (object.collectors) {
                            if (!Array.isArray(object.collectors))
                                throw TypeError(".telemetry.module.process.v1.ModuleRegistration.collectors: array expected");
                            message.collectors = [];
                            for (let i = 0; i < object.collectors.length; ++i) {
                                if (typeof object.collectors[i] !== "object")
                                    throw TypeError(".telemetry.module.process.v1.ModuleRegistration.collectors: object expected");
                                message.collectors[i] = $root.telemetry.module.process.v1.CollectorSpec.fromObject(object.collectors[i]);
                            }
                        }
                        if (object.controllers) {
                            if (!Array.isArray(object.controllers))
                                throw TypeError(".telemetry.module.process.v1.ModuleRegistration.controllers: array expected");
                            message.controllers = [];
                            for (let i = 0; i < object.controllers.length; ++i) {
                                if (typeof object.controllers[i] !== "object")
                                    throw TypeError(".telemetry.module.process.v1.ModuleRegistration.controllers: object expected");
                                message.controllers[i] = $root.telemetry.module.process.v1.ControllerSpec.fromObject(object.controllers[i]);
                            }
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a ModuleRegistration message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof telemetry.module.process.v1.ModuleRegistration
                     * @static
                     * @param {telemetry.module.process.v1.ModuleRegistration} message ModuleRegistration
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    ModuleRegistration.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.arrays || options.defaults) {
                            object.collectors = [];
                            object.controllers = [];
                        }
                        if (message.collectors && message.collectors.length) {
                            object.collectors = [];
                            for (let j = 0; j < message.collectors.length; ++j)
                                object.collectors[j] = $root.telemetry.module.process.v1.CollectorSpec.toObject(message.collectors[j], options);
                        }
                        if (message.controllers && message.controllers.length) {
                            object.controllers = [];
                            for (let j = 0; j < message.controllers.length; ++j)
                                object.controllers[j] = $root.telemetry.module.process.v1.ControllerSpec.toObject(message.controllers[j], options);
                        }
                        return object;
                    };

                    /**
                     * Converts this ModuleRegistration to JSON.
                     * @function toJSON
                     * @memberof telemetry.module.process.v1.ModuleRegistration
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    ModuleRegistration.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Gets the default type url for ModuleRegistration
                     * @function getTypeUrl
                     * @memberof telemetry.module.process.v1.ModuleRegistration
                     * @static
                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                     * @returns {string} The default type url
                     */
                    ModuleRegistration.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                        if (typeUrlPrefix === undefined) {
                            typeUrlPrefix = "type.googleapis.com";
                        }
                        return typeUrlPrefix + "/telemetry.module.process.v1.ModuleRegistration";
                    };

                    return ModuleRegistration;
                })();

                v1.Info = (function() {

                    /**
                     * Properties of an Info.
                     * @memberof telemetry.module.process.v1
                     * @interface IInfo
                     * @property {number|null} [pid] Info pid
                     * @property {number|null} [ppid] Info ppid
                     * @property {string|null} [user] Info user
                     * @property {string|null} [state] Info state
                     * @property {number|null} [cpuPercent] Info cpuPercent
                     * @property {number|Long|null} [memoryBytes] Info memoryBytes
                     * @property {string|null} [command] Info command
                     * @property {number|Long|null} [sampledAtUnixNano] Info sampledAtUnixNano
                     */

                    /**
                     * Constructs a new Info.
                     * @memberof telemetry.module.process.v1
                     * @classdesc Represents an Info.
                     * @implements IInfo
                     * @constructor
                     * @param {telemetry.module.process.v1.IInfo=} [properties] Properties to set
                     */
                    function Info(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Info pid.
                     * @member {number} pid
                     * @memberof telemetry.module.process.v1.Info
                     * @instance
                     */
                    Info.prototype.pid = 0;

                    /**
                     * Info ppid.
                     * @member {number} ppid
                     * @memberof telemetry.module.process.v1.Info
                     * @instance
                     */
                    Info.prototype.ppid = 0;

                    /**
                     * Info user.
                     * @member {string} user
                     * @memberof telemetry.module.process.v1.Info
                     * @instance
                     */
                    Info.prototype.user = "";

                    /**
                     * Info state.
                     * @member {string} state
                     * @memberof telemetry.module.process.v1.Info
                     * @instance
                     */
                    Info.prototype.state = "";

                    /**
                     * Info cpuPercent.
                     * @member {number} cpuPercent
                     * @memberof telemetry.module.process.v1.Info
                     * @instance
                     */
                    Info.prototype.cpuPercent = 0;

                    /**
                     * Info memoryBytes.
                     * @member {number|Long} memoryBytes
                     * @memberof telemetry.module.process.v1.Info
                     * @instance
                     */
                    Info.prototype.memoryBytes = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                    /**
                     * Info command.
                     * @member {string} command
                     * @memberof telemetry.module.process.v1.Info
                     * @instance
                     */
                    Info.prototype.command = "";

                    /**
                     * Info sampledAtUnixNano.
                     * @member {number|Long} sampledAtUnixNano
                     * @memberof telemetry.module.process.v1.Info
                     * @instance
                     */
                    Info.prototype.sampledAtUnixNano = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                    /**
                     * Creates a new Info instance using the specified properties.
                     * @function create
                     * @memberof telemetry.module.process.v1.Info
                     * @static
                     * @param {telemetry.module.process.v1.IInfo=} [properties] Properties to set
                     * @returns {telemetry.module.process.v1.Info} Info instance
                     */
                    Info.create = function create(properties) {
                        return new Info(properties);
                    };

                    /**
                     * Encodes the specified Info message. Does not implicitly {@link telemetry.module.process.v1.Info.verify|verify} messages.
                     * @function encode
                     * @memberof telemetry.module.process.v1.Info
                     * @static
                     * @param {telemetry.module.process.v1.IInfo} message Info message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Info.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.pid != null && Object.hasOwnProperty.call(message, "pid"))
                            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.pid);
                        if (message.ppid != null && Object.hasOwnProperty.call(message, "ppid"))
                            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.ppid);
                        if (message.user != null && Object.hasOwnProperty.call(message, "user"))
                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.user);
                        if (message.state != null && Object.hasOwnProperty.call(message, "state"))
                            writer.uint32(/* id 4, wireType 2 =*/34).string(message.state);
                        if (message.cpuPercent != null && Object.hasOwnProperty.call(message, "cpuPercent"))
                            writer.uint32(/* id 5, wireType 1 =*/41).double(message.cpuPercent);
                        if (message.memoryBytes != null && Object.hasOwnProperty.call(message, "memoryBytes"))
                            writer.uint32(/* id 6, wireType 0 =*/48).uint64(message.memoryBytes);
                        if (message.command != null && Object.hasOwnProperty.call(message, "command"))
                            writer.uint32(/* id 7, wireType 2 =*/58).string(message.command);
                        if (message.sampledAtUnixNano != null && Object.hasOwnProperty.call(message, "sampledAtUnixNano"))
                            writer.uint32(/* id 8, wireType 0 =*/64).int64(message.sampledAtUnixNano);
                        return writer;
                    };

                    /**
                     * Encodes the specified Info message, length delimited. Does not implicitly {@link telemetry.module.process.v1.Info.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof telemetry.module.process.v1.Info
                     * @static
                     * @param {telemetry.module.process.v1.IInfo} message Info message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Info.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes an Info message from the specified reader or buffer.
                     * @function decode
                     * @memberof telemetry.module.process.v1.Info
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {telemetry.module.process.v1.Info} Info
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Info.decode = function decode(reader, length, error) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.telemetry.module.process.v1.Info();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            if (tag === error)
                                break;
                            switch (tag >>> 3) {
                            case 1: {
                                    message.pid = reader.int32();
                                    break;
                                }
                            case 2: {
                                    message.ppid = reader.int32();
                                    break;
                                }
                            case 3: {
                                    message.user = reader.string();
                                    break;
                                }
                            case 4: {
                                    message.state = reader.string();
                                    break;
                                }
                            case 5: {
                                    message.cpuPercent = reader.double();
                                    break;
                                }
                            case 6: {
                                    message.memoryBytes = reader.uint64();
                                    break;
                                }
                            case 7: {
                                    message.command = reader.string();
                                    break;
                                }
                            case 8: {
                                    message.sampledAtUnixNano = reader.int64();
                                    break;
                                }
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes an Info message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof telemetry.module.process.v1.Info
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {telemetry.module.process.v1.Info} Info
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Info.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies an Info message.
                     * @function verify
                     * @memberof telemetry.module.process.v1.Info
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Info.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.pid != null && message.hasOwnProperty("pid"))
                            if (!$util.isInteger(message.pid))
                                return "pid: integer expected";
                        if (message.ppid != null && message.hasOwnProperty("ppid"))
                            if (!$util.isInteger(message.ppid))
                                return "ppid: integer expected";
                        if (message.user != null && message.hasOwnProperty("user"))
                            if (!$util.isString(message.user))
                                return "user: string expected";
                        if (message.state != null && message.hasOwnProperty("state"))
                            if (!$util.isString(message.state))
                                return "state: string expected";
                        if (message.cpuPercent != null && message.hasOwnProperty("cpuPercent"))
                            if (typeof message.cpuPercent !== "number")
                                return "cpuPercent: number expected";
                        if (message.memoryBytes != null && message.hasOwnProperty("memoryBytes"))
                            if (!$util.isInteger(message.memoryBytes) && !(message.memoryBytes && $util.isInteger(message.memoryBytes.low) && $util.isInteger(message.memoryBytes.high)))
                                return "memoryBytes: integer|Long expected";
                        if (message.command != null && message.hasOwnProperty("command"))
                            if (!$util.isString(message.command))
                                return "command: string expected";
                        if (message.sampledAtUnixNano != null && message.hasOwnProperty("sampledAtUnixNano"))
                            if (!$util.isInteger(message.sampledAtUnixNano) && !(message.sampledAtUnixNano && $util.isInteger(message.sampledAtUnixNano.low) && $util.isInteger(message.sampledAtUnixNano.high)))
                                return "sampledAtUnixNano: integer|Long expected";
                        return null;
                    };

                    /**
                     * Creates an Info message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof telemetry.module.process.v1.Info
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {telemetry.module.process.v1.Info} Info
                     */
                    Info.fromObject = function fromObject(object) {
                        if (object instanceof $root.telemetry.module.process.v1.Info)
                            return object;
                        let message = new $root.telemetry.module.process.v1.Info();
                        if (object.pid != null)
                            message.pid = object.pid | 0;
                        if (object.ppid != null)
                            message.ppid = object.ppid | 0;
                        if (object.user != null)
                            message.user = String(object.user);
                        if (object.state != null)
                            message.state = String(object.state);
                        if (object.cpuPercent != null)
                            message.cpuPercent = Number(object.cpuPercent);
                        if (object.memoryBytes != null)
                            if ($util.Long)
                                (message.memoryBytes = $util.Long.fromValue(object.memoryBytes)).unsigned = true;
                            else if (typeof object.memoryBytes === "string")
                                message.memoryBytes = parseInt(object.memoryBytes, 10);
                            else if (typeof object.memoryBytes === "number")
                                message.memoryBytes = object.memoryBytes;
                            else if (typeof object.memoryBytes === "object")
                                message.memoryBytes = new $util.LongBits(object.memoryBytes.low >>> 0, object.memoryBytes.high >>> 0).toNumber(true);
                        if (object.command != null)
                            message.command = String(object.command);
                        if (object.sampledAtUnixNano != null)
                            if ($util.Long)
                                (message.sampledAtUnixNano = $util.Long.fromValue(object.sampledAtUnixNano)).unsigned = false;
                            else if (typeof object.sampledAtUnixNano === "string")
                                message.sampledAtUnixNano = parseInt(object.sampledAtUnixNano, 10);
                            else if (typeof object.sampledAtUnixNano === "number")
                                message.sampledAtUnixNano = object.sampledAtUnixNano;
                            else if (typeof object.sampledAtUnixNano === "object")
                                message.sampledAtUnixNano = new $util.LongBits(object.sampledAtUnixNano.low >>> 0, object.sampledAtUnixNano.high >>> 0).toNumber();
                        return message;
                    };

                    /**
                     * Creates a plain object from an Info message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof telemetry.module.process.v1.Info
                     * @static
                     * @param {telemetry.module.process.v1.Info} message Info
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Info.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.pid = 0;
                            object.ppid = 0;
                            object.user = "";
                            object.state = "";
                            object.cpuPercent = 0;
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, true);
                                object.memoryBytes = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.memoryBytes = options.longs === String ? "0" : 0;
                            object.command = "";
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, false);
                                object.sampledAtUnixNano = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.sampledAtUnixNano = options.longs === String ? "0" : 0;
                        }
                        if (message.pid != null && message.hasOwnProperty("pid"))
                            object.pid = message.pid;
                        if (message.ppid != null && message.hasOwnProperty("ppid"))
                            object.ppid = message.ppid;
                        if (message.user != null && message.hasOwnProperty("user"))
                            object.user = message.user;
                        if (message.state != null && message.hasOwnProperty("state"))
                            object.state = message.state;
                        if (message.cpuPercent != null && message.hasOwnProperty("cpuPercent"))
                            object.cpuPercent = options.json && !isFinite(message.cpuPercent) ? String(message.cpuPercent) : message.cpuPercent;
                        if (message.memoryBytes != null && message.hasOwnProperty("memoryBytes"))
                            if (typeof message.memoryBytes === "number")
                                object.memoryBytes = options.longs === String ? String(message.memoryBytes) : message.memoryBytes;
                            else
                                object.memoryBytes = options.longs === String ? $util.Long.prototype.toString.call(message.memoryBytes) : options.longs === Number ? new $util.LongBits(message.memoryBytes.low >>> 0, message.memoryBytes.high >>> 0).toNumber(true) : message.memoryBytes;
                        if (message.command != null && message.hasOwnProperty("command"))
                            object.command = message.command;
                        if (message.sampledAtUnixNano != null && message.hasOwnProperty("sampledAtUnixNano"))
                            if (typeof message.sampledAtUnixNano === "number")
                                object.sampledAtUnixNano = options.longs === String ? String(message.sampledAtUnixNano) : message.sampledAtUnixNano;
                            else
                                object.sampledAtUnixNano = options.longs === String ? $util.Long.prototype.toString.call(message.sampledAtUnixNano) : options.longs === Number ? new $util.LongBits(message.sampledAtUnixNano.low >>> 0, message.sampledAtUnixNano.high >>> 0).toNumber() : message.sampledAtUnixNano;
                        return object;
                    };

                    /**
                     * Converts this Info to JSON.
                     * @function toJSON
                     * @memberof telemetry.module.process.v1.Info
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Info.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Gets the default type url for Info
                     * @function getTypeUrl
                     * @memberof telemetry.module.process.v1.Info
                     * @static
                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                     * @returns {string} The default type url
                     */
                    Info.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                        if (typeUrlPrefix === undefined) {
                            typeUrlPrefix = "type.googleapis.com";
                        }
                        return typeUrlPrefix + "/telemetry.module.process.v1.Info";
                    };

                    return Info;
                })();

                v1.Metrics = (function() {

                    /**
                     * Properties of a Metrics.
                     * @memberof telemetry.module.process.v1
                     * @interface IMetrics
                     * @property {Array.<telemetry.module.process.v1.IInfo>|null} [processes] Metrics processes
                     */

                    /**
                     * Constructs a new Metrics.
                     * @memberof telemetry.module.process.v1
                     * @classdesc Represents a Metrics.
                     * @implements IMetrics
                     * @constructor
                     * @param {telemetry.module.process.v1.IMetrics=} [properties] Properties to set
                     */
                    function Metrics(properties) {
                        this.processes = [];
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Metrics processes.
                     * @member {Array.<telemetry.module.process.v1.IInfo>} processes
                     * @memberof telemetry.module.process.v1.Metrics
                     * @instance
                     */
                    Metrics.prototype.processes = $util.emptyArray;

                    /**
                     * Creates a new Metrics instance using the specified properties.
                     * @function create
                     * @memberof telemetry.module.process.v1.Metrics
                     * @static
                     * @param {telemetry.module.process.v1.IMetrics=} [properties] Properties to set
                     * @returns {telemetry.module.process.v1.Metrics} Metrics instance
                     */
                    Metrics.create = function create(properties) {
                        return new Metrics(properties);
                    };

                    /**
                     * Encodes the specified Metrics message. Does not implicitly {@link telemetry.module.process.v1.Metrics.verify|verify} messages.
                     * @function encode
                     * @memberof telemetry.module.process.v1.Metrics
                     * @static
                     * @param {telemetry.module.process.v1.IMetrics} message Metrics message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Metrics.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.processes != null && message.processes.length)
                            for (let i = 0; i < message.processes.length; ++i)
                                $root.telemetry.module.process.v1.Info.encode(message.processes[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        return writer;
                    };

                    /**
                     * Encodes the specified Metrics message, length delimited. Does not implicitly {@link telemetry.module.process.v1.Metrics.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof telemetry.module.process.v1.Metrics
                     * @static
                     * @param {telemetry.module.process.v1.IMetrics} message Metrics message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Metrics.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Metrics message from the specified reader or buffer.
                     * @function decode
                     * @memberof telemetry.module.process.v1.Metrics
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {telemetry.module.process.v1.Metrics} Metrics
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Metrics.decode = function decode(reader, length, error) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.telemetry.module.process.v1.Metrics();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            if (tag === error)
                                break;
                            switch (tag >>> 3) {
                            case 1: {
                                    if (!(message.processes && message.processes.length))
                                        message.processes = [];
                                    message.processes.push($root.telemetry.module.process.v1.Info.decode(reader, reader.uint32()));
                                    break;
                                }
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Metrics message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof telemetry.module.process.v1.Metrics
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {telemetry.module.process.v1.Metrics} Metrics
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Metrics.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Metrics message.
                     * @function verify
                     * @memberof telemetry.module.process.v1.Metrics
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Metrics.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.processes != null && message.hasOwnProperty("processes")) {
                            if (!Array.isArray(message.processes))
                                return "processes: array expected";
                            for (let i = 0; i < message.processes.length; ++i) {
                                let error = $root.telemetry.module.process.v1.Info.verify(message.processes[i]);
                                if (error)
                                    return "processes." + error;
                            }
                        }
                        return null;
                    };

                    /**
                     * Creates a Metrics message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof telemetry.module.process.v1.Metrics
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {telemetry.module.process.v1.Metrics} Metrics
                     */
                    Metrics.fromObject = function fromObject(object) {
                        if (object instanceof $root.telemetry.module.process.v1.Metrics)
                            return object;
                        let message = new $root.telemetry.module.process.v1.Metrics();
                        if (object.processes) {
                            if (!Array.isArray(object.processes))
                                throw TypeError(".telemetry.module.process.v1.Metrics.processes: array expected");
                            message.processes = [];
                            for (let i = 0; i < object.processes.length; ++i) {
                                if (typeof object.processes[i] !== "object")
                                    throw TypeError(".telemetry.module.process.v1.Metrics.processes: object expected");
                                message.processes[i] = $root.telemetry.module.process.v1.Info.fromObject(object.processes[i]);
                            }
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a Metrics message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof telemetry.module.process.v1.Metrics
                     * @static
                     * @param {telemetry.module.process.v1.Metrics} message Metrics
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Metrics.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.arrays || options.defaults)
                            object.processes = [];
                        if (message.processes && message.processes.length) {
                            object.processes = [];
                            for (let j = 0; j < message.processes.length; ++j)
                                object.processes[j] = $root.telemetry.module.process.v1.Info.toObject(message.processes[j], options);
                        }
                        return object;
                    };

                    /**
                     * Converts this Metrics to JSON.
                     * @function toJSON
                     * @memberof telemetry.module.process.v1.Metrics
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Metrics.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Gets the default type url for Metrics
                     * @function getTypeUrl
                     * @memberof telemetry.module.process.v1.Metrics
                     * @static
                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                     * @returns {string} The default type url
                     */
                    Metrics.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                        if (typeUrlPrefix === undefined) {
                            typeUrlPrefix = "type.googleapis.com";
                        }
                        return typeUrlPrefix + "/telemetry.module.process.v1.Metrics";
                    };

                    return Metrics;
                })();

                v1.SignalCommand = (function() {

                    /**
                     * Properties of a SignalCommand.
                     * @memberof telemetry.module.process.v1
                     * @interface ISignalCommand
                     * @property {number|null} [pid] SignalCommand pid
                     * @property {number|null} [signal] SignalCommand signal
                     */

                    /**
                     * Constructs a new SignalCommand.
                     * @memberof telemetry.module.process.v1
                     * @classdesc Represents a SignalCommand.
                     * @implements ISignalCommand
                     * @constructor
                     * @param {telemetry.module.process.v1.ISignalCommand=} [properties] Properties to set
                     */
                    function SignalCommand(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * SignalCommand pid.
                     * @member {number} pid
                     * @memberof telemetry.module.process.v1.SignalCommand
                     * @instance
                     */
                    SignalCommand.prototype.pid = 0;

                    /**
                     * SignalCommand signal.
                     * @member {number} signal
                     * @memberof telemetry.module.process.v1.SignalCommand
                     * @instance
                     */
                    SignalCommand.prototype.signal = 0;

                    /**
                     * Creates a new SignalCommand instance using the specified properties.
                     * @function create
                     * @memberof telemetry.module.process.v1.SignalCommand
                     * @static
                     * @param {telemetry.module.process.v1.ISignalCommand=} [properties] Properties to set
                     * @returns {telemetry.module.process.v1.SignalCommand} SignalCommand instance
                     */
                    SignalCommand.create = function create(properties) {
                        return new SignalCommand(properties);
                    };

                    /**
                     * Encodes the specified SignalCommand message. Does not implicitly {@link telemetry.module.process.v1.SignalCommand.verify|verify} messages.
                     * @function encode
                     * @memberof telemetry.module.process.v1.SignalCommand
                     * @static
                     * @param {telemetry.module.process.v1.ISignalCommand} message SignalCommand message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SignalCommand.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.pid != null && Object.hasOwnProperty.call(message, "pid"))
                            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.pid);
                        if (message.signal != null && Object.hasOwnProperty.call(message, "signal"))
                            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.signal);
                        return writer;
                    };

                    /**
                     * Encodes the specified SignalCommand message, length delimited. Does not implicitly {@link telemetry.module.process.v1.SignalCommand.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof telemetry.module.process.v1.SignalCommand
                     * @static
                     * @param {telemetry.module.process.v1.ISignalCommand} message SignalCommand message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SignalCommand.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a SignalCommand message from the specified reader or buffer.
                     * @function decode
                     * @memberof telemetry.module.process.v1.SignalCommand
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {telemetry.module.process.v1.SignalCommand} SignalCommand
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SignalCommand.decode = function decode(reader, length, error) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.telemetry.module.process.v1.SignalCommand();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            if (tag === error)
                                break;
                            switch (tag >>> 3) {
                            case 1: {
                                    message.pid = reader.int32();
                                    break;
                                }
                            case 2: {
                                    message.signal = reader.int32();
                                    break;
                                }
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a SignalCommand message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof telemetry.module.process.v1.SignalCommand
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {telemetry.module.process.v1.SignalCommand} SignalCommand
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SignalCommand.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a SignalCommand message.
                     * @function verify
                     * @memberof telemetry.module.process.v1.SignalCommand
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SignalCommand.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.pid != null && message.hasOwnProperty("pid"))
                            if (!$util.isInteger(message.pid))
                                return "pid: integer expected";
                        if (message.signal != null && message.hasOwnProperty("signal"))
                            if (!$util.isInteger(message.signal))
                                return "signal: integer expected";
                        return null;
                    };

                    /**
                     * Creates a SignalCommand message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof telemetry.module.process.v1.SignalCommand
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {telemetry.module.process.v1.SignalCommand} SignalCommand
                     */
                    SignalCommand.fromObject = function fromObject(object) {
                        if (object instanceof $root.telemetry.module.process.v1.SignalCommand)
                            return object;
                        let message = new $root.telemetry.module.process.v1.SignalCommand();
                        if (object.pid != null)
                            message.pid = object.pid | 0;
                        if (object.signal != null)
                            message.signal = object.signal | 0;
                        return message;
                    };

                    /**
                     * Creates a plain object from a SignalCommand message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof telemetry.module.process.v1.SignalCommand
                     * @static
                     * @param {telemetry.module.process.v1.SignalCommand} message SignalCommand
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SignalCommand.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.pid = 0;
                            object.signal = 0;
                        }
                        if (message.pid != null && message.hasOwnProperty("pid"))
                            object.pid = message.pid;
                        if (message.signal != null && message.hasOwnProperty("signal"))
                            object.signal = message.signal;
                        return object;
                    };

                    /**
                     * Converts this SignalCommand to JSON.
                     * @function toJSON
                     * @memberof telemetry.module.process.v1.SignalCommand
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SignalCommand.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Gets the default type url for SignalCommand
                     * @function getTypeUrl
                     * @memberof telemetry.module.process.v1.SignalCommand
                     * @static
                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                     * @returns {string} The default type url
                     */
                    SignalCommand.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                        if (typeUrlPrefix === undefined) {
                            typeUrlPrefix = "type.googleapis.com";
                        }
                        return typeUrlPrefix + "/telemetry.module.process.v1.SignalCommand";
                    };

                    return SignalCommand;
                })();

                return v1;
            })();

            return process;
        })();

        return module;
    })();

    return telemetry;
})();

export { $root as default };
